//////////////////////////////////////////////////////////////////////
/// \mainpage ToolBarControls Documentation
///
/// \section intro_sec Introduction
///
/// %ToolBarControls is a collection of rebar and tool bar ActiveX controls. The \c ReBar control wraps the
/// \c ReBarWindow32 window class and the \c ToolBar control wraps the \c ToolbarWindow32 window class.\n
/// The controls are optimized for Visual Basic 6.0, but should also work in any other environment that
/// supports COM controls.
///
/// \section basics_sec Basics
///
/// The controls superclass the mentioned native window classes of Windows: \c ReBarWindow32 and
/// \c ToolbarWindow32. Although I tried to wrap all features of these window classes (status: Windows 10),
/// some things may be missing. In these cases you usually may use the Win32 API and handle the controls as
/// native windows of the corresponding class. One of my goals was it to create controls that may be
/// controlled via API as well as via the classes that I implemented.
///
/// \section reqs_sec Requirements
///
/// %ToolBarControls ANSI runs on the following operating systems:
/// - Windows XP (SP3 or later) - <strong>limited support</strong>
/// - Windows Server 2003 (SP2 or later) - <strong>limited support</strong>
/// - Windows Vista (SP2 or later) - <strong>limited support</strong>
/// - Windows Server 2008 (SP2 or later) - <strong>limited support</strong>
/// - Windows 7 (SP1 or later) - <strong>limited support</strong>
/// - Windows Server 2008 R2 (SP1 or later) - <strong>limited support</strong>
/// - Windows 8 - <strong>limited support</strong>
/// - Windows Server 2012 - <strong>limited support</strong>
/// - Windows 8.1 - <strong>limited support</strong>
/// - Windows Server 2012 R2 - <strong>limited support</strong>
/// - Windows 10 - <strong>limited support</strong>
/// - Windows Server 2016 - <strong>limited support</strong>
///
/// Some features have additional requirements which are mentioned in the affected feature's
/// documentation.\n
/// Limited support means, that I won't invest much work to support those systems. If a feature works on
/// a system tagged with "limited support" - fine; if it does not and it's easy to fix, I'll fix it, but if
/// it's difficult to fix, I probably won't fix it. Also I will test the control much less on those systems.
///
/// \section support_sec Support
///
/// Although there's no entitlement to support, you've good chances to get help if you either post
/// to the <a href="https://www.timosoft-software.de/forum/viewforum.php?f=44">forums</a> or
/// <a href="mailto:Timo@TimoSoft-Software.de">send me a mail</a>.\n
/// Bugs and feature requests should be entered into the <a href="https://bugtracker.timosoft-software.de">bug tracking system</a>.
///
/// \section lic_sec License
///
/// <pre>
///      MIT License
///
///      Copyright (c) 2011-2018 Timo Kunze
///
///      Permission is hereby granted, free of charge, to any person obtaining a copy
///      of this software and associated documentation files (the "Software"), to deal
///      in the Software without restriction, including without limitation the rights
///      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
///      copies of the Software, and to permit persons to whom the Software is
///      furnished to do so, subject to the following conditions:
///
///      The above copyright notice and this permission notice shall be included in all
///      copies or substantial portions of the Software.
///
///      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
///      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
///      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
///      SOFTWARE.
/// </pre>
///
/// \section acks_sec Acknowledgements
///
/// Thanks go to:
/// - <a href="https://www.winehq.com">Wine Headquarters</a>, because Wine helped me a lot on
///   understanding how Windows is working.
/// - Microsoft, for ATL, WTL and Visual Studio - great libraries and a great IDE
/// - Igor Tandetnik, for his great help on learning ATL and WTL
/// - Dimitri van Heesch, for Doxygen
/// - <a href="http://www.zabkat.com/">Nikos Bozinis</a>, for his awesome help with the Vista drag'n'drop
///   stuff.
/// - <a href="https://www.dateicommander.de">Christian LÃ¼tgens</a>, for his great work as beta-tester
///   and for his help when I needed a 2nd opinion on some decisions.
/// - All donators
/// - For great music: Heaven Shall Burn, Arch Enemy, Machine Head, Trivium, Deadlock, Draconian, Soulfly,
///   Delain, Lacuna Coil, Ensiferum, Epica, Sirenia, Tristania, Nightwish, Battlelore, Amon Amarth, Volbeat,
///   Guns N' Roses
///
/// \section faq_sec FAQ
///
/// <strong>1. Why is the \c Font property ignored?</strong>\n
/// It isn't. My controls have a property \c UseSystemFont which defaults to \c True. This property tells
/// the control to use the system font rather than the font set by the \c Font property.\n
/// Why is this property's default \c True? Well, if I set system wide settings (like fonts) I expect all
/// applications to follow them. Unfortunately ignoring system wide settings seems to be trendy, so see
/// my decision as an educational measure.
///
/// <strong>2. Why is event xyz not fired?</strong>\n
/// Firing an event is relative time-consuming, even if the event isn't handled by the application at all.
/// Therefore I implemented a \c DisabledEvents property which can be used to deactivate certain events.\n
/// By default many events are deactivated.
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
/// \namespace TBarCtlsLibA
/// \brief <em>Contains COM definitions for the controls' public interfaces</em>
///
/// This is the ANSI version of the ToolBarControls COM library.
//////////////////////////////////////////////////////////////////////


#include "olectl.h"
#include "CompilerFlags.h"
#include "DispIDs.h"

#ifndef DOXYGEN_SHOULD_SKIP_THIS
	// interface is not automation marshaling conformant, requires Windows NT 4.0 SP4 or greater
	midl_pragma warning(disable: 2039)
	// identifier length exceeds 31 characters
	midl_pragma warning(disable: 2111)
	// too many methods in the interface, requires Windows NT 4.0 SP3 or greater
	midl_pragma warning(disable: 2362)
#endif

import "oaidl.idl";
import "ocidl.idl";


[
	uuid(C5AB19C0-2E5A-4097-91EF-61EFA3AC27E7),
	version(1.3),
	helpstring("TimoSoft ToolBarControls 1.3 (ANSI)")
]
library TBarCtlsLibA
{
	importlib("stdole2.tlb");


	/// \brief <em>Constants used with the \c Appearance properties</em>
	///
	/// \sa IReBar::Appearance, IToolBar::Appearance
	[helpstring("Constants used with the 'Appearance' properties.")]
	typedef enum AppearanceConstants {
		/// \brief The control is drawn with a flat border
		[helpstring("The control is drawn flat.")]
		a2D,
		/// \brief The control is drawn with a normal 3D border
		[helpstring("The control is drawn with a normal 3D border.")]
		a3D,
		/// \brief The control is drawn with a light 3D border
		[helpstring("The control is drawn with a light 3D border.")]
		a3DLight
	} AppearanceConstants;

	/// \brief <em>Constants used with the \c BackStyle property</em>
	///
	/// \sa IToolBar::BackStyle
	[helpstring("Constants used with the 'BackStyle' property.")]
	typedef enum BackStyleConstants {
		/// \brief The control is drawn with a transparent background
		[helpstring("The control is drawn with a transparent background.")]
		bksTransparent,
		/// \brief The control is drawn without an opaque background
		[helpstring("The control is drawn without an opaque background.")]
		bksOpaque
	} BackStyleConstants;

	/// \brief <em>Constants used to identify bands within an \c IReBarBands collection</em>
	///
	/// \sa IReBarBands
	[helpstring("Constants used to identify bands within a 'ReBarBands' collection.")]
	typedef enum BandIdentifierTypeConstants {
		/// \brief The band is identified by an unique ID
		///
		/// A band's ID will never change.
		///
		/// \sa IReBarBand::ID
		[helpstring("The band is identified by an unique ID.")]
		bitID,
		/// \brief The band is identified by a zero-based index
		///
		/// Reordering the bands won't change a band's index, but removing or adding new bands may do so.
		///
		/// \remarks This is the preferred and fastest method to identify a band.
		///
		/// \sa IReBarBand::Index
		[helpstring("The band is identified by a zero-based index.")]
		bitIndex
	} BandIdentifierTypeConstants;

	/// \brief <em>Constants used with the \c IReBarBand::GetRectangle method</em>
	///
	/// \sa IReBarBand::GetRectangle
	[helpstring("Constants used with the 'ReBarBand.GetRectangle' method.")]
	typedef enum BandRectangleTypeConstants {
		/// \brief The rectangle surrounds the entire band
		///
		/// The rectangle is the bounding rectangle around the entire band, including the title.
		[helpstring("The rectangle is the bounding rectangle around the entire band, including the title.")]
		brtBand = 0,
		/// \brief The rectangle surrounds the contained window
		///
		/// The rectangle is the bounding rectangle around the window contained in the band.
		[helpstring("The rectangle is the bounding rectangle around the window contained in the band.")]
		brtContainedWindow = 4
	} BandRectangleTypeConstants;

	/// \brief <em>Constants used with the \c BorderStyle properties</em>
	///
	/// \sa IReBar::BorderStyle, IToolBar::BorderStyle
	[helpstring("Constants used with the 'BorderStyle' properties.")]
	typedef enum BorderStyleConstants {
		/// \brief The control is drawn without an inner border
		[helpstring("The control is drawn without an additional border.")]
		bsNone,
		/// \brief The control is drawn with an inner border
		[helpstring("The control is drawn with an additional border.")]
		bsFixedSingle
	} BorderStyleConstants;

	/// \brief <em>Constants used to identify buttons within an \c IToolBarButtons collection</em>
	///
	/// \sa IToolBarButtons
	[helpstring("Constants used to identify buttons within a 'ToolBarButtons' collection.")]
	typedef enum ButtonIdentifierTypeConstants {
		/// \brief The button is identified by an unique ID
		///
		/// A button's ID will never change.
		///
		/// \sa IToolBarButton::ID
		[helpstring("The button is identified by an unique ID.")]
		btitID,
		/// \brief The button is identified by a zero-based index
		///
		/// Reordering the buttons won't change a button's index, but removing or adding new buttons may do so.
		///
		/// \remarks This is the preferred and fastest method to identify a button.
		///
		/// \sa IToolBarButton::Index
		[helpstring("The button is identified by a zero-based index.")]
		btitIndex
	} ButtonIdentifierTypeConstants;

	/// \brief <em>Constants used with the \c IToolBarButton::GetRectangle method</em>
	///
	/// \sa IToolBarButton::GetRectangle
	[helpstring("Constants used with the 'ToolBarButton.GetRectangle' method.")]
	typedef enum ButtonRectangleTypeConstants {
		/// \brief Retrieve the bounding rectangle of the tool bar button
		[helpstring("Retrieve the bounding rectangle of the tool bar button.")]
		brtButton = 0,
		/// \brief Retrieve the bounding rectangle of the tool bar button's drop-down window
		[helpstring("Retrieve the bounding rectangle of the tool bar button's drop-down window.")]
		brtDropDown = 1
	} ButtonRectangleTypeConstants;

	/// \brief <em>Constants used with the \c IToolBar::ButtonStyle property</em>
	///
	/// \sa IToolBar::ButtonStyle
	[helpstring("Constants used with the 'ToolBar.ButtonStyle' property.")]
	typedef enum ButtonStyleConstants {
		/// \brief Buttons appear like command buttons
		[helpstring("The buttons appear like command buttons, i. e. with a three-dimensional border.")]
		bst3D,
		/// \brief Buttons appear flat
		[helpstring("The buttons appear flat and a thin border is drawn around the button below the mouse.")]
		bstFlat
	} ButtonStyleConstants;

	/// \brief <em>Constants used with the \c IToolBar::ButtonTextPosition property</em>
	///
	/// \sa IToolBar::ButtonTextPosition
	[helpstring("Constants used with the 'ToolBar.ButtonTextPosition' property.")]
	typedef enum ButtonTextPositionConstants {
		/// \brief Button captions are drawn below the button icons
		[helpstring("The button captions are drawn below the button icons.")]
		btpBelowIcon,
		/// \brief Button captions are drawn to the right of the button icons
		[helpstring("The button captions are drawn to the right of the button icons.")]
		btpRightToIcon
	} ButtonTextPositionConstants;

	/// \brief <em>Constants used with the \c IToolBarButton::ButtonType property</em>
	///
	/// \sa IToolBarButton::ButtonType
	[helpstring("Constants used with the 'ToolBarButton.ButtonType' property.")]
	typedef enum ButtonTypeConstants {
		/// \brief The button is a normal push button
		///
		/// \sa IToolBarButton::Pushed
		[helpstring("The button is a normal push button.")]
		btyCommandButton,
		/// \brief The button is a check button, similar to a check box
		///
		/// \remarks Among all consecutive buttons that are part of a group, only one button can be checked.
		///          A check button that is part of a group cannot be unchecked by simply clicking it a
		///          second time. This can be used to create option-button like behavior.
		///
		/// \sa IToolBarButton::SelectionState, IToolBarButton::PartOfGroup
		[helpstring("The button is a check button, similar to a check box.")]
		btyCheckButton,
		/// \brief The button is a separator, used to separate button groups from each other
		[helpstring("The button is a separator, used to separate button groups from each other.")]
		btySeparator,
		/// \brief The button is a placeholder, used to consume space that will be covered by another control
		[helpstring("The button is a placeholder, used to consume space that will be covered by another control.")]
		btyPlaceholder
	} ButtonTypeConstants;

	/// \brief <em>Constants used with the \c ExecuteCommand event</em>
	///
	/// \sa _IToolBarEvents::ExecuteCommand
	[helpstring("Constants used with the 'ExecuteCommand' event.")]
	typedef enum CommandOriginConstants {
		/// \brief The command was triggered by clicking a button
		[helpstring("The command was triggered by clicking a button.")]
		coButton,
		/// \brief The command was triggered by clicking a menu item
		///
		/// \sa IToolBar::MenuMode
		[helpstring("The command was triggered by clicking a menu item.")]
		coMenu,
		/// \brief The command was triggered by pressing a registered hotkey
		///
		/// \sa IToolBar::RegisterHotkey
		[helpstring("The command was triggered by pressing a registered hotkey.")]
		coHotkey
	} CommandOriginConstants;

	/// \brief <em>Constants used to identify item and band states during custom draw</em>
	///
	/// \sa CustomDrawStageConstants, CustomDrawReturnValuesConstants, _IReBarEvents::CustomDraw,
	///     _IToolBarEvents::CustomDraw
	[helpstring("Constants used to identify item and band states during custom draw.")]
	typedef enum CustomDrawItemStateConstants {
		/// \brief The button or band is selected
		///
		/// \remarks Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band is selected. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisSelected = 0x1 /*CDIS_SELECTED*/,
		/// \brief The button or band is grayed
		///
		/// \remarks Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band is grayed. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisGrayed = 0x2 /*CDIS_GRAYED*/,
		/// \brief The button or band is disabled
		///
		/// \remarks Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band is disabled. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisDisabled = 0x4 /*CDIS_DISABLED*/,
		/// \brief The button or band is checked
		///
		/// \remarks Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band is checked. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisChecked = 0x8 /*CDIS_CHECKED*/,
		/// \brief The button or band has the keyboard focus
		///
		/// \remarks Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band has the keyboard focus. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisFocus = 0x10 /*CDIS_FOCUS*/,
		/// \brief The button or band is in its default state
		///
		/// \remarks Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band is in its default state. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisDefault = 0x20 /*CDIS_DEFAULT*/,
		/// \brief The button or band is currently under the mouse cursor
		///
		/// \remarks Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band is hot, i. e. it's currently under the mouse cursor. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisHot = 0x40 /*CDIS_HOT*/,
		/// \brief The button or band is marked
		///
		/// \remarks Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band is marked. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisMarked = 0x80 /*CDIS_MARKED*/,
		/// \brief The button or band is in an indeterminate state
		///
		/// \remarks Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band is in an indeterminate state. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisIndeterminate = 0x100 /*CDIS_INDETERMINATE*/,
		/// \brief The button or band is a keyboard cue
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.\n
		///          Current versions of Windows probably do not use this flag for rebar bands.
		[helpstring("The button or band is a keyboard cue. Requires comctl32.dll version 6.0 or higher. Current versions of Windows probably do not use this flag for rebar bands.")]
		cdisShowKeyboardCues = 0x200 /*CDIS_SHOWKEYBOARDCUES*/
	} CustomDrawItemStateConstants;

	/// \brief <em>Flags used to control further custom draw processing</em>
	///
	/// \sa CustomDrawItemStateConstants, CustomDrawStageConstants, _IReBarEvents::CustomDraw,
	///     _IToolBarEvents::CustomDraw
	[helpstring("Flags used to control further custom draw processing. They can be combined.")]
	typedef enum CustomDrawReturnValuesConstants {
		/// \brief Don't use custom draw
		///
		/// Advises the control to draw itself and to not raise any further custom draw events during the
		/// current paint cycle.
		[helpstring("Default processing will take place.")]
		cdrvDoDefault = 0x0 /*CDRF_DODEFAULT*/,
		/// \brief Use different font and colors
		///
		/// Advises the control to draw the button or band using the specified font and colors.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsItemPrePaint.\n
		///          This flag doesn't seem to be valid for rebar controls.
		[helpstring("Default processing will take place using the specified font and colors. This flag doesn't seem to be valid for rebar controls.")]
		cdrvNewFont = 0x2 /*CDRF_NEWFONT*/,
		/// \brief Don't draw the button or band
		///
		/// Advises the control to not draw the button or band. Use this to draw the element entirely yourself.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsItemPrePaint.
		[helpstring("The control won't draw the button or band.")]
		cdrvSkipDefault = 0x4 /*CDRF_SKIPDEFAULT*/,
		/// \brief Fire the custom draw event after drawing took place
		///
		/// Advises the control to fire the custom draw event after drawing took place.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsPrePaint.
		[helpstring("Fire the custom draw event after drawing took place.")]
		cdrvNotifyPostPaint = 0x10 /*CDRF_NOTIFYPOSTPAINT*/,
		/// \brief Fire the custom draw event for button or band related drawing operations
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsPrePaint.
		[helpstring("Fire the custom draw event for button or band related drawing operations.")]
		cdrvNotifyItemDraw = 0x20 /*CDRF_NOTIFYITEMDRAW*/,
		/// \brief Fire the custom draw event for sub-item related drawing operations
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsItemPrePaint.\n
		///          This flag is not valid for rebar controls and tool bar controls.
		[helpstring("Fire the custom draw event for sub-item related drawing operations. This flag is not valid for rebar controls and tool bar controls.")]
		cdrvNotifySubItemDraw = 0x20 /*CDRF_NOTIFYSUBITEMDRAW*/,
		/// \brief Fire the custom draw event after erasing took place
		///
		/// Advises the control to fire the custom draw event after erasing took place.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsPrePaint.
		[helpstring("Fire the custom draw event after erasing took place.")]
		cdrvNotifyPostErase = 0x40 /*CDRF_NOTIFYPOSTERASE*/,
		/// \brief Fire the custom draw event for band related erasing operations
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsPrePaint.
		[helpstring("Fire the custom draw event for band related erasing operations.")]
		cdrvNotifyItemErase = 0x80 /*CDRF_NOTIFYITEMERASE*/,
		/// \brief Don't draw the edges of the button
		///
		/// Advises the control to not draw the button's edges.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsItemPrePaint.\n
		///          This flag is not valid for rebar controls.
		[helpstring("Don't draw the button's edges. This flag is not valid for rebar controls.")]
		cdrvDontDrawButtonEdges = 0x00010000 /*TBCDRF_NOEDGES*/,
		/// \brief Use the color specified by the \c hotButtonBackColor parameter to draw the button background if it is in hot state
		///
		/// Advises the control to use the color specified by the \c hotButtonBackColor parameter to draw the
		/// button background if it is in hot state.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsItemPrePaint.\n
		///          This flag is not valid for rebar controls.
		[helpstring("Use the color specified by the 'hotButtonBackColor' parameter to draw the button background if it is in hot state. This flag is not valid for rebar controls.")]
		cdrvUseHotButtonBackColor = 0x00020000 /*TBCDRF_HILITEHOTTRACK*/,
		/// \brief Don't offset the button's caption if it is in pushed state
		///
		/// Advises the control to not offset the button's caption if it is in pushed state.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsItemPrePaint.\n
		///          This flag is not valid for rebar controls.
		[helpstring("Don't offset the button's caption if it is in pushed state. This flag is not valid for rebar controls.")]
		cdrvDontOffsetIfPushed = 0x00040000 /*TBCDRF_NOOFFSET*/,
		/// \brief Don't apply the default highlighting if the button is in marked state
		///
		/// Advises the control to not apply the default highlighting if the button is in marked state.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsItemPrePaint.\n
		///          This flag is not valid for rebar controls.
		[helpstring("Don't apply the default highlighting if the button is in marked state. This flag is not valid for rebar controls.")]
		cdrvDontHighlightIfMarked = 0x00080000 /*TBCDRF_NOMARK*/,
		/// \brief Don't apply the default 3D effect if the button is in disabled state
		///
		/// Advises the control to not apply the default 3D effect if the button is in disabled state.
		///
		/// \remarks This flag is ignored if the control is themed.\n
		///          This flag is valid if the custom draw stage equals \c cdsItemPrePaint.\n
		///          This flag is not valid for rebar controls.
		[helpstring("Don't apply the default 3D effect if the button is in disabled state. This flag is ignored if the control is themed. This flag is not valid for rebar controls.")]
		cdrvNoEtchedEffectIfDisabled = 0x00100000 /*TBCDRF_NOETCHEDEFFECT*/,
		/// \brief Blend the button's icon with the background
		///
		/// Advises the control to blend the button's icon with the background by 50 percent.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsItemPrePaint.\n
		///          This flag is not valid for rebar controls.
		[helpstring("Blend the button's icon with the background by 50 percent. This flag is not valid for rebar controls.")]
		cdrvBlendIconWithBackground = 0x00200000 /*TBCDRF_BLENDICON*/,
		/// \brief Don't draw the button's background
		///
		/// Advises the control to not draw the button's background.
		///
		/// \remarks This flag is valid if the custom draw stage equals \c cdsItemPrePaint.\n
		///          This flag is not valid for rebar controls.
		[helpstring("Skip drawing the button's background. This flag is not valid for rebar controls.")]
		cdrvDontDrawBackground = 0x00400000 /*TBCDRF_NOBACKGROUND*/,
		/// \brief Use the specified colors even if the control is themed
		///
		/// Advises the control to ignore the visual style and use the colors specified by the \c CustomDraw
		/// event.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.\n
		///          This flag is not valid for rebar controls.
		[helpstring("Skip drawing the button's background. Requires comctl32.dll version 6.10 or higher. This flag is not valid for rebar controls.")]
		cdrvUseCustomDrawColorsIfThemed = 0x00800000 /*TBCDRF_USECDCOLORS*/
	} CustomDrawReturnValuesConstants;

	/// \brief <em>Constants used to identify custom draw stages</em>
	///
	/// \sa CustomDrawItemStateConstants, CustomDrawReturnValuesConstants, _IReBarEvents::CustomDraw,
	///     _IToolBarEvents::CustomDraw
	[helpstring("Constants used to identify custom draw stages.")]
	typedef enum CustomDrawStageConstants {
		/// \brief Before the painting cycle begins
		[helpstring("Before the painting cycle begins.")]
		cdsPrePaint = 0x1 /*CDDS_PREPAINT*/,
		/// \brief After the painting cycle is complete
		[helpstring("After the painting cycle is complete.")]
		cdsPostPaint = 0x2 /*CDDS_POSTPAINT*/,
		/// \brief Before the erasing cycle begins
		///
		/// \remarks For the \c ToolBar control the \c CustomDraw event is raised with this draw stage only if
		///          the \c RaiseCustomDrawEventOnEraseBackground property is set to \c True.
		///
		/// \sa IToolBar::RaiseCustomDrawEventOnEraseBackground
		[helpstring("Before the erasing cycle begins.")]
		cdsPreErase = 0x3 /*CDDS_PREERASE*/,
		/// \brief After the erasing cycle is complete
		///
		/// \remarks For the \c ToolBar control the \c CustomDraw event is raised with this draw stage only if
		///          the \c RaiseCustomDrawEventOnEraseBackground property is set to \c True.
		///
		/// \sa IToolBar::RaiseCustomDrawEventOnEraseBackground
		[helpstring("After the erasing cycle is complete.")]
		cdsPostErase = 0x4 /*CDDS_POSTERASE*/,
		/// \brief The event affects a single button or band only and not the whole control
		[helpstring("The event affects a single button or band only and not the whole control.")]
		cdsItem = 0x10000 /*CDDS_ITEM*/,
		/// \brief Before a button or band is drawn
		[helpstring("Before a button or band is drawn.")]
		cdsItemPrePaint = cdsItem | cdsPrePaint /*CDDS_ITEMPREPAINT*/,
		/// \brief After a button or band has been drawn
		[helpstring("After a button or band has been drawn.")]
		cdsItemPostPaint = cdsItem | cdsPostPaint /*CDDS_ITEMPOSTPAINT*/,
		/// \brief Before a button or band is erased
		[helpstring("Before a button or band is erased.")]
		cdsItemPreErase = cdsItem | cdsPreErase /*CDDS_ITEMPREERASE*/,
		/// \brief After a button or band has been erased
		[helpstring("After a button or band has been erased.")]
		cdsItemPostErase = cdsItem | cdsPostErase /*CDDS_ITEMPOSTERASE*/,
		/// \brief The event affects a single sub-item only and not the whole item
		///
		/// \remarks This flag is not valid for rebar controls and tool bar controls.
		[helpstring("The event affects a single sub-item only and not the whole item. This flag is not valid for rebar controls and tool bar controls.")]
		cdsSubItem = 0x20000 /*CDDS_SUBITEM*/,
		/// \brief Before a sub-item is drawn
		///
		/// \remarks This flag is not valid for rebar controls and tool bar controls.
		[helpstring("Before a sub-item is drawn. This flag is not valid for rebar controls and tool bar controls.")]
		cdsSubItemPrePaint = cdsSubItem | cdsItemPrePaint /*CDDS_SUBITEM | CDDS_ITEMPREPAINT*/,
		/// \brief After a sub-item has been drawn
		///
		/// \remarks This flag is not valid for rebar controls and tool bar controls.
		[helpstring("After a sub-item has been drawn. This flag is not valid for rebar controls and tool bar controls.")]
		cdsSubItemPostPaint = cdsSubItem | cdsItemPostPaint /*CDDS_SUBITEM | CDDS_ITEMPOSTPAINT*/,
		/// \brief The event affects the chevron popup tool bar
		///
		/// \remarks This flag is not valid for rebar controls.
		[helpstring("The event affects the chevron popup tool bar. This flag is not valid for rebar controls.")]
		cdsChevronPopupToolbar = 0x80000000
	} CustomDrawStageConstants;

	/// \brief <em>Flags used with the \c DisabledEvents properties</em>
	///
	/// \sa IReBar::DisabledEvents, IToolBar::DisabledEvents
	[helpstring("Flags used with the 'DisabledEvents' properties. They can be combined.")]
	typedef enum DisabledEventsConstants {
		/// \brief Mouse events won't be fired
		///
		/// The following events won't be fired: \c MouseDown, \c MouseUp, \c MouseEnter, \c MouseHover,
		/// \c MouseLeave, \c BandMouseEnter, \c BandMouseLeave, \c ButtonMouseEnter, \c ButtonMouseLeave,
		/// \c MouseMove
		///
		/// \sa _IReBarEvents::MouseDown, _IReBarEvents::MouseUp, _IReBarEvents::MouseEnter,
		///     _IReBarEvents::MouseHover, _IReBarEvents::MouseLeave, _IReBarEvents::BandMouseEnter,
		///     _IReBarEvents::BandMouseLeave, _IReBarEvents::MouseMove, _IReBarEvents::NonClientHitTest,
		///     _IToolBarEvents::MouseDown, _IToolBarEvents::MouseUp, _IToolBarEvents::MouseEnter,
		///     _IToolBarEvents::MouseHover, _IToolBarEvents::MouseLeave, _IToolBarEvents::ButtonMouseEnter,
		///     _IToolBarEvents::ButtonMouseLeave, _IToolBarEvents::MouseMove
		[helpstring("Disables the following events: MouseDown, MouseUp, MouseEnter, MouseHover, MouseLeave, BandMouseEnter, BandMouseLeave, ButtonMouseEnter, ButtonMouseLeave, MouseMove, NonClientHitTest")]
		deMouseEvents = 0x01,
		/// \brief Click events won't be fired
		///
		/// The following events won't be fired: \c Click, \c DblClick, \c MClick, \c MDblClick,
		/// \c RClick, \c RDblClick, \c XClick, \c XDblClick
		///
		/// \sa _IReBarEvents::Click, _IReBarEvents::DblClick, _IReBarEvents::MClick, _IReBarEvents::MDblClick,
		///     _IReBarEvents::RClick, _IReBarEvents::RDblClick, _IReBarEvents::XClick,
		///     _IReBarEvents::XDblClick,
		///     _IToolBarEvents::Click, _IToolBarEvents::DblClick, _IToolBarEvents::MClick,
		///     _IToolBarEvents::MDblClick, _IToolBarEvents::RClick, _IToolBarEvents::RDblClick,
		///     _IToolBarEvents::XClick, _IToolBarEvents::XDblClick
		[helpstring("Disables the following events: Click, DblClick, MClick, MDblClick, RClick, RDblClick, XClick, XDblClick")]
		deClickEvents = 0x02,
		/// \brief Keyboard events won't be fired
		///
		/// The following events won't be fired: \c KeyDown, \c KeyUp, \c KeyPress
		///
		/// \sa _IToolBarEvents::KeyDown, _IToolBarEvents::KeyUp, _IToolBarEvents::KeyPress
		[helpstring("Disables the following events: KeyDown, KeyUp, KeyPress")]
		deKeyboardEvents = 0x08,
		/// \brief Events concerning band-insertions won't be fired
		///
		/// The following events won't be fired: \c InsertingBand, \c InsertedBand
		///
		/// \sa _IReBarEvents::InsertingBand, _IReBarEvents::InsertedBand
		[helpstring("Disables the following events: InsertingBand, InsertedBand")]
		deBandInsertionEvents = 0x20,
		/// \brief Events concerning button-insertions won't be fired
		///
		/// The following events won't be fired: \c InsertingButton, \c InsertedButton
		///
		/// \sa _IToolBarEvents::InsertingButton, _IToolBarEvents::InsertedButton
		[helpstring("Disables the following events: InsertingButton, InsertedButton")]
		deButtonInsertionEvents = 0x20,
		/// \brief Events concerning band-deletions won't be fired
		///
		/// The following events won't be fired: \c RemovingBand, \c RemovedBand
		///
		/// \sa _IReBarEvents::RemovingBand, _IReBarEvents::RemovedBand
		[helpstring("Disables the following events: RemovingBand, RemovedBand")]
		deBandDeletionEvents = 0x40,
		/// \brief Events concerning button-deletions won't be fired
		///
		/// The following events won't be fired: \c RemovingButton, \c RemovedButton
		///
		/// \sa _IToolBarEvents::RemovingButton, _IToolBarEvents::RemovedButton
		[helpstring("Disables the following events: RemovingButton, RemovedButton")]
		deButtonDeletionEvents = 0x40,
		/// \brief The \c FreeBandData event won't be fired
		///
		/// The following event won't be fired: \c FreeBandData
		///
		/// \sa _IReBarEvents::FreeBandData
		[helpstring("Disables the following event: FreeBandData")]
		deFreeBandData = 0x80,
		/// \brief The \c FreeButtonData event won't be fired
		///
		/// The following event won't be fired: \c FreeButtonData
		///
		/// \sa _IToolBarEvents::FreeButtonData
		[helpstring("Disables the following event: FreeButtonData")]
		deFreeButtonData = 0x80,
		/// \brief The \c CustomDraw event won't be fired
		///
		/// The following event won't be fired: \c CustomDraw
		///
		/// \sa _IReBarEvents::CustomDraw,
		///     _IToolBarEvents::CustomDraw
		[helpstring("Disables the following event: CustomDraw")]
		deCustomDraw = 0x100,
		/// \brief Events concerning hot button changes won't be fired
		///
		/// The following events won't be fired: \c HotButtonChangeWrapping, \c HotButtonChanging
		///
		/// \sa _IToolBarEvents::HotButtonChangeWrapping, _IToolBarEvents::HotButtonChanging
		[helpstring("Disables the following events: HotButtonChangeWrapping, HotButtonChanging")]
		deHotButtonChangeEvents = 0x20000,
		/// \brief Events concerning keyboard accelerators won't be fired
		///
		/// The following events won't be fired: \c IsDuplicateAccelerator, \c MapAccelerator
		///
		/// \sa _IToolBarEvents::IsDuplicateAccelerator, _IToolBarEvents::MapAccelerator
		[helpstring("Disables the following events: IsDuplicateAccelerator, MapAccelerator")]
		deAcceleratorEvents = 0x40000,
		/// \brief The \c RawMenuMessage event won't be fired
		///
		/// The following event won't be fired: \c RawMenuMessage
		///
		/// \sa _IReBarEvents::RawMenuMessage,
		///     _IToolBarEvents::RawMenuMessage
		[helpstring("Disables the following event: RawMenuMessage")]
		deRawMenuMessage = 0x80000
	} DisabledEventsConstants;

	/// \brief <em>Constants used with the \c IToolBar::DragDropCustomizationModifierKey property</em>
	///
	/// \sa IToolBar::DragDropCustomizationModifierKey
	[helpstring("Constants used with the 'ToolBar.DragDropCustomizationModifierKey' property.")]
	typedef enum DragDropCustomizationModifierKeyConstants {
		/// \brief The [SHIFT] key must be pressed while dragging a button to move its position
		[helpstring("The [SHIFT] key must be pressed while dragging a button to move its position.")]
		ddcmkShift = 0,
		/// \brief The [ALT] key must be pressed while dragging a button to move its position
		[helpstring("The [ALT] key must be pressed while dragging a button to move its position.")]
		ddcmkAlt
	} DragDropCustomizationModifierKeyConstants;

	/// \brief <em>Constants used with the \c IOLEDataObject::GetDropDescription and IOLEDataObject::SetDropDescription methods</em>
	///
	/// \sa IOLEDataObject::GetDropDescription, IOLEDataObject::SetDropDescription
	[helpstring("Constants used with the 'OLEDataObject.GetDropDescription' and 'OLEDataObject.SetDropDescription' methods.")]
	typedef enum DropDescriptionIconConstants {
		/// \brief No drop description is displayed
		[helpstring("No drop description is displayed.")]
		ddiNone = -1/*DROPIMAGE_INVALID*/,     // should be 8 (DROPIMAGE_NOIMAGE)
		/// \brief The drop description icon that visualizes the \c odeNone drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeNone' drop effect is displayed.")]
		ddiNoDrop = 0/*DROPIMAGE_NONE*/,
		/// \brief The drop description icon that visualizes the \c odeCopy drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeCopy' drop effect is displayed.")]
		ddiCopy = 1/*DROPIMAGE_COPY*/,
		/// \brief The drop description icon that visualizes the \c odeMove drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeMove' drop effect is displayed.")]
		ddiMove = 2/*DROPIMAGE_MOVE*/,
		/// \brief The drop description icon that visualizes the \c odeLink drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeLink' drop effect is displayed.")]
		ddiLink = 4/*DROPIMAGE_LINK*/,
		/// \brief The drop description icon that visualizes a drop, which causes a metadata change, is displayed
		[helpstring("The drop description icon that visualizes a drop, which causes a metadata change, is displayed.")]
		ddiMetadataChange = 6/*DROPIMAGE_LABEL*/,
		/// \brief The drop description icon that visualizes a warning is displayed
		[helpstring("The drop description icon that visualizes a warning is displayed.")]
		ddiWarning = 7/*DROPIMAGE_WARNING*/,
		/// \brief The default drop description is displayed
		///
		/// \remarks Requires Windows 7 or newer.
		[helpstring("The default drop description is displayed. Requires Windows 7 or newer.")]
		ddiUseDefault = 8/*DROPIMAGE_NOIMAGE*/     // should be -1 (DROPIMAGE_INVALID)
	} DropDescriptionIconConstants;

	/// \brief <em>Constants used to control further drop-down button click processing</em>
	///
	/// \sa _IToolBarEvents::DropDown
	[helpstring("Constants used to control further drop-down button click processing.")]
	typedef enum DropDownReturnValuesConstants {
		/// \brief Reset the button's or its drop-down section's pressed state and do not raise the \c ExecuteCommand event
		///
		/// Resets the button's or its drop-down section's pressed state. The \c ExecuteCommand event won't be
		/// raised.
		///
		/// \sa _IToolBarEvents::ExecuteCommand
		[helpstring("Resets the button's or its drop-down section's pressed state. The 'ExecuteCommand' event won't be raised.")]
		ddrvDoDefault = 0/*TBDDRET_DEFAULT*/,
		/// \brief Don't reset the button's or its drop-down section's pressed state and raise the \c ExecuteCommand event
		///
		/// Doesn't reset the button's or its drop-down section's pressed state. The \c ExecuteCommand event
		/// will be raised.
		///
		/// \sa _IToolBarEvents::ExecuteCommand
		[helpstring("Doesn't reset the button's or its drop-down section's pressed state. The 'ExecuteCommand' event will be raised.")]
		ddrvSkipDefault = 1/*TBDDRET_NODEFAULT*/,
		/// \brief Reset the button's or its drop-down section's pressed state and raise the \c ExecuteCommand event
		///
		/// Resets the button's or its drop-down section's pressed state. The \c ExecuteCommand event will be
		/// raised.
		///
		/// \sa _IToolBarEvents::ExecuteCommand
		[helpstring("Resets the button's or its drop-down section's pressed state. The 'ExecuteCommand' event will be raised.")]
		ddrvExecuteCommand = 2/*TBDDRET_TREATPRESSED*/
	} DropDownReturnValuesConstants;

	/// \brief <em>Constants used with the \c IToolBarButton::DropDownStyle property</em>
	///
	/// \sa IToolBarButton::DropDownStyle
	[helpstring("Constants used with the 'ToolBarButton.DropDownStyle' property.")]
	typedef enum DropDownStyleConstants {
		/// \brief The button does not have a drop-down menu
		[helpstring("The button does not have a drop-down menu.")]
		ddstNoDropDown,
		/// \brief The button is a drop-down button that might have a separate drop-down arrow section
		///
		/// The button is a drop-down button, i. e. a drop-down menu will be displayed if the button is
		/// clicked. Depending on the setting of the \c IToolBar::NormalDropDownButtonStyle property, the
		/// drop-down arrow is displayed to the button's right in a separate section, or no drop-down arrow is
		/// displayed at all.
		///
		/// \sa IToolBar::NormalDropDownButtonStyle
		[helpstring("The button is a drop-down button. Depending on the setting of the 'ToolBar.NormalDropDownButtonStyle' property, the drop-down arrow is displayed to the button's right in a separate section, or no drop-down arrow is displayed at all.")]
		ddstNormal,
		/// \brief The button is a drop-down button that never has a separate drop-down arrow section
		///
		/// The button is a drop-down button, i. e. a drop-down menu will be displayed if the button is
		/// clicked. Regardless of the setting of the \c IToolBar::NormalDropDownButtonStyle property, the
		/// drop-down arrow is displayed within the button itself.
		///
		/// \sa IToolBar::NormalDropDownButtonStyle
		[helpstring("The button is a drop-down button. Regardless of the setting of the 'ToolBar.NormalDropDownButtonStyle' property, the drop-down arrow is displayed within the button itself.")]
		ddstAlwaysWholeButton
	} DropDownStyleConstants;

	/// \brief <em>Constants used with the extended mouse button events</em>
	///
	/// \sa _IReBarEvents::MouseDown, _IReBarEvents::MouseEnter, _IReBarEvents::MouseHover,
	///     _IReBarEvents::MouseLeave, _IReBarEvents::MouseMove, _IReBarEvents::MouseUp,
	///     _IReBarEvents::BandMouseEnter, _IReBarEvents::BandMouseLeave,
	///     _IReBarEvents::XClick, _IReBarEvents::XDblClick,
	///     _IToolBarEvents::MouseDown, _IToolBarEvents::MouseEnter, _IToolBarEvents::MouseHover,
	///     _IToolBarEvents::MouseLeave, _IToolBarEvents::MouseMove, _IToolBarEvents::MouseUp,
	///     _IToolBarEvents::ButtonMouseEnter, _IToolBarEvents::ButtonMouseLeave,
	///     _IToolBarEvents::XClick, _IToolBarEvents::XDblClick
	[helpstring("Constants used with the extended mouse button events.")]
	typedef enum ExtendedMouseButtonConstants {
		/// \brief Identifies the first extended mouse button
		[helpstring("Identifies the first extended mouse button.")]
		embXButton1 = 0x20,
		/// \brief Identifies the second extended mouse button
		[helpstring("Identifies the second extended mouse button.")]
		embXButton2 = 0x40
	} ExtendedMouseButtonConstants;

	/// \brief <em>Constants used with the \c Filter properties</em>
	///
	/// \sa IReBarBands::Filter, IToolBarButtons::Filter
	[helpstring("Constants used with the 'Filter' properties.")]
	typedef enum FilteredPropertyConstants {
		/// \brief Retrieve or set the filter that filters by the \c PartOfGroup property
		///
		/// \sa IToolBarButton::PartOfGroup
		[helpstring("Retrieve or set the filter that filters by the 'PartOfGroup' property.")]
		fpPartOfGroup = 3,
		/// \brief Retrieve or set the filter that filters by the \c IconIndex property
		///
		/// \sa IReBarBand::IconIndex, IToolBarButton::IconIndex
		[helpstring("Retrieve or set the filter that filters by the 'IconIndex' property.")]
		fpIconIndex = 4,
		/// \brief Retrieve or set the filter that filters by the \c Index property
		///
		/// \sa IReBarBand::Index, IToolBarButton::Index
		[helpstring("Retrieve or set the filter that filters by the 'Index' property.")]
		fpIndex = 6,
		/// \brief Retrieve or set the filter that filters by the \c BandData property
		///
		/// \sa IReBarBand::BandData
		[helpstring("Retrieve or set the filter that filters by the 'BandData' property.")]
		fpBandData = 7,
		/// \brief Retrieve or set the filter that filters by the \c ButtonData property
		///
		/// \sa IToolBarButton::ButtonData
		[helpstring("Retrieve or set the filter that filters by the 'ButtonData' property.")]
		fpButtonData = 7,
		/// \brief Retrieve or set the filter that filters by the \c SelectionState property
		///
		/// \sa IToolBarButton::SelectionState
		[helpstring("Retrieve or set the filter that filters by the 'SelectionState' property.")]
		fpSelectionState = 9,
		/// \brief Retrieve or set the filter that filters by the \c Text property
		///
		/// \sa IReBarBand::Text, IToolBarButton::Text
		[helpstring("Retrieve or set the filter that filters by the 'Text' property.")]
		fpText = 11,
		/// \brief Retrieve or set the filter that filters by the \c AddMarginsAroundChild property
		///
		/// \sa IReBarBand::AddMarginsAroundChild
		[helpstring("Retrieve or set the filter that filters by the 'AddMarginsAroundChild' property.")]
		fpAddMarginsAroundChild = 20,
		/// \brief Retrieve or set the filter that filters by the \c BackColor property
		///
		/// \sa IReBarBand::BackColor
		[helpstring("Retrieve or set the filter that filters by the 'BackColor' property.")]
		fpBackColor = 21,
		/// \brief Retrieve or set the filter that filters by the \c CurrentHeight property
		///
		/// \sa IReBarBand::CurrentHeight
		[helpstring("Retrieve or set the filter that filters by the 'CurrentHeight' property.")]
		fpCurrentHeight = 22,
		/// \brief Retrieve or set the filter that filters by the \c CurrentWidth property
		///
		/// \sa IReBarBand::CurrentWidth
		[helpstring("Retrieve or set the filter that filters by the 'CurrentWidth' property.")]
		fpCurrentWidth = 23,
		/// \brief Retrieve or set the filter that filters by the \c Width property
		///
		/// \sa IToolBarButton::Width
		[helpstring("Retrieve or set the filter that filters by the 'Width' property.")]
		fpWidth = 23,
		/// \brief Retrieve or set the filter that filters by the \c FixedBackgroundBitmapOrigin property
		///
		/// \sa IReBarBand::FixedBackgroundBitmapOrigin
		[helpstring("Retrieve or set the filter that filters by the 'FixedBackgroundBitmapOrigin' property.")]
		fpFixedBackgroundBitmapOrigin = 24,
		/// \brief Retrieve or set the filter that filters by the \c ForeColor property
		///
		/// \sa IReBarBand::ForeColor
		[helpstring("Retrieve or set the filter that filters by the 'ForeColor' property.")]
		fpForeColor = 25,
		/// \brief Retrieve or set the filter that filters by the \c hBackgroundBitmap property
		///
		/// \sa IReBarBand::hBackgroundBitmap
		[helpstring("Retrieve or set the filter that filters by the 'hBackgroundBitmap' property.")]
		fpHBackgroundBitmap = 26,
		/// \brief Retrieve or set the filter that filters by the \c hContainedWindow property
		///
		/// \sa IReBarBand::hContainedWindow
		[helpstring("Retrieve or set the filter that filters by the 'hContainedWindow' property.")]
		fpHContainedWindow = 27,
		/// \brief Retrieve or set the filter that filters by the \c HeightChangeStepSize property
		///
		/// \sa IReBarBand::HeightChangeStepSize
		[helpstring("Retrieve or set the filter that filters by the 'HeightChangeStepSize' property.")]
		fpHeightChangeStepSize = 28,
		/// \brief Retrieve or set the filter that filters by the \c HideIfVertical property
		///
		/// \sa IReBarBand::HideIfVertical
		[helpstring("Retrieve or set the filter that filters by the 'HideIfVertical' property.")]
		fpHideIfVertical = 29,
		/// \brief Retrieve or set the filter that filters by the \c ID property
		///
		/// \sa IReBarBand::ID, IToolBarButton::ID
		[helpstring("Retrieve or set the filter that filters by the 'ID' property.")]
		fpID = 30,
		/// \brief Retrieve or set the filter that filters by the \c IdealWidth property
		///
		/// \sa IReBarBand::IdealWidth
		[helpstring("Retrieve or set the filter that filters by the 'IdealWidth' property.")]
		fpIdealWidth = 31,
		/// \brief Retrieve or set the filter that filters by the \c KeepInFirstRow property
		///
		/// \sa IReBarBand::KeepInFirstRow
		[helpstring("Retrieve or set the filter that filters by the 'KeepInFirstRow' property.")]
		fpKeepInFirstRow = 32,
		/// \brief Retrieve or set the filter that filters by the \c MaximumHeight property
		///
		/// \sa IReBarBand::MaximumHeight
		[helpstring("Retrieve or set the filter that filters by the 'MaximumHeight' property.")]
		fpMaximumHeight = 33,
		/// \brief Retrieve or set the filter that filters by the \c MinimumHeight property
		///
		/// \sa IReBarBand::MinimumHeight
		[helpstring("Retrieve or set the filter that filters by the 'MinimumHeight' property.")]
		fpMinimumHeight = 34,
		/// \brief Retrieve or set the filter that filters by the \c MinimumWidth property
		///
		/// \sa IReBarBand::MinimumWidth
		[helpstring("Retrieve or set the filter that filters by the 'MinimumWidth' property.")]
		fpMinimumWidth = 35,
		/// \brief Retrieve or set the filter that filters by the \c NewLine property
		///
		/// \sa IReBarBand::NewLine
		[helpstring("Retrieve or set the filter that filters by the 'NewLine' property.")]
		fpNewLine = 36,
		/// \brief Retrieve or set the filter that filters by the \c FollowedByLineBreak property
		///
		/// \sa IToolBarButton::FollowedByLineBreak
		[helpstring("Retrieve or set the filter that filters by the 'FollowedByLineBreak' property.")]
		fpFollowedByLineBreak = 36,
		/// \brief Retrieve or set the filter that filters by the \c Resizable property
		///
		/// \sa IReBarBand::Resizable
		[helpstring("Retrieve or set the filter that filters by the 'Resizable' property.")]
		fpResizable = 37,
		/// \brief Retrieve or set the filter that filters by the \c ShowTitle property
		///
		/// \sa IReBarBand::ShowTitle
		[helpstring("Retrieve or set the filter that filters by the 'ShowTitle' property.")]
		fpShowTitle = 38,
		/// \brief Retrieve or set the filter that filters by the \c DisplayText property
		///
		/// \sa IToolBarButton::DisplayText
		[helpstring("Retrieve or set the filter that filters by the 'DisplayText' property.")]
		fpDisplayText = 38,
		/// \brief Retrieve or set the filter that filters by the \c SizingGripVisibility property
		///
		/// \sa IReBarBand::SizingGripVisibility
		[helpstring("Retrieve or set the filter that filters by the 'SizingGripVisibility' property.")]
		fpSizingGripVisibility = 39,
		/// \brief Retrieve or set the filter that filters by the \c TitleWidth property
		///
		/// \sa IReBarBand::TitleWidth
		[helpstring("Retrieve or set the filter that filters by the 'TitleWidth' property.")]
		fpTitleWidth = 40,
		/// \brief Retrieve or set the filter that filters by the \c UseChevron property
		///
		/// \sa IReBarBand::UseChevron
		[helpstring("Retrieve or set the filter that filters by the 'UseChevron' property.")]
		fpUseChevron = 41,
		/// \brief Retrieve or set the filter that filters by the \c VariableHeight property
		///
		/// \sa IReBarBand::VariableHeight
		[helpstring("Retrieve or set the filter that filters by the 'VariableHeight' property.")]
		fpVariableHeight = 42,
		/// \brief Retrieve or set the filter that filters by the \c Visible property
		///
		/// \sa IReBarBand::Visible, IToolBarButton::Visible
		[helpstring("Retrieve or set the filter that filters by the 'Visible' property.")]
		fpVisible = 43,
		/// \brief Retrieve or set the filter that filters by the \c AutoSize property
		///
		/// \sa IToolBarButton::AutoSize
		[helpstring("Retrieve or set the filter that filters by the 'AutoSize' property.")]
		fpAutoSize = 44,
		/// \brief Retrieve or set the filter that filters by the \c ButtonType property
		///
		/// \sa IToolBarButton::ButtonType
		[helpstring("Retrieve or set the filter that filters by the 'ButtonType' property.")]
		fpButtonType = 45,
		/// \brief Retrieve or set the filter that filters by the \c DropDownStyle property
		///
		/// \sa IToolBarButton::DropDownStyle
		[helpstring("Retrieve or set the filter that filters by the 'DropDownStyle' property.")]
		fpDropDownStyle = 46,
		/// \brief Retrieve or set the filter that filters by the \c Enabled property
		///
		/// \sa IToolBarButton::Enabled
		[helpstring("Retrieve or set the filter that filters by the 'Enabled' property.")]
		fpEnabled = 47,
		/// \brief Retrieve or set the filter that filters by the \c ImageListIndex property
		///
		/// \sa IToolBarButton::ImageListIndex
		[helpstring("Retrieve or set the filter that filters by the 'ImageListIndex' property.")]
		fpImageListIndex = 48,
		/// \brief Retrieve or set the filter that filters by the \c Marked property
		///
		/// \sa IToolBarButton::Marked
		[helpstring("Retrieve or set the filter that filters by the 'Marked' property.")]
		fpMarked = 49,
		/// \brief Retrieve or set the filter that filters by the \c Pushed property
		///
		/// \sa IToolBarButton::Pushed
		[helpstring("Retrieve or set the filter that filters by the 'Pushed' property.")]
		fpPushed = 50,
		/// \brief Retrieve or set the filter that filters by the \c ShowingEllipsis property
		///
		/// \sa IToolBarButton::ShowingEllipsis
		[helpstring("Retrieve or set the filter that filters by the 'ShowingEllipsis' property.")]
		fpShowingEllipsis = 51,
		/// \brief Retrieve or set the filter that filters by the \c UseMnemonic property
		///
		/// \sa IToolBarButton::UseMnemonic
		[helpstring("Retrieve or set the filter that filters by the 'UseMnemonic' property.")]
		fpUseMnemonic = 52
	} FilteredPropertyConstants;

	/// \brief <em>Constants used with the \c FilterType properties</em>
	///
	/// \sa IReBarBands::FilterType, IToolBarButtons::FilterType
	[helpstring("Constants used with the 'FilterType' properties.")]
	typedef enum FilterTypeConstants {
		/// \brief The filter is deactivated
		[helpstring("The filter is deactivated.")]
		ftDeactivated,
		/// \brief A band or button must match this filter to be in the collection
		[helpstring("A band or button must match this filter to be in the collection.")]
		ftIncluding,
		/// \brief A band or button must not match this filter to be in the collection
		[helpstring("A band or button must not match this filter to be in the collection.")]
		ftExcluding
	} FilterTypeConstants;

	/// \brief <em>Constants used with the \c HorizontalTextAlignment property</em>
	///
	/// \sa IToolBar::HorizontalTextAlignment, VAlignmentConstants
	[helpstring("Constants used with the 'HorizontalTextAlignment' property.")]
	typedef enum HAlignmentConstants {
		/// \brief The button texts are left-aligned
		[helpstring("The button texts are left-aligned.")]
		halLeft,
		/// \brief The button texts are horizontally centered
		[helpstring("The button texts are horizontally centered.")]
		halCenter,
		/// \brief The button texts are right-aligned
		[helpstring("The button texts are right-aligned.")]
		halRight
	} HAlignmentConstants;

	/// \brief <em>Flags used with the \c HitTest methods</em>
	///
	/// \sa IReBar::HitTest
	[helpstring("Flags used with the 'HitTest' methods.")]
	typedef enum HitTestConstants {
		/// \brief Not in any band
		///
		/// The specified point lies outside any rebar band.
		[helpstring("The specified point lies outside any rebar band.")]
		htNotInBand = 0x0001 /*RBHT_NOWHERE*/,
		/// \brief Not in any tool bar button
		///
		/// The specified point lies outside any tool bar button. The specified button is the nearest button
		/// that is not a separator.
		[helpstring("The specified point lies outside any tool bar button.")]
		htNotInButton = 0x0001,
		/// \brief In a band's caption
		///
		/// The specified point lies in a band's caption, which may consist of text and an icon.
		[helpstring("The specified point lies in a band's caption, which may consist of text and an icon.")]
		htBandTitle = 0x0002 /*RBHT_CAPTION*/,
		/// \brief Inside a tool bar button
		///
		/// The specified point lies inside a tool bar button.
		[helpstring("The specified point lies inside a tool bar button.")]
		htButton = 0x0002,
		/// \brief In a band's client area
		///
		/// The specified point lies in a band's client area.
		[helpstring("The specified point lies in a band's client area.")]
		htBandClientArea = 0x0003 /*RBHT_CLIENT*/,
		/// \brief In a band's sizing grip
		///
		/// The specified point lies in a band's sizing grip.
		[helpstring("The specified point lies in a band's sizing grip.")]
		htBandSizingGrip = 0x0004 /*RBHT_GRABBER*/,
		/// \brief In a band's chevron button
		///
		/// The specified point lies in a band's chevron button.
		[helpstring("The specified point lies in a band's chevron button.")]
		htBandChevron = 0x0008 /*RBHT_CHEVRON*/,
		/// \brief In the control's splitter
		///
		/// The specified point lies in the control's splitter.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa IReBar::DisplaySplitter
		[helpstring("The specified point lies in the control's splitter. Requires comctl32.dll version 6.10 or higher.")]
		htSplitter = 0x0010 /*RBHT_SPLITTER*/,
		/// \brief Above the control's client area
		///
		/// The specified point lies above the control's client area.
		[helpstring("The specified point lies above the control's client area.")]
		htAbove = 0x0100,
		/// \brief Below the control's client area
		///
		/// The specified point lies below the control's client area.
		[helpstring("The specified point lies below the control's client area.")]
		htBelow = 0x0200,
		/// \brief To the right of the control's client area
		///
		/// The specified point lies to the right of the control's client area.
		[helpstring("The specified point lies to the right of the control's client area.")]
		htToRight = 0x0400,
		/// \brief To the left of the control's client area
		///
		/// The specified point lies to the left of the control's client area.
		[helpstring("The specified point lies to the left of the control's client area.")]
		htToLeft = 0x0800
	} HitTestConstants;

	/// \brief <em>Flags used with the \c HotButtonChanging event</em>
	///
	/// \sa _IToolBarEvents::HotButtonChanging
	[helpstring("Flags used with the 'HotButtonChanging' event.")]
	typedef enum HotButtonChangingAdditionalInfoConstants {
		/// \brief The shortcut key, that caused the hot button change, is not unique
		[helpstring("The shortcut key, that caused the hot button change, is not unique.")]
		hbcaiDuplicateAccelerator = 0x0008/*HICF_DUPACCEL*/,
		/// \brief The control previously did not have a hot button
		[helpstring("The control previously did not have a hot button.")]
		hbcaiEntering = 0x0010/*HICF_ENTERING*/,
		/// \brief The control does not have a hot button anymore
		[helpstring("The control does not have a hot button anymore.")]
		hbcaiLeaving = 0x0020/*HICF_LEAVING*/,
		/// \brief The shortcut key of the currently hot button was pressed and the hot button did not really change
		[helpstring("The shortcut key of the currently hot button was pressed and the hot button did not really change.")]
		hbcaiReselect = 0x0040/*HICF_RESELECT*/,
		/// \brief The hot button change was caused by a click with the left mouse button
		///
		/// \remarks Current versions of Windows do not seem to use this flag.
		[helpstring("The hot button change was caused by a click with the left mouse button. Current versions of Windows do not seem to use this flag.")]
		hbcaiLeftMouseClick = 0x0080/*HICF_LMOUSE*/,
		/// \brief If the new hot button is a drop-down button, a programmatic click on the drop-down arrow will be done
		///
		/// \remarks This flag is useful when changing the hot button through \c IToolBar::SetHotButton.
		[helpstring("If the new hot button is a drop-down button, a programmatic click on the drop-down arrow will be done. This flag is useful when changing the hot button through 'ToolBar.SetHotButton'.")]
		hbcaiDoDropDownClick = 0x0100/*HICF_TOGGLEDROPDOWN*/
	} HotButtonChangingAdditionalInfoConstants;

	/// \brief <em>Flags used with the \c HotButtonChanging event</em>
	///
	/// \sa _IToolBarEvents::HotButtonChanging
	[helpstring("Flags used with the 'HotButtonChanging' event.")]
	typedef enum HotButtonChangingCausedByConstants {
		/// \brief The hot button change was caused by some other event like a focus change or setting the hot button through code
		[helpstring("The hot button change was caused by some other event like a focus change or setting the hot button through code.")]
		hbccbOther = 0x0000/*HICF_OTHER*/,
		/// \brief The hot button change was caused by mouse input
		[helpstring("The hot button change was caused by mouse input.")]
		hbccbMouse = 0x0001/*HICF_MOUSE*/,
		/// \brief The hot button change was caused by pressing an arrow key
		[helpstring("The hot button change was caused by pressing an arrow key.")]
		hbccbArrowKey = 0x0002/*HICF_ARROWKEYS*/,
		/// \brief The hot button change was caused by pressing a button's shortcut key
		[helpstring("The hot button change was caused by pressing a button's shortcut key.")]
		hbccbAcceleratorKey = 0x0004/*HICF_ACCELERATOR*/
	} HotButtonChangingCausedByConstants;

	/// \brief <em>Constants used with the \c hImageList properties</em>
	///
	/// \sa IReBar::hImageList, IToolBar::hImageList
	[helpstring("Constants used with the 'hImageList' properties.")]
	typedef enum ImageListConstants {
		/// \brief Identifies the image list containing the bands' icons
		///
		/// Identifies the image list containing the bands' icons. If this image list is set to 0, no icons are
		/// drawn.
		///
		/// \sa IReBarBand::IconIndex
		[helpstring("Identifies the image list containing the bands' icons.")]
		ilBands = 1,
		/// \brief Identifies the image list containing the tool bar buttons' icons
		///
		/// Identifies the image list containing the tool bar buttons' icons. If this image list is set to 0,
		/// no icons are drawn.
		///
		/// \sa IToolBarButton::IconIndex
		[helpstring("Identifies the image list containing the tool bar buttons' icons.")]
		ilNormalButtons = 1,
		/// \brief Identifies the imagelist containing the tool bar buttons' icons used for Aero OLE drag images
		///
		/// Identifies the imagelist containing the tool bar buttons' icons used when icons with a high
		/// resolution are required. Currently the only usage of this imagelist is the creation of Aero OLE
		/// drag images.\n
		/// If this imagelist is set to 0, the \c ilNormalButtons imagelist is used.
		///
		/// \sa ilNormalButtons, IToolBarButton::IconIndex, IToolBar::SupportOLEDragImages, IToolBar::OLEDrag
		[helpstring("Identifies the imagelist containing the tool bar buttons' icons used for Aero OLE drag images.")]
		ilHighResolution = 4,
		/// \brief Identifies the image list containing the tool bar buttons' icons for hot state
		///
		/// Identifies the image list containing the tool bar buttons' icons for hot state. If this image list
		/// is set to 0, the icons out of the image list identified by \c ilNormalButtons are used.
		///
		/// \sa IToolBarButton::IconIndex
		[helpstring("Identifies the image list containing the tool bar buttons' icons for hot state.")]
		ilHotButtons = 11,
		/// \brief Identifies the image list containing the tool bar buttons' icons for pushed state
		///
		/// Identifies the image list containing the tool bar buttons' icons for pushed state. If this image
		/// list is set to 0, the icons out of the image list identified by \c ilNormalButtons are used.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa IToolBarButton::IconIndex
		[helpstring("Identifies the image list containing the tool bar buttons' icons for pushed state. Requires comctl32.dll version 6.10 or higher.")]
		ilPushedButtons,
		/// \brief Identifies the image list containing the tool bar buttons' icons for disabled state
		///
		/// Identifies the image list containing the tool bar buttons' icons for disabled state. If this image
		/// list is set to 0, the icons out of the image list identified by \c ilNormalButtons are used.
		///
		/// \sa IToolBarButton::IconIndex
		[helpstring("Identifies the image list containing the tool bar buttons' icons for disabled state.")]
		ilDisabledButtons
	} ImageListConstants;

	/// \brief <em>Constants that may be used with the \c SetInsertMarkPosition and \c GetInsertMarkPosition methods</em>
	///
	/// Constants that may be used for the \c relativePosition parameter of the \c SetInsertMarkPosition
	/// and \c GetInsertMarkPosition methods.
	///
	/// \sa IToolBar::SetInsertMarkPosition, IToolBar::GetInsertMarkPosition
	[helpstring("Constants that may be used for the 'relativePosition' parameter of the 'SetInsertMarkPosition' and 'GetInsertMarkPosition' methods.")]
	typedef enum InsertMarkPositionConstants {
		/// \brief The insertion mark is or will be removed
		[helpstring("The insertion mark is or will be removed.")]
		impNowhere = 0,
		/// \brief The insertion mark is or will be placed before the button
		[helpstring("The insertion mark is or will be placed before the button.")]
		impBefore = 1,
		/// \brief The insertion mark is or will be placed after the button
		[helpstring("The insertion mark is or will be placed after the button.")]
		impAfter = 2,
		/// \brief The insertion mark won't be (re-)moved
		[helpstring("The insertion mark won't be (re-)moved.")]
		impDontChange = 3
	} InsertMarkPositionConstants;

	/// \brief <em>Constants used with the \c MenuBarTheme property</em>
	///
	/// \sa IToolBar::MenuBarTheme, IToolBar::MenuMode
	[helpstring("Constants used with the 'MenuBarTheme' property.")]
	typedef enum MenuBarThemeConstants {
		/// \brief If the tool bar control is in menu mode, the tool bar buttons are drawn like normal tool bar buttons
		[helpstring("If the tool bar control is in menu mode, the tool bar buttons are drawn like normal tool bar buttons.")]
		mbtNativeToolbar = 0,
		/// \brief If the tool bar control is in menu mode, the tool bar buttons are drawn like a native menu bar
		[helpstring("If the tool bar control is in menu mode, the tool bar buttons are drawn like a native menu bar.")]
		mbtNativeMenuBar = 1
	} MenuBarThemeConstants;

	/// \brief <em>Flags used with the \c SelectedMenuItem event</em>
	///
	/// \sa _IToolBarEvents::SelectedMenuItem
	[helpstring("Flags used with the 'SelectedMenuItem' event. They can be combined.")]
	typedef enum MenuItemStateConstants {
		/// \brief The menu item is grayed
		[helpstring("The menu item is grayed.")]
		misIsGrayed = 0x00000001/*MF_GRAYED*/,
		/// \brief The menu item is disabled
		[helpstring("The menu item is disabled.")]
		misIsDisabled = 0x00000002/*MF_DISABLED*/,
		/// \brief The menu item consists of a bitmap
		[helpstring("The menu item consists of a bitmap.")]
		misDisplaysBitmap = 0x00000004/*MF_BITMAP*/,
		/// \brief The menu item is checked, i.e. it has a checkmark
		[helpstring("The menu item is checked, i.e. it has a checkmark.")]
		misIsChecked = 0x00000008/*MF_CHECKED*/,
		/// \brief The menu item opens a sub-menu
		[helpstring("The menu item opens a sub-menu.")]
		misOpensSubMenu = 0x00000010/*MF_POPUP*/,
		/// \brief The menu item is displayed in a new column, and a vertical separator is drawn
		[helpstring("The menu item is displayed in a new column, and a vertical separator is drawn.")]
		misDisplayedInNewColumnWithSeparator = 0x00000020/*MF_MENUBARBREAK*/,
		/// \brief The menu item is displayed in a new column, but no vertical separator is drawn
		[helpstring("The menu item is displayed in a new column, but no vertical separator is drawn.")]
		misDisplayedInNewColumnWithoutSeparator = 0x00000040/*MF_MENUBREAK*/,
		/// \brief The menu item is highlighted
		[helpstring("The menu item is highlighted.")]
		misIsHighlighted = 0x00000080/*MF_HILITE*/,
		/// \brief The menu item is drawn by the client application instead of the system
		///
		/// \sa _IReBarEvents::RawMenuMessage, _IToolBarEvents::RawMenuMessage
		[helpstring("The menu item is drawn by the client application instead of the system.")]
		misIsOwnerDrawn = 0x00000100/*MF_OWNERDRAW*/,
		/// \brief The menu item uses option button style checkmarks instead of check box style checkmarks
		[helpstring("The menu item uses option button style checkmarks instead of check box style checkmarks.")]
		misUsesOptionCheckmarks = 0x00000200/*MFT_RADIOCHECK*/,
		/// \brief The menu item is a separator
		[helpstring("The menu item is a separator.")]
		misIsSeparator = 0x00000800/*MFT_SEPARATOR*/,
		// \brief The menu item is part of a window's system menu
		//[helpstring("The menu item is part of a window's system menu.")]
		//misIsPartOfSysMenu = 0x00002000/*MF_SYSMENU*/,
		/// \brief The menu item has a right-to-left layout
		[helpstring("The menu item has a right-to-left layout.")]
		misRightToLeftLayout = 0x00002000/*MFT_RIGHTORDER*/,
		/// \brief The menu item has been selected with the mouse cursor
		[helpstring("The menu item has been selected with the mouse cursor.")]
		misIsSelectedWithMouse = 0x00008000/*MF_MOUSESELECT*/
	} MenuItemStateConstants;

	/// \brief <em>Flags used with the \c IToolBar::RegisterHotkey method</em>
	///
	/// \sa IToolBar::RegisterHotkey
	[helpstring("Flags used with the 'ToolBar.RegisterHotkey' method. They can be combined.")]
	typedef enum ModifierKeysConstants {
		/// \brief The combination of modifier keys contains the [SHIFT] key
		[helpstring("The combination of modifier keys contains the [SHIFT] key.")]
		mkShift = 0x01/*HOTKEYF_SHIFT*/,
		/// \brief The combination of modifier keys contains the [CTRL] key
		[helpstring("The combination of modifier keys contains the [CTRL] key.")]
		mkCtrl = 0x02/*HOTKEYF_CONTROL*/,
		/// \brief The combination of modifier keys contains the [ALT] key
		[helpstring("The combination of modifier keys contains the [ALT] key.")]
		mkAlt = 0x04/*HOTKEYF_ALT*/
	} ModifierKeysConstants;

	/// \brief <em>Constants used with the \c MousePointer properties</em>
	///
	/// \sa IReBar::MousePointer, IToolBar::MousePointer
	[helpstring("Constants used with the 'MousePointer' properties.")]
	typedef enum MousePointerConstants {
		/// \brief The default mouse cursor is used
		[helpstring("The default mouse cursor is used.")]
		mpDefault,
		/// \brief The default arrow is used as mouse cursor
		[helpstring("The default arrow is used as mouse cursor.")]
		mpArrow,
		/// \brief A cross is used as mouse cursor
		[helpstring("A cross is used as mouse cursor.")]
		mpCross,
		/// \brief A vertical beam (like in textboxes) is used as mouse cursor
		[helpstring("A vertical beam (like in textboxes) is used as mouse cursor.")]
		mpIBeam,
		/// \brief An icon is used as mouse cursor
		[helpstring("An icon is used as mouse cursor.")]
		mpIcon,
		/// \brief A mouse cursor indicating window sizing is used
		[helpstring("A mouse cursor indicating window sizing is used.")]
		mpSize,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-right or lower-left corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-right or lower-left corner is used.")]
		mpSizeNESW,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its upper or
		/// lower border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper or lower border is used.")]
		mpSizeNS,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-left or lower-right corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-left or lower-right corner is used.")]
		mpSizeNWSE,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its left or
		/// right border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's left or right border is used.")]
		mpSizeEW,
		/// \brief An arrow pointing upwardly is used as mouse cursor
		[helpstring("An arrow pointing upwardly is used as mouse cursor.")]
		mpUpArrow,
		/// \brief An hourglass is used as mouse cursor.
		[helpstring("An hourglass is used as mouse cursor.")]
		mpHourglass,
		/// \brief An mouse cursor indicating that the control can't be a drop target is used
		[helpstring("An mouse cursor indicating that the control can't be a drop target is used.")]
		mpNoDrop,
		/// \brief The default arrow with a small hourglass is used as mouse cursor
		[helpstring("The default arrow with a small hourglass is used as mouse cursor.")]
		mpArrowHourglass,
		/// \brief The default arrow with a small question mark is used as mouse cursor
		[helpstring("The default arrow with a small question mark is used as mouse cursor.")]
		mpArrowQuestion,
		/// \brief A mouse cursor indicating window sizing to all directions is used
		[helpstring("A mouse cursor indicating window sizing to all directions is used.")]
		mpSizeAll,
		/// \brief A hand typically used for hyperlinks is used as mouse cursor
		[helpstring("A hand typically used for hyperlinks is used as mouse cursor.")]
		mpHand,
		/// \brief A mouse cursor indicating that the program waits for some media is used
		[helpstring("A mouse cursor indicating that the program waits for some media is used.")]
		mpInsertMedia,
		/// \brief A mouse cursor indicating scrolling to all directions is used
		[helpstring("A mouse cursor indicating scrolling to all directions is used.")]
		mpScrollAll,
		/// \brief A mouse cursor indicating scrolling upwardly is used
		[helpstring("A mouse cursor indicating scrolling upwardly is used.")]
		mpScrollN,
		/// \brief A mouse cursor indicating scrolling to the window's upper-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-right corner is used.")]
		mpScrollNE,
		/// \brief A mouse cursor indicating scrolling to the window's right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's right border is used.")]
		mpScrollE,
		/// \brief A mouse cursor indicating scrolling to the window's lower-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-right corner is used.")]
		mpScrollSE,
		/// \brief A mouse cursor indicating scrolling downwards is used
		[helpstring("A mouse cursor indicating scrolling downwards is used.")]
		mpScrollS,
		/// \brief A mouse cursor indicating scrolling to the window's lower-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-left corner is used.")]
		mpScrollSW,
		/// \brief A mouse cursor indicating scrolling to the window's left border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left border is used.")]
		mpScrollW,
		/// \brief A mouse cursor indicating scrolling to the window's upper-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-left corner is used.")]
		mpScrollNW,
		/// \brief A mouse cursor indicating scrolling upwardly or downwards is used
		[helpstring("A mouse cursor indicating scrolling upwardly or downwards is used.")]
		mpScrollNS,
		/// \brief A mouse cursor indicating scrolling to the window's left or right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left or right border is used.")]
		mpScrollEW,
		/// \brief The custom mouse cursor defined by the \c MouseIcon property is used
		[helpstring("The custom mouse cursor defined by the MouseIcon property is used.")]
		mpCustom = 0x63
	} MousePointerConstants;

	/// \brief <em>Constants used with the \c IToolBar::NormalDropDownButtonStyle property</em>
	///
	/// \sa IToolBar::NormalDropDownButtonStyle
	[helpstring("Constants used with the 'ToolBar.NormalDropDownButtonStyle' property.")]
	typedef enum NormalDropDownButtonStyleConstants {
		/// \brief Drop-down buttons are drawn with a separate drop-down arrow
		///
		/// Buttons for which the \c IToolBarButton::DropDownStyle property is set to \c ddstNormal, are drawn
		/// with a drop-down arrow in a separate section to the button's right.
		///
		/// \sa IToolBarButton::DropDownStyle
		[helpstring("Buttons for which the 'ToolBarButton.DropDownStyle' property is set to 'ddstNormal', are drawn with a drop-down arrow in a separate section to the button's right.")]
		nddbsSplitButton,
		/// \brief Drop-down buttons are drawn without drop-down arrow
		///
		/// Buttons for which the \c IToolBarButton::DropDownStyle property is set to \c ddstNormal, are drawn
		/// without a drop-down arrow.
		///
		/// \sa IToolBarButton::DropDownStyle
		[helpstring("Buttons for which the 'ToolBarButton.DropDownStyle' property is set to 'ddstNormal', are drawn without a drop-down arrow.")]
		nddbsWithoutArrow
	} NormalDropDownButtonStyleConstants;

	/// \brief <em>Constants used with the \c OLEQueryContinueDrag event</em>
	///
	/// \sa _IToolBarEvents::OLEQueryContinueDrag, _IToolBarEvents::OLEGiveFeedback,
	///     IToolBar::OLEDrag
	[helpstring("Constants used with the OLEQueryContinueDrag event.")]
	typedef enum OLEActionToContinueWithConstants {
		/// \brief Continue the drag'n'drop operation
		[helpstring("Continue the drag'n'drop operation.")]
		oatcwContinue = 0x0 /*S_OK*/,
		/// \brief Cancel the drag'n'drop operation
		[helpstring("Cancel the drag'n'drop operation.")]
		oatcwCancel = 0x40101 /*DRAGDROP_S_CANCEL*/,
		/// \brief Complete the drag'n'drop operation
		[helpstring("Complete the drag'n'drop operation.")]
		oatcwDrop = 0x40100 /*DRAGDROP_S_DROP*/
	} OLEActionToContinueWithConstants;

	/// \brief <em>Constants used with the \c OLEDragImageStyle property</em>
	///
	/// \sa IToolBar::OLEDragImageStyle
	[helpstring("Constants used with the 'OLEDragImageStyle' property.")]
	typedef enum OLEDragImageStyleConstants {
		/// \brief OLE drag images will be generated in classic style
		[helpstring("OLE drag images will be generated in classic style.")]
		odistClassic,
		/// \brief OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems
		///
		/// \remarks Aero style is supported by Windows Vista and newer systems.\n
		///          The icons for Aero style drag images are taken from the \c ilHighResolution image list.
		///
		/// \sa IToolBar::hImageList
		[helpstring("OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems. Aero style is supported by Windows Vista and newer systems.")]
		odistAeroIfAvailable
	} OLEDragImageStyleConstants;

	/// \brief <em>Constants used with OLE drag'n'drop</em>
	///
	/// \sa _IReBarEvents::OLEDragEnter, _IReBarEvents::OLEDragMouseMove, _IReBarEvents::OLEDragDrop,
	///     _IToolBarEvents::OLEDragEnter, _IToolBarEvents::OLEDragMouseMove, _IToolBarEvents::OLEDragDrop
	[helpstring("Constants used with the OLEDrag* events.")]
	typedef enum OLEDropEffectConstants {
		/// \brief No OLE drag and drop operation has occurred or will occur
		[helpstring("No OLE drag and drop operation has occurred or will occur.")]
		odeNone = 0 /*DROPEFFECT_NONE*/,
		/// \brief A copy has occured or will occur
		[helpstring("A copy has occured or will occur.")]
		odeCopy = 1 /*DROPEFFECT_COPY*/,
		/// \brief A move has occured or will occur
		[helpstring("A move has occured or will occur.")]
		odeMove = 2 /*DROPEFFECT_MOVE*/,
		/// \brief A link has occured or will occur
		[helpstring("A link has occured or will occur.")]
		odeLink = 4 /*DROPEFFECT_LINK*/,
		/// \brief Combination of \c odeCopy and \c odeMove
		[helpstring("Combination of 'odeCopy' and 'odeMove'.")]
		odeCopyOrMove = odeCopy | odeMove,
		/// \brief The drop target window has scrolled or will scroll
		[helpstring("The drop target window has scrolled or will scroll.")]
		odeScroll = 0x80000000 /*DROPEFFECT_SCROLL*/
	} OLEDropEffectConstants;

	/// \brief <em>Constants used with the \c Orientation properties</em>
	///
	/// \sa IReBar::Orientation, IToolBar::Orientation
	[helpstring("Constants used with the 'Orientation' properties.")]
	typedef enum OrientationConstants {
		/// \brief The control displays its content (bands or buttons) horizontally, from left to right
		[helpstring("The control displays its content (bands or buttons) horizontally, from left to right.")]
		oHorizontal,
		/// \brief The control displays its content (bands or buttons) vertically, from bottom to top
		[helpstring("The control displays its content (bands or buttons) vertically, from bottom to top.")]
		oVertical
	} OrientationConstants;

	/// \brief <em>Constants used with the \c RegisterForOLEDragDrop properties</em>
	///
	/// \sa IReBar::RegisterForOLEDragDrop, IToolBar::RegisterForOLEDragDrop
	[helpstring("Constants used with the 'RegisterForOLEDragDrop' properties.")]
	typedef enum RegisterForOLEDragDropConstants {
		/// \brief OLE drag'n'drop support is deactivated
		[helpstring("OLE drag'n'drop support is deactivated.")]
		rfoddNoDragDrop,
		/// \brief The built-in OLE drag'n'drop support of \c ReBarWindow32 or \c ToolbarWindow32 is used
		///
		/// The built-in OLE drag'n'drop support of \c ReBarWindow32 or \c ToolbarWindow32 is used.
		[helpstring("The built-in OLE drag'n'drop support of 'ReBarWindow32' or 'ToolbarWindow32' is used.")]
		rfoddNativeDragDrop,
		/// \brief OLE drag'n'drop is done by the \c ReBar or \c ToolBar class
		///
		/// OLE drag'n'drop is done by the \c ReBar or \c ToolBar class, giving the client application full
		/// control over OLE drag'n'drop.
		[helpstring("OLE drag'n'drop is done by the 'ReBar' or 'ToolBar' class, giving the client application full control over OLE drag'n'drop.")]
		rfoddAdvancedDragDrop
	} RegisterForOLEDragDropConstants;

	/// \brief <em>Constants used with the \c IReBar::ReplaceMDIFrameMenu property</em>
	///
	/// \sa IReBar::ReplaceMDIFrameMenu
	[helpstring("Constants used with the 'ReBar.ReplaceMDIFrameMenu' property.")]
	typedef enum ReplaceMDIFrameMenuConstants {
		/// \brief The MDI frame window's menu remains unchanged
		[helpstring("The MDI frame window's menu remains unchanged.")]
		rmfmDontReplace,
		/// \brief The MDI frame window's menu is removed
		///
		/// The MDI frame window's menu is removed. The control does not overtake the menu's functionality.
		[helpstring("The MDI frame window's menu is removed. The control does not overtake the menu's functionality.")]
		rmfmJustRemove,
		/// \brief The MDI frame window's menu is removed and the control overtakes its functionality
		///
		/// The MDI frame window's menu is removed. The control overtakes the menu's functionality.
		[helpstring("The MDI frame window's menu is removed. The control overtakes the menu's functionality.")]
		rmfmFullReplace
	} ReplaceMDIFrameMenuConstants;

	/// \brief <em>Constants used with the \c ButtonGetDisplayInfo event</em>
	///
	/// \sa _IToolBarEvents::ButtonGetDisplayInfo
	[helpstring("Constants used with the 'ButtonGetDisplayInfo' event.")]
	typedef enum RequestedInfoConstants {
		/// \brief The event was fired to retrieve the button's text
		///
		/// \sa IToolBarButton::Text
		[helpstring("The control requires the button's text.")]
		riButtonText = 0x0001,
		/// \brief The event was fired to retrieve the index of the button's icon
		///
		/// \sa IToolBarButton::IconIndex, IToolBarButton::ImageListIndex
		[helpstring("The control requires the index of the button's icon.")]
		riIconIndex = 0x0002
	} RequestedInfoConstants;

	/// \brief <em>Flags used with the \c RightToLeft properties</em>
	///
	/// \sa IReBar::RightToLeft, IToolBar::RightToLeft
	[helpstring("Flags used with the 'RightToLeft' properties. They can be combined.")]
	typedef enum RightToLeftConstants {
		/// \brief Read text from right to left
		///
		/// The control's text is read from right to left, but the general layout is left to right.
		[helpstring("The control's text is read from right to left, but the general layout is left to right.")]
		rtlText = 1,
		/// \brief Use a right to left layout
		///
		/// The general layout is right to left.
		[helpstring("The general layout is right to left.")]
		rtlLayout = 2
	} RightToLeftConstants;

	/// \brief <em>Constants used with the \c SelectionState property</em>
	///
	/// \sa IToolBarButton::SelectionState
	[helpstring("Constants used with the 'SelectionState' property.")]
	typedef enum SelectionStateConstants {
		/// \brief The check button is cleared
		[helpstring("The check button is cleared.")]
		ssUnchecked,
		/// \brief The check button is checked
		[helpstring("The check button is checked.")]
		ssChecked,
		/// \brief The check button is grayed, indicating an indeterminate state
		[helpstring("The check button is grayed, indicating an indeterminate state.")]
		ssIndeterminate
	} SelectionStateConstants;

	/// \brief <em>Constants used with the \c IReBar::SizingGripVisibility property</em>
	///
	/// \sa IReBarBand::SizingGripVisibility
	[helpstring("Constants used with the 'ReBar.SizingGripVisibility' property.")]
	typedef enum SizingGripVisibilityConstants {
		/// \brief The sizing grip is never displayed
		[helpstring("The sizing grip is never displayed.")]
		sgvNever,
		/// \brief The sizing grip is displayed automatically, if the band can be moved or resized
		[helpstring("The sizing grip is displayed automatically, if the band can be moved or resized.")]
		sgvAutomatic,
		/// \brief The sizing grip is always displayed, even if the band can't be moved or resized
		[helpstring("The sizing grip is always displayed, even if the band can't be moved or resized.")]
		sgvAlways
	} SizingGripVisibilityConstants;

	/// \brief <em>Constants used with the \c CustomDraw event</em>
	///
	/// \sa _IToolBarEvents::CustomDraw
	[helpstring("Constants used with the 'CustomDraw' event.")]
	typedef enum StringBackgroundModeConstants {
		/// \brief Draw the button text with a transparent background
		[helpstring("The button text will be drawn with a transparent background.")]
		sbmTransparent = 1 /*TRANSPARENT*/,
		/// \brief Draw the button text with an opaque background
		[helpstring("The button text will be drawn with an opaque background.")]
		sbmOpaque = 2 /*OPAQUE*/
	} StringBackgroundModeConstants;

	/// \brief <em>Constants used with the \c SuggestedIconSize property</em>
	///
	/// \sa IToolBar::SuggestedIconSize
	[helpstring("Constants used with the 'SuggestedIconSize' property.")]
	typedef enum SuggestedIconSizeConstants {
		/// \brief The control suggests to use small icons (usually 16x16 pixels)
		[helpstring("The control suggests to use small icons (usually 16x16 pixels).")]
		sisSmall,
		/// \brief The control suggests to use large icons (usually 24x24 pixels)
		[helpstring("The control suggests to use large icons (usually 24x24 pixels).")]
		sisLarge
	} SuggestedIconSizeConstants;

	/// \brief <em>Constants used with the \c IToolBarButton::IconIndex property</em>
	///
	/// \sa IToolBarButton::IconIndex, SystemImageListTypeConstants
	[helpstring("Constants used with the 'ToolBarButton.IconIndex' property.")]
	typedef enum SystemImageIndexConstants {
		/// \brief The system image for the "Back" command
		///
		/// \remarks This value is valid for the \c siltSmallExplorerBitmaps and \c siltLargeExplorerBitmaps
		///          image lists.
		[helpstring("The system image for the ""Back"" command. This value is valid for the 'siltSmallExplorerBitmaps' and 'siltLargeExplorerBitmaps' image lists.")]
		siiExplorerBack = 0 /*HIST_BACK*/,
		/// \brief The system image for the "Forward" command
		///
		/// \remarks This value is valid for the \c siltSmallExplorerBitmaps and \c siltLargeExplorerBitmaps
		///          image lists.
		[helpstring("The system image for the ""Forward"" command. This value is valid for the 'siltSmallExplorerBitmaps' and 'siltLargeExplorerBitmaps' image lists.")]
		siiExplorerForward = 1 /*HIST_FORWARD*/,
		/// \brief The system image for the "Favorites" command
		///
		/// \remarks This value is valid for the \c siltSmallExplorerBitmaps and \c siltLargeExplorerBitmaps
		///          image lists.
		[helpstring("The system image for the ""Favorites"" command. This value is valid for the 'siltSmallExplorerBitmaps' and 'siltLargeExplorerBitmaps' image lists.")]
		siiExplorerFavorites = 2 /*HIST_FAVORITES*/,
		/// \brief The system image for the "Add To Favorites" command
		///
		/// \remarks This value is valid for the \c siltSmallExplorerBitmaps and \c siltLargeExplorerBitmaps
		///          image lists.
		[helpstring("The system image for the ""Add To Favorites"" command. This value is valid for the 'siltSmallExplorerBitmaps' and 'siltLargeExplorerBitmaps' image lists.")]
		siiExplorerAddToFavorites = 3 /*HIST_ADDTOFAVORITES*/,
		/// \brief The system image for the "View Tree" command
		///
		/// \remarks This value is valid for the \c siltSmallExplorerBitmaps and \c siltLargeExplorerBitmaps
		///          image lists.
		[helpstring("The system image for the ""View Tree"" command. This value is valid for the 'siltSmallExplorerBitmaps' and 'siltLargeExplorerBitmaps' image lists.")]
		siiExplorerViewTree = 4 /*HIST_VIEWTREE*/,
		/// \brief The system image for the "Cut" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Cut"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardCut = 0 /*STD_CUT*/,
		/// \brief The system image for the "Copy" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Copy"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardCopy = 1 /*STD_COPY*/,
		/// \brief The system image for the "Paste" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Paste"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardPaste = 2 /*STD_PASTE*/,
		/// \brief The system image for the "Undo" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Undo"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardUndo = 3 /*STD_UNDO*/,
		/// \brief The system image for the "Redo" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Redo"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardRedo = 4 /*STD_REDOW*/,
		/// \brief The system image for the "Delete" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Delete"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardDelete = 5 /*STD_DELETE*/,
		/// \brief The system image for the "New File" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""New File"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardFileNew = 6 /*STD_FILENEW*/,
		/// \brief The system image for the "Open File" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Open File"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardFileOpen = 7 /*STD_FILEOPEN*/,
		/// \brief The system image for the "Save File" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Save File"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardFileSave = 8 /*STD_FILESAVE*/,
		/// \brief The system image for the "Print Preview" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Print Preview"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardPrintPreview = 9 /*STD_PRINTPRE*/,
		/// \brief The system image for the "Properties" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Properties"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardProperties = 10 /*STD_PROPERTIES*/,
		/// \brief The system image for the "Help" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Help"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardHelp = 11 /*STD_HELP*/,
		/// \brief The system image for the "Find" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Find"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardFind = 12 /*STD_FIND*/,
		/// \brief The system image for the "Replace" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Replace"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardReplace = 13 /*STD_REPLACE*/,
		/// \brief The system image for the "Print" command
		///
		/// \remarks This value is valid for the \c siltSmallStandardBitmaps and \c siltLargeStandardBitmaps
		///          image lists.
		[helpstring("The system image for the ""Print"" command. This value is valid for the 'siltSmallStandardBitmaps' and 'siltLargeStandardBitmaps' image lists.")]
		siiStandardPrint = 14 /*STD_PRINT*/,
		/// \brief The system image for the "Large Icons" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Large Icons"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewLargeIcons = 0 /*VIEW_LARGEICONS*/,
		/// \brief The system image for the "Small Icons" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Small Icons"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewSmallIcons = 1 /*VIEW_SMALLICONS*/,
		/// \brief The system image for the "List" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""List"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewList = 2 /*VIEW_LIST*/,
		/// \brief The system image for the "Details" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Details"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewDetails = 3 /*VIEW_DETAILS*/,
		/// \brief The system image for the "Sort By Name" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Sort By Name"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewSortByName = 4 /*VIEW_SORTNAME*/,
		/// \brief The system image for the "Sort By Size" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Sort By Size"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewSortBySize = 5 /*VIEW_SORTSIZE*/,
		/// \brief The system image for the "Sort By Date" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Sort By Date"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewSortByDate = 6 /*VIEW_SORTDATE*/,
		/// \brief The system image for the "Sort By Type" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Sort By Type"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewSortByType = 7 /*VIEW_SORTTYPE*/,
		/// \brief The system image for the "Go To Parent Folder" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Go To Parent Folder"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewParentFolder = 8 /*VIEW_PARENTFOLDER*/,
		/// \brief The system image for the "Connect To Network Drive" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Connect To Network Drive"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewNetConnect = 9 /*VIEW_NETCONNECT*/,
		/// \brief The system image for the "Disconnect From Network Drive" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""Disconnect From Network Drive"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewNetDisconnect = 10 /*VIEW_NETDISCONNECT*/,
		/// \brief The system image for the "New Folder" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""New Folder"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewNewFolder = 11 /*VIEW_NEWFOLDER*/,
		/// \brief The system image for the "View Menu" command
		///
		/// \remarks This value is valid for the \c siltSmallViewBitmaps and \c siltLargeViewBitmaps
		///          image lists.
		[helpstring("The system image for the ""View Menu"" command. This value is valid for the 'siltSmallViewBitmaps' and 'siltLargeViewBitmaps' image lists.")]
		siiViewMenu = 12 /*VIEW_VIEWMENU*/
	} SystemImageIndexConstants;

	/// \brief <em>Constants used with the \c IToolBar::LoadDefaultImages method</em>
	///
	/// \sa IToolBar::LoadDefaultImages, SystemImageIndexConstants
	[helpstring("Constants used with the 'ToolBar.LoadDefaultImages' method.")]
	typedef enum SystemImageListTypeConstants {
		/// \brief The system image list containing the shell icons, sized 256x256 pixels
		///
		/// \remarks Requires Windows Vista or higher.
		[helpstring("The system image list containing the shell icons, sized 256x256 pixels. Requires Windows Vista or higher.")]
		siltShellIcons256x256 = -4,
		/// \brief The system image list containing the shell icons, sized 48x48 pixels
		///
		/// \remarks Requires Windows XP or higher.
		[helpstring("The system image list containing the shell icons, sized 48x48 pixels. Requires Windows XP or higher.")]
		siltShellIcons48x48 = -3,
		/// \brief The system image list containing the shell icons, sized 32x32 pixels
		[helpstring("The system image list containing the shell icons, sized 32x32 pixels.")]
		siltShellIcons32x32 = -2,
		/// \brief The system image list containing the shell icons, sized 16x16 pixels
		[helpstring("The system image list containing the shell icons, sized 16x16 pixels.")]
		siltShellIcons16x16 = -1,
		/// \brief The small version of the system's standard bitmaps
		[helpstring("The small version of the system's standard bitmaps.")]
		siltSmallStandardBitmaps = 0 /*IDB_STD_SMALL_COLOR*/,
		/// \brief The large version of the system's standard bitmaps
		[helpstring("The large version of the system's standard bitmaps.")]
		siltLargeStandardBitmaps = 1 /*IDB_STD_LARGE_COLOR*/,
		/// \brief The small version of the system's view mode bitmaps
		[helpstring("The small version of the system's view mode bitmaps.")]
		siltSmallViewBitmaps = 4 /*IDB_VIEW_SMALL_COLOR*/,
		/// \brief The large version of the system's view mode bitmaps
		[helpstring("The large version of the system's view mode bitmaps.")]
		siltLargeViewBitmaps = 5 /*IDB_VIEW_LARGE_COLOR*/,
		/// \brief The small version of the Windows Explorer bitmaps
		[helpstring("The small version of the Windows Explorer bitmaps.")]
		siltSmallExplorerBitmaps = 8 /*IDB_HIST_SMALL_COLOR*/,
		/// \brief The large version of the Windows Explorer bitmaps
		[helpstring("The large version of the Windows Explorer bitmaps.")]
		siltLargeExplorerBitmaps = 9 /*IDB_HIST_LARGE_COLOR*/,
		/// \brief Windows Explorer's travel and favorites bitmaps for normal button state
		///
		/// \remarks Requires Windows Vista or higher.
		[helpstring("Windows Explorer's travel and favorites bitmaps for normal button state. Requires Windows Vista or higher.")]
		siltNormalTravelAndFavoritesBitmaps = 12 /*IDB_HIST_NORMAL*/,
		/// \brief Windows Explorer's travel and favorites bitmaps for hot button state
		///
		/// \remarks Requires Windows Vista or higher.
		[helpstring("Windows Explorer's travel and favorites bitmaps for hot button state. Requires Windows Vista or higher.")]
		siltHotTravelAndFavoritesBitmaps = 13 /*IDB_HIST_HOT*/,
		/// \brief Windows Explorer's travel and favorites bitmaps for disabled button state
		///
		/// \remarks Requires Windows Vista or higher.
		[helpstring("Windows Explorer's travel and favorites bitmaps for disabled button state. Requires Windows Vista or higher.")]
		siltDisabledTravelAndFavoritesBitmaps = 14 /*IDB_HIST_DISABLED*/,
		/// \brief Windows Explorer's travel and favorites bitmaps for pressed button state
		///
		/// \remarks Requires Windows Vista or higher.
		[helpstring("Windows Explorer's travel and favorites bitmaps for pressed button state. Requires Windows Vista or higher.")]
		siltPressedTravelAndFavoritesBitmaps = 15 /*IDB_HIST_PRESSED*/
	} SystemImageListTypeConstants;

	/// \brief <em>Constants used with the \c VerticalTextAlignment property</em>
	///
	/// \sa IToolBar::VerticalTextAlignment, HAlignmentConstants
	[helpstring("Constants used with the 'VerticalTextAlignment' property.")]
	typedef enum VAlignmentConstants {
		/// \brief The button texts are top-aligned
		[helpstring("The button texts are top-aligned.")]
		valTop,
		/// \brief The button texts are vertically centered
		[helpstring("The button texts are vertically centered.")]
		valCenter,
		/// \brief The button texts are bottom-aligned
		[helpstring("The button texts are bottom-aligned.")]
		valBottom
	} VAlignmentConstants;

	/// \brief <em>Constants used with the \c HotButtonChangeWrapping event</em>
	///
	/// \sa _IToolBarEvents::HotButtonChangeWrapping
	[helpstring("Constants used with the 'HotButtonChangeWrapping' event.")]
	typedef enum WrappingDirectionConstants {
		/// \brief The hot button is changed to a button before the current hot button
		[helpstring("The hot button is changed to a button before the current hot button.")]
		wrdBeforeCurrent = -1,
		/// \brief The hot button is changed to a button after the current hot button
		[helpstring("The hot button is changed to a button after the current hot button.")]
		wrdAfterCurrent = 1
	} WrappingDirectionConstants;


	/// \brief <em>Holds the coordinates of a rectangle's opposing corners</em>
	///
	/// \sa _IReBarEvents::AutoSized, _IReBarEvents::ResizingContainedWindow
	// NOTE: If we change the UUID, we also need to update _IReBarEvents_CP.h!
	[helpstring("Holds a rectangle's position and size."), uuid(4111318D-17B8-4728-9AC5-C8B3C6A6498F)]
	typedef struct RECTANGLE
	{
		/// \brief <em>Holds the position of the rectangle's left border in pixels</em>
		[helpstring("Holds the position of the rectangle's left border in pixels.")]
		OLE_XPOS_PIXELS Left;
		/// \brief <em>Holds the position of the rectangle's upper border in pixels</em>
		[helpstring("Holds the position of the rectangle's upper border in pixels.")]
		OLE_YPOS_PIXELS Top;
		/// \brief <em>Holds the position of the rectangle's right border in pixels</em>
		[helpstring("Holds the position of the rectangle's right border in pixels.")]
		OLE_XPOS_PIXELS Right;
		/// \brief <em>Holds the position of the rectangle's lower border in pixels</em>
		[helpstring("Holds the position of the rectangle's lower border in pixels.")]
		OLE_YPOS_PIXELS Bottom;
	} RECTANGLE;


	/// \interface IControlHostWindow
	/// \brief <em>Wraps a container window used to provide floating controls</em>
	///
	/// This interface is a wrapper around a tool window that can be used to host controls, e.g. to provide
	/// floating tool bars.
	///
	/// \sa _IControlHostWindowEvents
	[
		object,
		uuid(59EF3F59-9432-428A-AE76-414E22B2BCF3),
		dual,
		nonextensible,
		helpstring("IControlHostWindow interface"),
		pointer_default(unique)
	]
	interface IControlHostWindow : IDispatch
	{
		/// \brief <em>Retrieves the window's handle</em>
		///
		/// Retrieves the window's handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Create, hWndChild, _IControlHostWindowEvents::Created, _IControlHostWindowEvents::Destroyed
		[propget, id(DISPID_CHW_HWND), helpstring("Retrieves the window's handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the child control's window handle</em>
		///
		/// Retrieves or sets the child control's window handle.
		///
		/// \remarks This is the default property of the \c IControlHostWindow interface.
		///
		/// \sa hWnd
		[propget, id(DISPID_CHW_HWNDCHILD), helpstring("Retrieves or sets the child control's window handle."), nonbrowsable]
		HRESULT hWndChild([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_CHW_HWNDCHILD), helpstring("Retrieves or sets the child control's window handle."), nonbrowsable]
		HRESULT hWndChild([in] OLE_HANDLE newValue);
		/// \brief <em>Controls the window's resizeability</em>
		///
		/// Retrieves or sets whether the window can be resized. If set to \c True, the window can be resized;
		/// otherwise not.
		///
		/// \sa Visible, _IControlHostWindowEvents::Resized
		[propget, id(DISPID_CHW_RESIZEABLE), helpstring("Retrieves or sets whether the window can be resized."), nonbrowsable]
		HRESULT Resizeable([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHW_RESIZEABLE), helpstring("Retrieves or sets whether the window can be resized."), nonbrowsable]
		HRESULT Resizeable([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the window's visibility</em>
		///
		/// Retrieves or sets whether the window is visible. If set to \c True, the window is visible;
		/// otherwise not.
		///
		/// \remarks Until the window is created by calling the \c Create method, this property retrieves the
		///          visibility that the window will have after the \c Create method has been called. After the
		///          window has been created, this property retrieves the window's current view state.
		///
		/// \sa WindowTitle, Resizeable
		[propget, id(DISPID_CHW_VISIBLE), helpstring("Retrieves or sets whether the window is visible."), nonbrowsable]
		HRESULT Visible([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_CHW_VISIBLE), helpstring("Retrieves or sets whether the window is visible."), nonbrowsable]
		HRESULT Visible([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the window's title</em>
		///
		/// Retrieves or sets the text that is displayed as the window's caption.
		///
		/// \sa Visible
		[propget, id(DISPID_CHW_WINDOWTITLE), helpstring("Retrieves or sets the text that is displayed as the window's caption."), nonbrowsable]
		HRESULT WindowTitle([out, retval] BSTR* pValue);
		[propput, id(DISPID_CHW_WINDOWTITLE), helpstring("Retrieves or sets the text that is displayed as the window's caption."), nonbrowsable]
		HRESULT WindowTitle([in] BSTR newValue);

		/// \brief <em>Calculates the window size that is required to achieve the specified client size</em>
		///
		/// Calculates the window size that is required to achieve the specified client size. The calculation
		/// takes the current window styles into account, e. g. it adds space for the window borders.
		///
		/// \param[in] clientWidth The width (in pixels) of the client area that the window shall have.
		/// \param[in] clientHeight The height (in pixels) of the client area that the window shall have.
		/// \param[out] windowWidth Receives the width (in pixels) that the window has to be sized to in order
		///             to achieve the specified client area width.
		/// \param[out] windowHeight Receives the height (in pixels) that the window has to be sized to in
		///             order to achieve the specified client area height.
		///
		/// \sa GetClientRectangle, GetRectangle, Move
		[id(DISPID_CHW_CALCULATEWINDOWSIZE), helpstring("Calculates the window size that is required to achieve the specified client size. The calculation takes the current window styles into account, e. g. it adds space for the window borders.")]
		HRESULT CalculateWindowSize([in, defaultvalue(0x80000000)] long clientWidth, [in, defaultvalue(0x80000000)] long clientHeight, [in, out, defaultvalue(0)] OLE_XSIZE_PIXELS* windowWidth, [in, out, defaultvalue(0)] OLE_YSIZE_PIXELS* windowHeight);
		/// \brief <em>Creates a window that can be used to host other windows</em>
		///
		/// Creates a window that can be used to host other windows.
		///
		/// \param[in] hWndParent The window that will be the parent window of the created window.
		///
		/// \sa Destroy, hWnd, hWndChild, Visible, _IControlHostWindowEvents::Created
		[id(DISPID_CHW_CREATE), helpstring("Creates a window that can be used to host other windows.")]
		HRESULT Create([in] OLE_HANDLE hWndParent);
		/// \brief <em>Destroys the control host window</em>
		///
		/// Destroys the control host window.
		///
		/// \remarks This method will fail as long as a child window is placed on the control host window.
		///
		/// \sa Create, hWnd, hWndChild, _IControlHostWindowEvents::Destroyed
		[id(DISPID_CHW_DESTROY), helpstring("Destroys the control host window. This method will fail as long as a child window is placed on the control host window.")]
		HRESULT Destroy(void);
		/// \brief <em>Retrieves the bounding rectangle of the control host window's client area</em>
		///
		/// Retrieves the bounding rectangle (in pixels) of the control host window's client area. The
		/// retrieved rectangle is in client coordinates.
		///
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border.
		///
		/// \sa GetRectangle, CalculateWindowSize, _IControlHostWindowEvents::Resizing,
		///     _IControlHostWindowEvents::Resized
		[id(DISPID_CHW_GETCLIENTRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels) of the control host window's client area. The retrieved rectangle is in client coordinates.")]
		HRESULT GetClientRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
		/// \brief <em>Retrieves the bounding rectangle of the control host window</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the screen's upper-left corner) of the
		/// control host window.
		///
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the screen's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the screen's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the screen's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the screen's upper-left corner.
		///
		/// \sa GetClientRectangle, CalculateWindowSize, Move, _IControlHostWindowEvents::Moving,
		///     _IControlHostWindowEvents::Resizing, _IControlHostWindowEvents::Moved,
		///     _IControlHostWindowEvents::Resized
		[id(DISPID_CHW_GETRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the screen's upper-left corner) of the control host window.")]
		HRESULT GetRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
		/// \brief <em>Moves and resizes the control host window</em>
		///
		/// Moves and resizes the control host window.
		///
		/// \param[in] left The x-coordinate (in pixels) of the window's position relative to the screen's
		///            upper-left corner.
		/// \param[in] top The y-coordinate (in pixels) of the window's position relative to the screen's
		///            upper-left corner.
		/// \param[in] width The control host window's width in pixels.
		/// \param[in] height The control host window's height in pixels.
		///
		/// \sa CalculateWindowSize, GetRectangle, _IControlHostWindowEvents::Moving,
		///     _IControlHostWindowEvents::Resizing, _IControlHostWindowEvents::Moved,
		///     _IControlHostWindowEvents::Resized
		[id(DISPID_CHW_MOVE), helpstring("Moves and resizes the control host window.")]
		HRESULT Move([in, defaultvalue(0x80000000)] long Left, [in, defaultvalue(0x80000000)] long Top, [in, defaultvalue(0x80000000)] long Width, [in, defaultvalue(0x80000000)] long Height);
	}


	/// \interface _IControlHostWindowEvents
	/// \brief <em>The \c ControlHostWindow class' events interface</em>
	///
	/// This interface defines all events the \c ControlHostWindow class may raise.
	///
	/// \sa IControlHostWindow
	[
		uuid(F5935A3E-C4D8-44A6-BB87-D37F3781D6D3),
		helpstring("IControlHostWindow-event-interface")
	]
	dispinterface _IControlHostWindowEvents
	{
		properties:
		methods:
			/// \brief <em>The control host window was resized</em>
			///
			/// Will be fired after the control host window was resized.
			///
			/// \param[in] width The control host window's width in pixels.
			/// \param[in] height The control host window's height in pixels.
			///
			/// \remarks This is the class' default event.
			///
			/// \sa Resizing, Moved
			[id(DISPID_CHWE_RESIZED), helpstring("Will be fired after the control host window was resized.")]
			void Resized(OLE_XSIZE_PIXELS Width, OLE_YSIZE_PIXELS Height);
			/// \brief <em>The control host window is being activated</em>
			///
			/// Will be fired if the control host window is activated.
			///
			/// \param[in] activatedByMouseClick If \c True, the window is being activated in response to a mouse
			///            click; otherwise it is activated by using the keyboard or by code.
			/// \param[in] hWndBeingDeactivated The handle of the window that is being deactivated.
			///
			/// \sa Deactivate
			[id(DISPID_CHWE_ACTIVATE), helpstring("Will be fired if the control host window is activated.")]
			void Activate(VARIANT_BOOL activatedByMouseClick, LONG hWndBeingDeactivated);
			/// \brief <em>The control host window is being closed</em>
			///
			/// Will be fired while the control host window is being closed.
			///
			/// \param[out] cancel If set to \c True, the window is kept open; otherwise it is closed.
			///
			/// \sa Destroyed, Created
			[id(DISPID_CHWE_CLOSING), helpstring("Will be fired while the control host window is being closed.")]
			void Closing(VARIANT_BOOL* cancel);
			/// \brief <em>The control host window was recreated</em>
			///
			/// Will be fired after the control host window was created.
			///
			/// \param[in] hWnd The control host's window handle.
			///
			/// \sa Destroyed, IControlHostWindow::hWnd
			[id(DISPID_CHWE_CREATED), helpstring("Will be fired after the control host window was created.")]
			void Created(LONG hWnd);
			/// \brief <em>The control host window is being deactivated</em>
			///
			/// Will be fired if the control host window is deactivated.
			///
			/// \param[in] hWndBeingActivated The handle of the window that is being deactivated.
			///
			/// \sa Activate
			[id(DISPID_CHWE_DEACTIVATE), helpstring("Will be fired if the control host window is deactivated.")]
			void Deactivate(LONG hWndBeingActivated);
			/// \brief <em>The control host window was destroyed</em>
			///
			/// Will be fired after the control host window was destroyed.
			///
			/// \param[in] hWnd The control host's window handle.
			///
			/// \sa Closing, Created, IControlHostWindow::hWnd
			[id(DISPID_CHWE_DESTROYED), helpstring("Will be fired after the control host window was destroyed.")]
			void Destroyed(LONG hWnd);
			/// \brief <em>The control host window was moved</em>
			///
			/// Will be fired after the control host window was moved.
			///
			/// \param[in] left The x-coordinate (in pixels) of the window's position relative to the screen's
			///            upper-left corner.
			/// \param[in] top The y-coordinate (in pixels) of the window's position relative to the screen's
			///            upper-left corner.
			///
			/// \sa Moving, Resized, IControlHostWindow::Move
			[id(DISPID_CHWE_MOVED), helpstring("Will be fired after the control host window was moved.")]
			void Moved(OLE_XPOS_PIXELS Left, OLE_YPOS_PIXELS Top);
			/// \brief <em>The control host window is being moved</em>
			///
			/// Will be fired while the control host window is being moved.
			///
			/// \param[in] left The x-coordinate (in pixels) of the window's position relative to the screen's
			///            upper-left corner. This value can be changed.
			/// \param[in] top The y-coordinate (in pixels) of the window's position relative to the screen's
			///            upper-left corner. This value can be changed.
			/// \param[out] preventMove If set to \c True, the change to the window's position is refused;
			///             otherwise it is accepted.
			///
			/// \sa Moved, Resizing, IControlHostWindow::Move
			[id(DISPID_CHWE_MOVING), helpstring("Will be fired while the control host window is being moved.")]
			void Moving(OLE_XPOS_PIXELS* Left, OLE_YPOS_PIXELS* Top, VARIANT_BOOL* preventMove);
			/// \brief <em>The control host window is being resized</em>
			///
			/// Will be fired while the control host window is being resized.
			///
			/// \param[in,out] width The control host window's width in pixels. This value can be changed.
			/// \param[in,out] height The control host window's height in pixels. This value can be changed.
			/// \param[out] preventResize If set to \c True, the change to the window's size is refused;
			///             otherwise it is accepted.
			///
			/// \remarks This is the class' default event.
			///
			/// \sa Resized, Moving
			[id(DISPID_CHWE_RESIZING), helpstring("Will be fired while the control host window is being resized.")]
			void Resizing(OLE_XSIZE_PIXELS* Width, OLE_YSIZE_PIXELS* Height, VARIANT_BOOL* preventResize);
			/// \brief <em>The user double-clicked onto the control host window's title bar</em>
			///
			/// Will be fired if the user double-clicks onto the control host window's title bar using the left
			/// mouse button.
			///
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the screen's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the screen's
			///            upper-left corner.
			///
			/// \sa IControlHostWindow::Destroy
			[id(DISPID_CHWE_TITLEDBLCLICK), helpstring("Will be fired if the user double-clicks onto the control host window's title bar using the left mouse button.")]
			void TitleDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	};


	/// \brief <em>The \c ControlHostWindow class</em>
	///
	/// This COM class implements the \c IControlHostWindow and \c _IControlHostWindowEvents interfaces.
	///
	/// \sa IControlHostWindow, _IControlHostWindowEvents
	[
		uuid(B6306994-7ECD-4CBC-AD3A-C073DC941916),
		version(1.3),
		helpstring("ControlHostWindow Class 1.3 (Unicode)")
	]
	coclass ControlHostWindow
	{
		[default] interface IControlHostWindow;
		[default, source] dispinterface _IControlHostWindowEvents;
	};


	/// \interface IOLEDataObject
	/// \brief <em>Wraps the \c IDataObject interface</em>
	///
	/// This interface provides easy access to data being transferred using the \c IDataObject interface.
	///
	/// \sa _IOLEDataObjectEvents,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
	[
		object,
		uuid(B2C0B4EB-39A0-4bdb-B603-FE343425C074),
		dual,
		nonextensible,
		helpstring("IOLEDataObject interface"),
		pointer_default(unique)
	]
	interface IOLEDataObject : IDispatch
	{
		/// \brief <em>Deletes the contents of the \c OLEDataObject object</em>
		///
		/// \remarks This method will succeed only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
		[id(DISPID_ODO_CLEAR), helpstring("Deletes the contents of the 'OLEDataObject' object.")]
		HRESULT Clear(void);
		/// \brief <em>Retrieves the best format settings from the \c OLEDataObject object</em>
		///
		/// Call this method to retrieve data format settings that match best with the data format, that you
		/// actually want to work with. Set the parameters to the data format settings you want to work with.
		/// The method will set them to the settings you should use.
		///
		/// \param[in,out] formatID An integer value specifying the data format. Valid values are those defined
		///                by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///                registered using the \c RegisterClipboardFormat API function.
		/// \param[in,out] index An integer value that is assigned to the internal \c FORMATETC struct's
		///                \c lindex member. Usually you pass -1 here, but some formats like
		///                \c CFSTR_FILECONTENTS require multiple \c FORMATETC structs for the same format. In
		///                such cases you'll give each struct of this format a separate index.
		/// \param[in,out] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
		///                struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
		///                Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \sa GetData, GetFormat,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETCANONICALFORMAT), helpstring("Call this method to retrieve data format settings that match best with the data format, that you actually want to work with.")]
		HRESULT GetCanonicalFormat([in, out] LONG* formatID, [in, out] LONG* Index, [in, out] LONG* dataOrViewAspect);
		/// \brief <em>Retrieves data from the \c OLEDataObject object</em>
		///
		/// Retrieves data from the \c OLEDataObject object, that has the specified format.
		///
		/// \param[in] formatID An integer value specifying the format of the data to retrieve. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return The data that has the specified format.
		///
		/// \remarks This method will fail, if the \c OLEDataObject object does not contain data of the
		///          specified format.
		///
		/// \sa GetCanonicalFormat, GetFormat, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETDATA), helpstring("Retrieves data from the 'OLEDataObject' object.")]
		HRESULT GetData([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT* pData);
		/// \brief <em>Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object</em>
		///
		/// Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object. The drop description
		/// describes what will happen if the user drops the dragged data at the current position. It is
		/// displayed at the bottom of the drag image.
		///
		/// \param[in,out] targetDescription Receives the description of the current drop target.
		/// \param[in,out] actionDescription Receives the description of the whole drop action, i. e. a string
		///                like <em>"Copy to %1"</em> where <em>"Copy to"</em> is the description of the current
		///                drop effect and <em>"%1"</em> is the placeholder for the drop target description
		///                specified by \c targetDescription.
		/// \param[in,out] icon Receives the icon used to visualize the current drop effect. Any of the values
		///                defined by the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa SetDropDescription, IReBar::SupportOLEDragImages, IToolBar::SupportOLEDragImages,
		///     DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_GETDROPDESCRIPTION), helpstring("Retrieves the 'DROPDESCRIPTION' data stored by the 'OLEDataObject' object. Requires Windows Vista or newer.")]
		HRESULT GetDropDescription([in, out, optional] VARIANT* targetDescription, [in, out, optional] VARIANT* actionDescription, [in, out, defaultvalue(0)] DropDescriptionIconConstants* Icon);
		/// \brief <em>Retrieves whether the \c OLEDataObject object contains data in a specific format</em>
		///
		/// \param[in] formatID An integer value specifying the format to check for. Valid values are those
		///            defined by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///            registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return \c True, if the \c OLEDataObject object contains data in the specified format;
		///         otherwise \c False.
		///
		/// \sa GetCanonicalFormat, GetData, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETFORMAT), helpstring("Retrieves whether the 'OLEDataObject' object contains data in a specific format.")]
		HRESULT GetFormat([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT_BOOL* pFormatAvailable);
		/// \brief <em>Inserts data into the \c OLEDataObject object using the specified format</em>
		///
		/// \param[in] formatID An integer value specifying the format of the data being passed. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] data The data to insert. If not specified, the \c OLESetData event will be raised if
		///            data of the specified format is requested from the \c OLEDataObject object.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \remarks The \c data parameter is optional only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa GetData, Clear,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_SETDATA), helpstring("Inserts data into the 'OLEDataObject' object using the specified format.")]
		HRESULT SetData([in] LONG formatID, [in, optional] VARIANT data, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect);
		/// \brief <em>Sets the drop description displayed below the drag image</em>
		///
		/// Sets the \c DROPDESCRIPTION data. The drop description describes what will happen if the user drops
		/// the dragged data at the current position. It is displayed at the bottom of the drag image.
		///
		/// \param[in] targetDescription The description of the current drop target.
		/// \param[in] actionDescription The description of the whole drop action, i. e. a string like <em>"Copy
		///            to %1"</em> where <em>"Copy to"</em> is the description of the current drop effect and
		///            <em>"%1"</em> is the placeholder for the drop target description specified by
		///            \c targetDescription.
		/// \param[in] icon The icon used to visualize the current drop effect. Any of the values defined by
		///            the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa GetDropDescription, IReBar::SupportOLEDragImages, IToolBar::SupportOLEDragImages,
		///     DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_SETDROPDESCRIPTION), helpstring("Sets the drop description displayed below the drag image. Requires Windows Vista or newer.")]
		HRESULT SetDropDescription([in, optional] VARIANT targetDescription, [in, optional] VARIANT actionDescription, [in, defaultvalue(ddiNone)] DropDescriptionIconConstants Icon);
	}


	/// \interface _IOLEDataObjectEvents
	/// \brief <em>The \c OLEDataObject class' events interface</em>
	///
	/// This interface defines all events the \c OLEDataObject class may raise.
	///
	/// \sa IOLEDataObject
	[
		uuid(9C09223C-76A5-4bd4-984C-2A12AEB440D0),
		helpstring("IOLEDataObject-event-interface")
	]
	dispinterface _IOLEDataObjectEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c OLEDataObject class</em>
	///
	/// This COM class implements the \c IOLEDataObject and \c _IOLEDataObjectEvents interfaces.
	///
	/// \sa IOLEDataObject, _IOLEDataObjectEvents
	[
		uuid(844D6BBF-064D-416e-8F08-D229A68F03B4),
		version(1.3),
		noncreatable,
		helpstring("OLEDataObject Class 1.3 (ANSI)")
	]
	coclass OLEDataObject
	{
		[default] interface IOLEDataObject;
		[default, source] dispinterface _IOLEDataObjectEvents;
	};


	/// \interface IVirtualReBarBand
	/// \brief <em>Wraps a not existing band</em>
	///
	/// This interface is a wrapper around a rebar band that does not yet or not anymore exist within the
	/// control.
	///
	/// \sa _IVirtualReBarBandEvents, IReBarBand, _IReBarEvents
	[
		object,
		uuid(80B7AB71-EB3B-4ded-9D51-219DF1C8DAF0),
		dual,
		nonextensible,
		helpstring("IVirtualReBarBand interface"),
		pointer_default(unique)
	]
	interface IVirtualReBarBand : IDispatch
	{
		/// \brief <em>Retrieves whether the band's height is increased by a small margin</em>
		///
		/// Retrieves whether the band's height will be or was increased by a small margin. If set to \c True,
		/// a small margin will be or was inserted at the top and bottom of the band's contained window;
		/// otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa CurrentHeight, IReBar::DisplayBandSeparators
		[propget, id(DISPID_VRBB_ADDMARGINSAROUNDCHILD), helpstring("Retrieves whether the band's height will be or was increased by a small margin.")]
		HRESULT AddMarginsAroundChild([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the band's background color</em>
		///
		/// Retrieves the band's background color. If set to -1, the control's background color will be or was
		/// used.
		///
		/// \remarks This property isn't supported for themed rebars.\n
		///          This property is read-only.
		///
		/// \sa hBackgroundBitmap, ForeColor, IReBar::BackColor
		[propget, id(DISPID_VRBB_BACKCOLOR), helpstring("Retrieves the band's background color. This property isn't supported for themed rebars.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		/// \brief <em>Retrieves the band's associated data</em>
		///
		/// Retrieves the \c Long value that will be or was associated with the band.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IReBarEvents::FreeBandData
		[propget, id(DISPID_VRBB_BANDDATA), helpstring("Retrieves the Long value that will be or was associated with the band.")]
		HRESULT BandData([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the accessibility object state of the band's chevron button</em>
		///
		/// Retrieves the accessibility object state of the band's chevron button. For a list of possible
		/// object states see the <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">MSDN
		/// article</a>.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.\n
		///          This property is read-only.
		///
		/// \sa UseChevron,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">Accessibility Object State Constants</a>
		[propget, id(DISPID_VRBB_CHEVRONBUTTONOBJECTSTATE), helpstring("Retrieves the accessibility object state of the band's chevron button. Requires comctl32.dll version 6.10 or higher."), nonbrowsable]
		HRESULT ChevronButtonObjectState([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the band's current height</em>
		///
		/// Retrieves the band's current height in pixels.
		///
		/// \remarks If the \c VariableHeight property is set to \c False, this property is ignored.\n
		///          This property is read-only.
		///
		/// \sa CurrentWidth, MinimumHeight, MaximumHeight, HeightChangeStepSize, VariableHeight
		[propget, id(DISPID_VRBB_CURRENTHEIGHT), helpstring("Retrieves the band's current height in pixels.")]
		HRESULT CurrentHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the band's current width</em>
		///
		/// Retrieves the band's current width in pixels.
		///
		/// \remarks This property is read-only.
		///
		/// \sa CurrentHeight, MinimumWidth, IdealWidth, TitleWidth
		[propget, id(DISPID_VRBB_CURRENTWIDTH), helpstring("Retrieves the band's current width in pixels.")]
		HRESULT CurrentWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the origin of the band's background bitmap</em>
		///
		/// Retrieves whether the band's background bitmap will begin or has begun at the control's upper-left
		/// corner instead of the band's upper-left corner. If set to \c True, the bitmap's origin will be or
		/// was the control's upper-left corner, so that the background image will or did not move if the band
		/// will be or was resized or moved (instead the visible part of the background image will change or
		/// has changed). If set to \c False, the origin will be or was the band's upper-left corner, so that
		/// the background image will move or has moved with the band.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hBackgroundBitmap
		[propget, id(DISPID_VRBB_FIXEDBACKGROUNDBITMAPORIGIN), helpstring("Retrieves or sets whether the band's background bitmap will begin or has begun at the control's upper-left corner instead of the band's upper-left corner.")]
		HRESULT FixedBackgroundBitmapOrigin([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the band's text color</em>
		///
		/// Retrieves the band's text color. If set to -1, the control's text color will be or was used.
		///
		/// \remarks This property isn't supported for themed rebars.\n
		///          This property is read-only.
		///
		/// \sa BackColor, IReBar::ForeColor
		[propget, id(DISPID_VRBB_FORECOLOR), helpstring("Retrieves the band's text color. This property isn't supported for themed rebars.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		/// \brief <em>Retrieves the bitmap used as the background for the band</em>
		///
		/// Retrieves or sets the handle of the bitmap that will be or was used as the background for the band.
		///
		/// \remarks This property is read-only.
		///
		/// \sa BackColor, IReBar::hPalette, FixedBackgroundBitmapOrigin
		[propget, id(DISPID_VRBB_HBACKGROUNDBITMAP), helpstring("Retrieves or sets the handle of the bitmap that will be or was used as the background for the band."), nonbrowsable]
		HRESULT hBackgroundBitmap([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the window contained in the band</em>
		///
		/// Retrieves the handle of the window that will be or was contained in the band.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MinimumHeight, CurrentHeight, MaximumHeight, MinimumWidth, CurrentWidth
		[propget, id(DISPID_VRBB_HCONTAINEDWINDOW), helpstring("Retrieves the handle of the window that will be or was contained in the band."), nonbrowsable]
		HRESULT hContainedWindow([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves how the band's height can be changed</em>
		///
		/// Retrieves the number of pixels by which the band's height can or could be changed in a single step.
		/// If the control changes or has changed the band's height, the difference between old and new height
		/// will be or was a multiple of this value.
		///
		/// \remarks If the \c VariableHeight property is set to \c False, this property is ignored.\n
		///          This property is read-only.
		///
		/// \sa MinimumHeight, CurrentHeight, MaximumHeight, VariableHeight
		[propget, id(DISPID_VRBB_HEIGHTCHANGESTEPSIZE), helpstring("Retrieves the number of pixels by which the band's height can or could be changed in a single step.")]
		HRESULT HeightChangeStepSize([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves whether the band is visible if the control's orientation is vertical</em>
		///
		/// Retrieves whether the band will be or was visible if the control's orientation is vertical. If set
		/// to \c True, the band will be or was displayed if the control's orientation is vertical; otherwise
		/// it will be or was displayed on horizontal orientation only.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Visible, IReBar::Orientation
		[propget, id(DISPID_VRBB_HIDEIFVERTICAL), helpstring("Retrieves whether the band will be or was visible if the control's orientation is vertical.")]
		HRESULT HideIfVertical([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the band's icon</em>
		///
		/// Retrieves the zero-based index of the band's icon in the control's \c ilBands image list. If set to
		/// -2, no icon will be or was displayed for this band.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IReBar::hImageList, ImageListConstants
		[propget, id(DISPID_VRBB_ICONINDEX), helpstring("Retrieves the zero-based index of the band's icon in the control's 'ilBands' image list. If set to -2, no icon will be or was displayed for this band.")]
		HRESULT IconIndex([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the band's ID</em>
		///
		/// Retrieves an unique ID identifying this band.
		///
		/// \remarks A band's ID will never change.\n
		///          This property is read-only.
		///
		/// \sa Index, BandIdentifierTypeConstants
		[propget, id(DISPID_VRBB_ID), helpstring("Retrieves the band's unique ID.")]
		HRESULT ID([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the band's ideal width</em>
		///
		/// Retrieves the width (in pixels), to which the control will try or has tried to resize the band, if
		/// it will auto-size or has auto-sized it.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MinimumWidth, CurrentWidth
		[propget, id(DISPID_VRBB_IDEALWIDTH), helpstring("Retrieves the width (in pixels), to which the control will try or has tried to resize the band, if it will auto-size or has auto-sized it.")]
		HRESULT IdealWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the band's zero-based index</em>
		///
		/// Retrieves the zero-based index identifying this band.
		///
		/// \remarks Although adding or removing bands changes other bands' indexes, the index is the best
		///          (and fastest) option to identify a band.\n
		///          This property is read-only.
		///
		/// \sa ID, BandIdentifierTypeConstants
		[propget, id(DISPID_VRBB_INDEX), helpstring("Retrieves the zero-based index identifying this band.")]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Retrieves whether the band is locked to the first row</em>
		///
		/// Retrieves whether the band will be or was always displayed within the first row. If set to \c True,
		/// the band will be or was locked to the first row; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa NewLine, IReBar::NumberOfRows
		[propget, id(DISPID_VRBB_KEEPINFIRSTROW), helpstring("Retrieves or sets whether the band will be or was always displayed within the first row.")]
		HRESULT KeepInFirstRow([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the band's maximum height</em>
		///
		/// Retrieves the band's maximum height in pixels. The band won't be or wasn't sized larger than that.
		///
		/// \remarks If the \c VariableHeight property is set to \c False, this property is ignored.\n
		///          This property is read-only.
		///
		/// \sa MinimumHeight, CurrentHeight, HeightChangeStepSize, MinimumWidth, VariableHeight
		[propget, id(DISPID_VRBB_MAXIMUMHEIGHT), helpstring("Retrieves the band's maximum height in pixels.")]
		HRESULT MaximumHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the band's minimum height</em>
		///
		/// Retrieves the band's minimum height in pixels. The band won't be or wasn't sized smaller than that.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MaximumHeight, CurrentHeight, HeightChangeStepSize, MinimumWidth
		[propget, id(DISPID_VRBB_MINIMUMHEIGHT), helpstring("Retrieves the band's minimum height in pixels.")]
		HRESULT MinimumHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the band's minimum width</em>
		///
		/// Retrieves the band's minimum width in pixels. The band won't be or wasn't sized smaller than that.
		///
		/// \remarks This property is read-only.
		///
		/// \sa CurrentWidth, MinimumHeight, MaximumHeight
		[propget, id(DISPID_VRBB_MINIMUMWIDTH), helpstring("Retrieves the band's minimum width in pixels.")]
		HRESULT MinimumWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves whether the band is displayed on a new line</em>
		///
		/// Retrieves whether the band will be or was displayed in a new row within the control. If set to
		/// \c True, the band will be or was displayed on a new line; otherwise it will be or was displayed in
		/// the same row as the previous band.
		///
		/// \remarks This property is read-only.
		///
		/// \sa KeepInFirstRow, IdealWidth, CurrentWidth, IReBar::NumberOfRows, _IReBarEvents::AutoBreakingBand
		[propget, id(DISPID_VRBB_NEWLINE), helpstring("Retrieves whether the band will be or was displayed in a new row within the control.")]
		HRESULT NewLine([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether the band can be resized by the user</em>
		///
		/// Retrieves whether the band can be resized by the user. If set to \c True, a sizing grip is
		/// displayed with which the band can be resized; otherwise no such grip is displayed and the band has
		/// a fixed size.
		///
		/// \remarks This property is read-only.
		///
		/// \sa SizingGripVisibility, IdealWidth, CurrentWidth, VariableHeight
		[propget, id(DISPID_VRBB_RESIZABLE), helpstring("Retrieves whether the band can be resized by the user.")]
		HRESULT Resizable([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether the band's caption is displayed</em>
		///
		/// Retrieves whether the band's caption, which may consist of text and an icon, will be or was
		/// displayed. If set to \c True, the band's caption will be or was displayed; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Text, IconIndex, TitleWidth
		[propget, id(DISPID_VRBB_SHOWTITLE), helpstring("Retrieves whether the band's caption, which may consist of text and an icon, will be or was displayed.")]
		HRESULT ShowTitle([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves when the band's sizing grip is displayed</em>
		///
		/// Retrieves when the band's sizing grip will be or was displayed. Any of the values defined by the
		/// \c SizingGripVisibilityConstants enumeration is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Resizable, IReBar::HighlightColor, IReBar::ShadowColor, SizingGripVisibilityConstants
		[propget, id(DISPID_VRBB_SIZINGGRIPVISIBILITY), helpstring("Retrieves when the band's sizing grip will be or was displayed.")]
		HRESULT SizingGripVisibility([out, retval] SizingGripVisibilityConstants* pValue);
		/// \brief <em>Retrieves the band's text</em>
		///
		/// Retrieves the band's text. The maximum number of characters in this text is 8192.
		///
		/// \remarks This is the default property of the \c IVirtualReBarBand interface.\n
		///          This property is read-only.
		///
		/// \sa IReBarBands::Add
		[propget, id(DISPID_VRBB_TEXT), helpstring("Retrieves the band's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
		/// \brief <em>Retrieves the width of the band's caption</em>
		///
		/// Retrieves the width (in pixels) of the band's caption, which may consist of text and an icon. If
		/// set to -1, the caption will be or was sized automatically.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ShowTitle, Text, IconIndex, CurrentWidth
		[propget, id(DISPID_VRBB_TITLEWIDTH), helpstring("Retrieves the width (in pixels) of the band's caption, which may consist of text and an icon.")]
		HRESULT TitleWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves whether a chevron button is displayed if the band is smaller than its ideal width</em>
		///
		/// Retrieves whether a chevron button will be or was displayed if the band's current width is smaller
		/// than its ideal width. If set to \c True, a chevron button will be or was displayed; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IdealWidth, CurrentWidth, ChevronButtonObjectState, GetChevronRectangle
		[propget, id(DISPID_VRBB_USECHEVRON), helpstring("Retrieves whether a chevron button will be or was displayed if the band's current width is smaller than its ideal width.")]
		HRESULT UseChevron([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether the band's height can be changed by the control</em>
		///
		/// Retrieves whether the band's height can or could be changed by the control. If set to \c True, the
		/// band's height can or could be changed according to the settings specified by the \c MinimumHeight,
		/// \c MaximumHeight and \c HeightChangeStepSize properties; otherwise its height will be or was fixed.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MinimumHeight, MaximumHeight, HeightChangeStepSize, Resizable
		[propget, id(DISPID_VRBB_VARIABLEHEIGHT), helpstring("Retrieves whether the band's height can or could be changed by the control.")]
		HRESULT VariableHeight([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether the band is visible</em>
		///
		/// Retrieves whether the band will be or was visible. If set to \c True, the band will be or was
		/// displayed; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa HideIfVertical, IReBarBands::Remove, IReBarBands::Add
		[propget, id(DISPID_VRBB_VISIBLE), helpstring("Retrieves whether the band will be or was visible.")]
		HRESULT Visible([out, retval] VARIANT_BOOL* pValue);

		/// \brief <em>Retrieves the bounding rectangle of the band's chevron button</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's client area) of the band's
		/// chevron button.
		///
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the control's upper-left corner.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa UseChevron
		[id(DISPID_VRBB_GETCHEVRONRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's client area) of the band's chevron button. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT GetChevronRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
	}


	/// \interface _IVirtualReBarBandEvents
	/// \brief <em>The \c VirtualReBarBand class' events interface</em>
	///
	/// This interface defines all events the \c VirtualReBarBand class may raise.
	///
	/// \sa IVirtualReBarBand
	[
		uuid(C3DB5523-4C48-442a-B0DE-F01851F9D986),
		helpstring("IVirtualReBarBand-event-interface")
	]
	dispinterface _IVirtualReBarBandEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c VirtualReBarBand class</em>
	///
	/// This COM class implements the \c IVirtualReBarBand and \c _IVirtualReBarBandEvents interfaces.
	///
	/// \sa IVirtualReBarBand, _IVirtualReBarBandEvents, ReBar, ReBarBand
	[
		uuid(40E611A6-97A8-44e4-B4D8-90838E169DDA),
		version(1.0),
		noncreatable,
		helpstring("VirtualReBarBand Class 1.0 (ANSI)")
	]
	coclass VirtualReBarBand
	{
		[default] interface IVirtualReBarBand;
		[default, source] dispinterface _IVirtualReBarBandEvents;
	};


	/// \interface IReBarBand
	/// \brief <em>Wraps an existing rebar band</em>
	///
	/// This interface is a wrapper around a band that - unlike a band wrapped by \c IVirtualReBarBand -
	/// really exists within the control.
	///
	/// \sa _IReBarBandEvents, IVirtualReBarBand, IReBarBands, IReBar, _IReBarEvents
	[
		object,
		uuid(7DA695F5-A0DF-4648-9E89-036CF797F0D9),
		dual,
		nonextensible,
		helpstring("IReBarBand interface"),
		pointer_default(unique)
	]
	interface IReBarBand : IDispatch
	{
		/// \brief <em>Specifies whether the band's height is increased by a small margin</em>
		///
		/// Retrieves or sets whether the band's height is increased by a small margin. If set to \c True,
		/// a small margin is inserted at the top and bottom of the band's contained window; otherwise not.
		///
		/// \sa CurrentHeight, IReBar::GetMargins, IReBar::DisplayBandSeparators
		[propget, id(DISPID_RBB_ADDMARGINSAROUNDCHILD), helpstring("Retrieves or sets whether the band's height is increased by a small margin.")]
		HRESULT AddMarginsAroundChild([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_ADDMARGINSAROUNDCHILD), helpstring("Retrieves or sets whether the band's height is increased by a small margin.")]
		HRESULT AddMarginsAroundChild([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the band's background color</em>
		///
		/// Retrieves or sets the band's background color. If set to -1, the control's background color is
		/// used.
		///
		/// \remarks This property isn't supported for themed rebars.
		///
		/// \sa hBackgroundBitmap, ForeColor, IReBar::BackColor
		[propget, id(DISPID_RBB_BACKCOLOR), helpstring("Retrieves or sets the band's background color. This property isn't supported for themed rebars.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_RBB_BACKCOLOR), helpstring("Retrieves or sets the band's background color. This property isn't supported for themed rebars.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies the band's associated data</em>
		///
		/// Retrieves or sets the \c Long value associated with the band. Use this property to associate
		/// any data with the band.
		///
		/// \sa _IReBarEvents::FreeBandData
		[propget, id(DISPID_RBB_BANDDATA), helpstring("Retrieves or sets the Long value associated with the band.")]
		HRESULT BandData([out, retval] LONG* pValue);
		[propput, id(DISPID_RBB_BANDDATA), helpstring("Retrieves or sets the Long value associated with the band.")]
		HRESULT BandData([in] LONG newValue);
		/// \brief <em>Retrieves the accessibility object state of the band's chevron button</em>
		///
		/// Retrieves the accessibility object state of the band's chevron button. For a list of possible
		/// object states see the <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">MSDN
		/// article</a>.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.\n
		///          This property is read-only.
		///
		/// \sa UseChevron,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms697270.aspx">Accessibility Object State Constants</a>
		[propget, id(DISPID_RBB_CHEVRONBUTTONOBJECTSTATE), helpstring("Retrieves the accessibility object state of the band's chevron button. Requires comctl32.dll version 6.10 or higher."), nonbrowsable]
		HRESULT ChevronButtonObjectState([out, retval] LONG* pValue);
		/// \brief <em>Specifies the band's current height</em>
		///
		/// Retrieves or sets the band's current height in pixels.
		///
		/// \remarks If the \c VariableHeight property is set to \c False, this property is ignored.
		///
		/// \sa CurrentWidth, MinimumHeight, MaximumHeight, HeightChangeStepSize, VariableHeight
		[propget, id(DISPID_RBB_CURRENTHEIGHT), helpstring("Retrieves or sets the band's current height in pixels.")]
		HRESULT CurrentHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_RBB_CURRENTHEIGHT), helpstring("Retrieves or sets the band's current height in pixels.")]
		HRESULT CurrentHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the band's current width</em>
		///
		/// Retrieves or sets the band's current width in pixels.
		///
		/// \sa CurrentHeight, MinimumWidth, IdealWidth, TitleWidth, Maximize, Minimize
		[propget, id(DISPID_RBB_CURRENTWIDTH), helpstring("Retrieves or sets the band's current width in pixels.")]
		HRESULT CurrentWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_RBB_CURRENTWIDTH), helpstring("Retrieves or sets the band's current width in pixels.")]
		HRESULT CurrentWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies the origin of the band's background bitmap</em>
		///
		/// Retrieves or sets whether the band's background bitmap begins at the control's upper-left corner
		/// instead of the band's upper-left corner. If set to \c True, the bitmap's origin is the control's
		/// upper-left corner, so that the background image doesn't move if the band is resized or moved
		/// (instead the visible part of the background image changes). If set to \c False, the origin is the
		/// band's upper-left corner, so that the background image moves with the band.
		///
		/// \sa hBackgroundBitmap
		[propget, id(DISPID_RBB_FIXEDBACKGROUNDBITMAPORIGIN), helpstring("Retrieves or sets whether the band's background bitmap begins at the control's upper-left corner instead of the band's upper-left corner.")]
		HRESULT FixedBackgroundBitmapOrigin([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_FIXEDBACKGROUNDBITMAPORIGIN), helpstring("Retrieves or sets whether the band's background bitmap begins at the control's upper-left corner instead of the band's upper-left corner.")]
		HRESULT FixedBackgroundBitmapOrigin([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the band's text color</em>
		///
		/// Retrieves or sets the band's text color. If set to -1, the control's text color is used.
		///
		/// \remarks This property isn't supported for themed rebars.
		///
		/// \sa BackColor, IReBar::ForeColor
		[propget, id(DISPID_RBB_FORECOLOR), helpstring("Retrieves or sets the band's text color. This property isn't supported for themed rebars.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_RBB_FORECOLOR), helpstring("Retrieves or sets the band's text color. This property isn't supported for themed rebars.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies the bitmap used as the background for the band</em>
		///
		/// Retrieves or sets the handle of the bitmap used as the background for the band.
		///
		/// \sa BackColor, IReBar::hPalette, FixedBackgroundBitmapOrigin
		[propget, id(DISPID_RBB_HBACKGROUNDBITMAP), helpstring("Retrieves or sets the handle of the bitmap used as the background for the band."), nonbrowsable]
		HRESULT hBackgroundBitmap([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_RBB_HBACKGROUNDBITMAP), helpstring("Retrieves or sets the handle of the bitmap used as the background for the band."), nonbrowsable]
		HRESULT hBackgroundBitmap([in] OLE_HANDLE newValue);
		/// \brief <em>Specifies the window contained in the band</em>
		///
		/// Retrieves or sets the handle of the window contained in the band.
		///
		/// \attention Setting this property to zero hides the previously contained window. However, COM might
		///            still treat the window as visible, so it's best to explicitly set the contained
		///            control's \c Visible property to \c False (if it is a COM control) after setting the
		///            \c hContainedWindow property to zero. To make the control visible after setting the
		///            \c hContainedWindow property to zero set the control's \c Visible property to \c False
		///            and then to \c True.
		///
		/// \sa MinimumHeight, CurrentHeight, MaximumHeight, MinimumWidth, CurrentWidth
		[propget, id(DISPID_RBB_HCONTAINEDWINDOW), helpstring("Retrieves or sets the handle of the window contained in the band. See documentation for important information about visibility of the contained window."), nonbrowsable]
		HRESULT hContainedWindow([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_RBB_HCONTAINEDWINDOW), helpstring("Retrieves or sets the handle of the window contained in the band. See documentation for important information about visibility of the contained window."), nonbrowsable]
		HRESULT hContainedWindow([in] OLE_HANDLE newValue);
		/// \brief <em>Specifies how the band's height can be changed</em>
		///
		/// Retrieves or sets the number of pixels by which the band's height can be changed in a single step.
		/// If the control changes the band's height, the difference between old and new height will be a
		/// multiple of this value.
		///
		/// \remarks If the \c VariableHeight property is set to \c False, this property is ignored.
		///
		/// \sa MinimumHeight, CurrentHeight, MaximumHeight, VariableHeight
		[propget, id(DISPID_RBB_HEIGHTCHANGESTEPSIZE), helpstring("Retrieves or sets the number of pixels by which the band's height can be changed in a single step.")]
		HRESULT HeightChangeStepSize([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_RBB_HEIGHTCHANGESTEPSIZE), helpstring("Retrieves or sets the number of pixels by which the band's height can be changed in a single step.")]
		HRESULT HeightChangeStepSize([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies whether the band is visible if the control's orientation is vertical</em>
		///
		/// Retrieves or sets whether the band is visible if the control's orientation is vertical. If set to
		/// \c True, the band is displayed if the control's orientation is vertical; otherwise it is displayed
		/// on horizontal orientation only.
		///
		/// \sa Visible, IReBar::Orientation
		[propget, id(DISPID_RBB_HIDEIFVERTICAL), helpstring("Retrieves or sets whether the band is visible if the control's orientation is vertical.")]
		HRESULT HideIfVertical([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_HIDEIFVERTICAL), helpstring("Retrieves or sets whether the band is visible if the control's orientation is vertical.")]
		HRESULT HideIfVertical([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the band's icon</em>
		///
		/// Retrieves or sets the zero-based index of the band's icon in the control's \c ilBands image list.
		/// If set to -2, no icon is displayed for this band.
		///
		/// \sa IReBar::hImageList, ImageListConstants
		[propget, id(DISPID_RBB_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the band's icon in the control's 'ilBands' image list. If set to -2, no icon is displayed for this band.")]
		HRESULT IconIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_RBB_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the band's icon in the control's 'ilBands' image list. If set to -2, no icon is displayed for this band.")]
		HRESULT IconIndex([in] LONG newValue);
		/// \brief <em>Retrieves the band's ID</em>
		///
		/// Retrieves an unique ID identifying this band.
		///
		/// \remarks A band's ID will never change.\n
		///          This property is read-only.
		///
		/// \sa Index, BandIdentifierTypeConstants
		[propget, id(DISPID_RBB_ID), helpstring("Retrieves the band's unique ID.")]
		HRESULT ID([out, retval] LONG* pValue);
		/// \brief <em>Specifies the band's ideal width</em>
		///
		/// Retrieves or sets the width (in pixels), to which the control tries to resize the band, if it
		/// auto-sizes it.
		///
		/// \sa MinimumWidth, CurrentWidth, Maximize
		[propget, id(DISPID_RBB_IDEALWIDTH), helpstring("Retrieves or sets the width (in pixels), to which the control tries to resize the band, if it auto-sizes it.")]
		HRESULT IdealWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_RBB_IDEALWIDTH), helpstring("Retrieves or sets the width (in pixels), to which the control tries to resize the band, if it auto-sizes it.")]
		HRESULT IdealWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies the band's zero-based index</em>
		///
		/// Retrieves or sets the zero-based index identifying this band. Setting this property moves the band.
		///
		/// \remarks Although adding or removing bands changes other bands' indexes, the index is the best
		///          (and fastest) option to identify a band.
		///
		/// \sa ID, BandIdentifierTypeConstants
		[propget, id(DISPID_RBB_INDEX), helpstring("Retrieves or sets the zero-based index identifying this band. Setting this property moves the band.")]
		HRESULT Index([out, retval] LONG* pValue);
		[propput, id(DISPID_RBB_INDEX), helpstring("Retrieves or sets the zero-based index identifying this band. Setting this property moves the band.")]
		HRESULT Index([in] LONG newValue);
		/// \brief <em>Specifies whether the band is locked to the first row</em>
		///
		/// Retrieves or sets whether the band is always displayed within the first row. If set to \c True, the
		/// band is locked to the first row; otherwise not.
		///
		/// \sa NewLine, IReBar::NumberOfRows
		[propget, id(DISPID_RBB_KEEPINFIRSTROW), helpstring("Retrieves or sets whether the band is always displayed within the first row.")]
		HRESULT KeepInFirstRow([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_KEEPINFIRSTROW), helpstring("Retrieves or sets whether the band is always displayed within the first row.")]
		HRESULT KeepInFirstRow([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the band's maximum height</em>
		///
		/// Retrieves or sets the band's maximum height in pixels. The band won't be sized larger than that.
		///
		/// \remarks If the \c VariableHeight property is set to \c False, this property is ignored.
		///
		/// \sa MinimumHeight, CurrentHeight, HeightChangeStepSize, MinimumWidth, VariableHeight
		[propget, id(DISPID_RBB_MAXIMUMHEIGHT), helpstring("Retrieves or sets the band's maximum height in pixels.")]
		HRESULT MaximumHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_RBB_MAXIMUMHEIGHT), helpstring("Retrieves or sets the band's maximum height in pixels.")]
		HRESULT MaximumHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the band's minimum height</em>
		///
		/// Retrieves or sets the band's minimum height in pixels. The band won't be sized smaller than that.
		///
		/// \sa MaximumHeight, CurrentHeight, HeightChangeStepSize, MinimumWidth
		[propget, id(DISPID_RBB_MINIMUMHEIGHT), helpstring("Retrieves or sets the band's minimum height in pixels.")]
		HRESULT MinimumHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_RBB_MINIMUMHEIGHT), helpstring("Retrieves or sets the band's minimum height in pixels.")]
		HRESULT MinimumHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the band's minimum width</em>
		///
		/// Retrieves or sets the band's minimum width in pixels. The band won't be sized smaller than that.
		///
		/// \sa CurrentWidth, MinimumHeight, MaximumHeight
		[propget, id(DISPID_RBB_MINIMUMWIDTH), helpstring("Retrieves or sets the band's minimum width in pixels.")]
		HRESULT MinimumWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_RBB_MINIMUMWIDTH), helpstring("Retrieves or sets the band's minimum width in pixels.")]
		HRESULT MinimumWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies whether the band is displayed on a new line</em>
		///
		/// Retrieves or sets whether the band is displayed in a new row within the control. If set to \c True,
		/// the band is displayed on a new line; otherwise it is displayed in the same row as the previous
		/// band.
		///
		/// \sa KeepInFirstRow, IdealWidth, CurrentWidth, IReBar::NumberOfRows, _IReBarEvents::AutoBreakingBand
		[propget, id(DISPID_RBB_NEWLINE), helpstring("Retrieves or sets whether the band is displayed in a new row within the control.")]
		HRESULT NewLine([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_NEWLINE), helpstring("Retrieves or sets whether the band is displayed in a new row within the control.")]
		HRESULT NewLine([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the band can be resized by the user</em>
		///
		/// Retrieves or sets whether the band can be resized by the user. If set to \c True, a sizing grip
		/// is displayed with which the band can be resized; otherwise no such grip is displayed and the band
		/// has a fixed size.
		///
		/// \sa SizingGripVisibility, IdealWidth, CurrentWidth, VariableHeight
		[propget, id(DISPID_RBB_RESIZABLE), helpstring("Retrieves or sets whether the band can be resized by the user.")]
		HRESULT Resizable([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_RESIZABLE), helpstring("Retrieves or sets whether the band can be resized by the user.")]
		HRESULT Resizable([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the height of the row that contains the band</em>
		///
		/// Retrieves the height in pixels of the row that contains this band.
		///
		/// \remarks This property is read-only.
		///
		/// \sa GetRectangle, IReBar::NumberOfRows
		[propget, id(DISPID_RBB_ROWHEIGHT), helpstring("Retrieves the height in pixels of the row that contains the band.")]
		HRESULT RowHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Specifies whether the band's caption is displayed</em>
		///
		/// Retrieves or sets whether the band's caption, which may consist of text and an icon, is displayed.
		/// If set to \c True, the band's caption is displayed; otherwise not.
		///
		/// \sa Text, IconIndex, TitleWidth
		[propget, id(DISPID_RBB_SHOWTITLE), helpstring("Retrieves or sets whether the band's caption, which may consist of text and an icon, is displayed.")]
		HRESULT ShowTitle([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_SHOWTITLE), helpstring("Retrieves or sets whether the band's caption, which may consist of text and an icon, is displayed.")]
		HRESULT ShowTitle([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies when the band's sizing grip is displayed</em>
		///
		/// Retrieves or sets when the band's sizing grip is displayed. Any of the values defined by the
		/// \c SizingGripVisibilityConstants enumeration is valid.
		///
		/// \sa Resizable, IReBar::HighlightColor, IReBar::ShadowColor, SizingGripVisibilityConstants
		[propget, id(DISPID_RBB_SIZINGGRIPVISIBILITY), helpstring("Retrieves or sets when the band's sizing grip is displayed.")]
		HRESULT SizingGripVisibility([out, retval] SizingGripVisibilityConstants* pValue);
		[propput, id(DISPID_RBB_SIZINGGRIPVISIBILITY), helpstring("Retrieves or sets when the band's sizing grip is displayed.")]
		HRESULT SizingGripVisibility([in] SizingGripVisibilityConstants newValue);
		/// \brief <em>Specifies the band's text</em>
		///
		/// Retrieves or sets the band's text. The maximum number of characters in this text is 8192.
		///
		/// \remarks This is the default property of the \c IReBarBand interface.
		///
		/// \sa IReBarBands::Add
		[propget, id(DISPID_RBB_TEXT), helpstring("Retrieves or sets the band's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_RBB_TEXT), helpstring("Retrieves or sets the band's text.")]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Specifies the width of the band's caption</em>
		///
		/// Retrieves or sets the width (in pixels) of the band's caption, which may consist of text and an
		/// icon. If set to -1, the caption is sized automatically.
		///
		/// \sa ShowTitle, Text, IconIndex, CurrentWidth
		[propget, id(DISPID_RBB_TITLEWIDTH), helpstring("Retrieves or sets the width (in pixels) of the band's caption, which may consist of text and an icon.")]
		HRESULT TitleWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_RBB_TITLEWIDTH), helpstring("Retrieves or sets the width (in pixels) of the band's caption, which may consist of text and an icon.")]
		HRESULT TitleWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies whether a chevron button is displayed if the band is smaller than its ideal width</em>
		///
		/// Retrieves or sets whether a chevron button is displayed if the band's current width is smaller than
		/// its ideal width. If set to \c True, a chevron button is displayed; otherwise not.
		///
		/// \sa IdealWidth, CurrentWidth, ChevronVisible, ChevronButtonObjectState, GetChevronRectangle,
		///     ClickChevron
		[propget, id(DISPID_RBB_USECHEVRON), helpstring("Retrieves or sets whether a chevron button is displayed if the band's current width is smaller than its ideal width.")]
		HRESULT UseChevron([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_USECHEVRON), helpstring("Retrieves or sets whether a chevron button is displayed if the band's current width is smaller than its ideal width.")]
		HRESULT UseChevron([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the band can be resized by the user</em>
		///
		/// Retrieves or sets whether the band's height can be changed by the control. If set to \c True, the
		/// band's height can be changed according to the settings specified by the \c MinimumHeight,
		/// \c MaximumHeight and \c HeightChangeStepSize properties; otherwise its height is fixed.
		///
		/// \sa MinimumHeight, MaximumHeight, HeightChangeStepSize, Resizable
		[propget, id(DISPID_RBB_VARIABLEHEIGHT), helpstring("Retrieves whether the band's height can be changed by the control.")]
		HRESULT VariableHeight([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_VARIABLEHEIGHT), helpstring("Retrieves whether the band's height can be changed by the control.")]
		HRESULT VariableHeight([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the band is visible</em>
		///
		/// Retrieves or sets whether the band is visible. If set to \c True, the band will be displayed;
		/// otherwise not.
		///
		/// \sa HideIfVertical, Hide, Show, ChevronVisible, IReBarBands::Remove, IReBarBands::Add
		[propget, id(DISPID_RBB_VISIBLE), helpstring("Retrieves or sets whether the band is visible.")]
		HRESULT Visible([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBB_VISIBLE), helpstring("Retrieves or sets whether the band is visible.")]
		HRESULT Visible([in] VARIANT_BOOL newValue);

		/// \brief <em>Clicks the band's chevron programmatically</em>
		///
		/// Clicks the band's chevron programmatically. The \c ChevronClick event will be raised with the
		/// \c userData parameter being set to the specified value.
		///
		/// \param[in] userData A \c Long value that will be passed to the \c ChevronClick event handler.
		///
		/// \sa UseChevron, _IReBarEvents::ChevronClick
		[id(DISPID_RBB_CLICKCHEVRON), helpstring("Clicks the band's chevron programmatically.")]
		HRESULT ClickChevron([in, defaultvalue(0)] LONG userData);
		/// \brief <em>Retrieves the size of the border around the band</em>
		///
		/// Retrieves the width (in pixels) of the border around the band.
		///
		/// \param[out] leftBorder The width (in pixels) of the border on the left of the band.
		/// \param[out] topBorder The height (in pixels) of the border on the top of the band.
		/// \param[out] rightBorder The width (in pixels) of the border on the right of the band.
		/// \param[out] bottomBorder The height (in pixels) of the border on the bottom of the band.
		///
		/// \sa GetRectangle, IReBar::DisplayBandSeparators, IReBar::GetMargins
		[id(DISPID_RBB_GETBORDERSIZES), helpstring("Retrieves the width (in pixels) of the border around the band.")]
		HRESULT GetBorderSizes([in, out, defaultvalue(0)] OLE_XSIZE_PIXELS* leftBorder, [in, out, defaultvalue(0)] OLE_YSIZE_PIXELS* topBorder, [in, out, defaultvalue(0)] OLE_XSIZE_PIXELS* rightBorder, [in, out, defaultvalue(0)] OLE_YSIZE_PIXELS* bottomBorder);
		/// \brief <em>Retrieves the bounding rectangle of the band's chevron button</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's client area) of the band's
		/// chevron button.
		///
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the control's upper-left corner.
		///
		/// \sa UseChevron, GetRectangle
		[id(DISPID_RBB_GETCHEVRONRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's client area) of the band's chevron button.")]
		HRESULT GetChevronRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
		/// \brief <em>Retrieves the bounding rectangle of either the band or a part of it</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's client area) of either the
		/// band or a part of it.
		///
		/// \param[in] rectangleType The rectangle to retrieve. Any of the values defined by the
		///            \c BandRectangleTypeConstants enumeration is valid.
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the control's upper-left corner.
		///
		/// \sa GetBorderSizes, GetChevronRectangle, RowHeight, IReBar::GetMargins, BandRectangleTypeConstants
		[id(DISPID_RBB_GETRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's client area) of either the band or a part of it.")]
		HRESULT GetRectangle([in] BandRectangleTypeConstants rectangleType, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
		/// \brief <em>Hides the band</em>
		///
		/// \sa Show, Visible
		[id(DISPID_RBB_HIDE), helpstring("Hides the band.")]
		HRESULT Hide(void);
		/// \brief <em>Maximizes the band's width</em>
		///
		/// Maximizes the band to either its ideal width as specified by the \c IdealWidth property, or to the
		/// largest possible width.
		///
		/// \param[in] useIdealWidth If set to \c True, the band is maximized to its ideal width, as specified
		///            by the \c IdealWidth property; otherwise it is made as large as possible.
		///
		/// \sa Minimize, IdealWidth, CurrentWidth
		[id(DISPID_RBB_MAXIMIZE), helpstring("Maximizes the band to either its ideal width as specified by the 'IdealWidth' property, or to the largest possible width.")]
		HRESULT Maximize([in, defaultvalue(-1)] VARIANT_BOOL useIdealWidth);
		/// \brief <em>Minimizes the band's width</em>
		///
		/// Minimizes the band to its minimum width as specified by the \c MinimumWidth property.
		///
		/// \sa Maximize, MinimumWidth, IdealWidth, CurrentWidth
		[id(DISPID_RBB_MINIMIZE), helpstring("Minimizes the band to its minimum width as specified by the 'MinimumWidth' property.")]
		HRESULT Minimize(void);
		/// \brief <em>Unhides the band</em>
		///
		/// \sa Hide, Visible
		[id(DISPID_RBB_SHOW), helpstring("Unhides the band.")]
		HRESULT Show(void);

		/// \brief <em>Retrieves whether the mouse cursor is located over the band's chevron button</em>
		///
		/// Retrieves whether the mouse cursor is located over the band's chevron button. If \c True, the
		/// chevron button is hot (i.e. below the mouse); otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa UseChevron, ChevronVisible, ChevronPushed
		[propget, id(DISPID_RBB_CHEVRONHOT), helpstring("Retrieves whether the mouse cursor is located over the band's chevron button.")]
		HRESULT ChevronHot([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether the band's chevron button currently is pushed</em>
		///
		/// Retrieves whether the band's chevron button currently is pushed. If \c True, the chevron button is
		/// pushed; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa UseChevron, ChevronVisible, ChevronHot
		[propget, id(DISPID_RBB_CHEVRONPUSHED), helpstring("Retrieves whether the band's chevron button currently is pushed.")]
		HRESULT ChevronPushed([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether the band's chevron button is visible</em>
		///
		/// Retrieves whether the band's chevron button is visible. If \c True, the chevron button is being
		/// displayed; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa UseChevron, IdealWidth, ChevronHot, ChevronPushed
		[propget, id(DISPID_RBB_CHEVRONVISIBLE), helpstring("Retrieves whether the band's chevron button is visible.")]
		HRESULT ChevronVisible([out, retval] VARIANT_BOOL* pValue);
	}


	/// \interface _IReBarBandEvents
	/// \brief <em>The \c ReBarBand class' events interface</em>
	///
	/// This interface defines all events the \c ReBarBand class may raise.
	///
	/// \sa IReBarBand
	[
		uuid(3FE002CF-0413-4fcf-AB97-8715F2FF1F3E),
		helpstring("IReBarBand-event-interface")
	]
	dispinterface _IReBarBandEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ReBarBand class</em>
	///
	/// This COM class implements the \c IReBarBand and \c _IReBarBandEvents interfaces.
	///
	/// \sa IReBarBand, _IReBarBandEvents, ReBar, ReBarBands
	[
		uuid(486876B1-8368-4d20-828C-49962D9F54E9),
		version(1.3),
		noncreatable,
		helpstring("ReBarBand Class 1.3 (ANSI)")
	]
	coclass ReBarBand
	{
		[default] interface IReBarBand;
		[default, source] dispinterface _IReBarBandEvents;
	};


	/// \interface IReBarBands
	/// \brief <em>Manages a collection of \c ReBarBand objects</em>
	///
	/// This interface provides easy access (including filtering) to collections of \c ReBarBand objects.
	/// While a \c ReBarBandContainer object is used to group any bands and acts more like a clipboard, a
	/// \c ReBarBands object is used to group bands that have certain properties in common.
	///
	/// \sa _IReBarBandsEvents, IReBarBand, IReBar
	[
		object,
		uuid(ABE86EB5-1F34-4825-AEE8-A697F3340F28),
		dual,
		nonextensible,
		helpstring("IReBarBands interface"),
		pointer_default(unique)
	]
	interface IReBarBands : IDispatch
	{
		/// \brief <em>Specifies whether filters for string properties are case sensitive</em>
		///
		/// Retrieves or sets whether string comparisons, that are done when applying the filters on a band,
		/// are case sensitive. If this property is set to \c True, string comparisons are case sensitive;
		/// otherwise not.
		///
		/// \sa Filter, ComparisonFunction
		[propget, id(DISPID_RBBS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on a band, are case sensitive.")]
		HRESULT CaseSensitiveFilters([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RBBS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on a band, are case sensitive.")]
		HRESULT CaseSensitiveFilters([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies a filter's comparison function</em>
		///
		/// Retrieves or sets a band filter's comparison function. This property takes the address of a
		/// function having the following signature:\n
		/// \code
		///   IsEqual(ByVal bandProperty As T, ByVal pattern As T) As Long
		/// \endcode
		/// where T stands for the filtered property's type (\c Boolean, \c Long or \c String). This function
		/// must compare its arguments and return a non-zero value if the arguments are equal and zero
		/// otherwise.\n
		/// If this property is set to 0, the control compares the values itself using the "=" operator
		/// (\c lstrcmp and \c lstrcmpi for string filters).
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, CaseSensitiveFilters, FilteredPropertyConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647488.aspx">lstrcmp</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647489.aspx">lstrcmpi</a>
		[propget, id(DISPID_RBBS_COMPARISONFUNCTION), helpstring("Retrieves or sets a band filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [out, retval] LONG* pValue);
		[propput, id(DISPID_RBBS_COMPARISONFUNCTION), helpstring("Retrieves or sets a band filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [in] LONG newValue);
		/// \brief <em>Specifies a filter for a property</em>
		///
		/// Retrieves or sets a band filter.\n
		/// An \c IReBarBands collection can be filtered by any of \c IReBarBand's properties, that the
		/// \c FilteredPropertyConstants enumeration defines a constant for. Combinations of multiple filters
		/// are possible, too. A filter is a \c Variant containing an array whose elements are of type
		/// \c Variant. Each element of this array contains a valid value for the property, that the filter
		/// refers to.\n
		/// When applying the filter, the elements of the array are connected using the logical Or operator.\n\n
		/// Setting this property to \c Empty or any other value, that doesn't match the described structure,
		/// deactivates the filter.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa FilterType, ComparisonFunction, FilteredPropertyConstants
		[propget, id(DISPID_RBBS_FILTER), helpstring("Retrieves or sets a band filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [out, retval] VARIANT* pValue);
		[propput, id(DISPID_RBBS_FILTER), helpstring("Retrieves or sets a band filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [in] VARIANT newValue);
		/// \brief <em>Specifies a filter's type</em>
		///
		/// Retrieves or sets a band filter's type.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, FilteredPropertyConstants, FilterTypeConstants
		[propget, id(DISPID_RBBS_FILTERTYPE), helpstring("Retrieves or sets a band filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [out, retval] FilterTypeConstants* pValue);
		[propput, id(DISPID_RBBS_FILTERTYPE), helpstring("Retrieves or sets a band filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [in] FilterTypeConstants newValue);
		/// \brief <em>Retrieves a \c ReBarBand object from the collection</em>
		///
		/// Retrieves a \c ReBarBand object from the collection that wraps the rebar band identified by
		/// \c bandIdentifier.
		///
		/// \param[in] bandIdentifier A value that identifies the rebar band to be retrieved.
		/// \param[in] bandIdentifierType A value specifying the meaning of \c bandIdentifier. Any of the
		///            values defined by the \c BandIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IReBarBands interface.\n
		///          This property is read-only.
		///
		/// \sa IReBarBand, BandIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_RBBS_ITEM), helpstring("Retrieves a 'ReBarBand' object from the collection that wraps the rebar band identified by 'bandIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG bandIdentifier, [in, defaultvalue(bitIndex)] BandIdentifierTypeConstants bandIdentifierType, [out, retval] IReBarBand** ppBand);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c ReBarBand objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_RBBS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds a band to the rebar control</em>
		///
		/// Adds a band with the specified properties at the specified position in the control and returns a
		/// \c ReBarBand object wrapping the inserted band.
		///
		/// \param[in] insertAt The new band's zero-based index. If set to -1, the band will be inserted
		///            as the last band.
		/// \param[in] hContainedWindow The handle of the window that will be contained in the band.
		/// \param[in] newLine If set to \c True, the band will be displayed in a new row within the control;
		///            otherwise it will be displayed in the same row as its preceeding band.
		/// \param[in] sizingGripVisibility Specifies when the new band's sizing grip is displayed. Any of the
		///            values defined by the \c SizingGripVisibilityConstants enumeration is valid.
		/// \param[in] resizable If set to \c True, the new band can be resized by the user; otherwise not.
		/// \param[in] keepInFirstRow If set to \c True, the new band is always displayed within the first row;
		///            otherwise it may be moved to another row.
		/// \param[in] visible If set to \c True, the new band is made visible; otherwise not.
		/// \param[in] idealWidth The width (in pixels), to which the control tries to resize the new band, if
		///            it auto-sizes it.
		/// \param[in] minimumWidth The new band's minimum width in pixels. The band won't be sized smaller
		///            than that.
		/// \param[in] minimumHeight The new band's minimum height in pixels. The band won't be sized smaller
		///            than that.
		/// \param[in] maximumHeight The new band's maximum height in pixels. The band won't be sized larger
		///            than that.
		/// \param[in] heightChangeStepSize The number of pixels by which the new band's height can be changed
		///            in a single step. If the control changes the band's height, the difference between old
		///            and new height will be a multiple of this value.
		/// \param[in] variableHeight If set to \c True, the new band's height can be changed by the control;
		///            otherwise not.
		/// \param[in] showTitle If set to \c True, the new band's caption, which may consist of text and an
		///            icon, is displayed; otherwise not.
		/// \param[in] text The new band's text. The maximum number of characters in this text is 8192.
		/// \param[in] iconIndex The zero-based index of the new band's icon in the control's \c ilBands image
		///            list. If set to -2, no icon is displayed for this band.
		/// \param[in] bandData A \c Long value that will be associated with the new band.
		/// \param[in] titleWidth The width (in pixels) of the new band's caption, which may consist of text
		///            and an icon. If set to -1, the caption is sized automatically.
		/// \param[in] hideIfVertical If set to \c True, the new band is displayed if the control's orientation
		///            is vertical; otherwise it is displayed on horizontal orientation only.
		/// \param[in] addMarginsAroundChild If set to \c True, a small margin is inserted at the top and
		///            bottom of the new band's contained window; otherwise not.
		///
		/// \return The inserted band.
		///
		/// \remarks If the parameter \c variableHeight is set to \c False, the parameters \c maximumHeight and
		///          \c heightChangeStepSize are ignored.
		///
		/// \sa Count, Remove, RemoveAll, IReBarBand::hContainedWindow, IReBarBand::NewLine,
		///     IReBarBand::SizingGripVisibility, IReBarBand::Resizable, IReBarBand::KeepInFirstRow,
		///     IReBarBand::Visible, IReBarBand::IdealWidth, IReBarBand::MinimumWidth,
		///     IReBarBand::MinimumHeight, IReBarBand::MaximumHeight, IReBarBand::HeightChangeStepSize,
		///     IReBarBand::VariableHeight, IReBarBand::ShowTitle, IReBarBand::Text, IReBarBand::IconIndex,
		///     IReBar::hImageList, IReBarBand::BandData, IReBarBand::TitleWidth, IReBarBand::HideIfVertical,
		///     IReBar::Orientation, IReBarBand::AddMarginsAroundChild, SizingGripVisibilityConstants
		[id(DISPID_RBBS_ADD), helpstring("Adds a new band with the specified properties.")]
		HRESULT Add([in, defaultvalue(-1)] LONG insertAt, [in, defaultvalue(0)] OLE_HANDLE hContainedWindow, [in, defaultvalue(0)] VARIANT_BOOL NewLine, [in, defaultvalue(sgvAutomatic)] SizingGripVisibilityConstants SizingGripVisibility, [in, defaultvalue(-1)] VARIANT_BOOL Resizable, [in, defaultvalue(0)] VARIANT_BOOL KeepInFirstRow, [in, defaultvalue(-1)] VARIANT_BOOL Visible, [in, defaultvalue(0)] OLE_XSIZE_PIXELS IdealWidth, [in, defaultvalue(-1)] OLE_XSIZE_PIXELS MinimumWidth, [in, defaultvalue(-1)] OLE_YSIZE_PIXELS MinimumHeight, [in, defaultvalue(-1)] OLE_YSIZE_PIXELS MaximumHeight, [in, defaultvalue(-1)] OLE_YSIZE_PIXELS HeightChangeStepSize, [in, defaultvalue(0)] VARIANT_BOOL VariableHeight, [in, defaultvalue(-1)] VARIANT_BOOL ShowTitle, [in, defaultvalue("")] BSTR Text, [in, defaultvalue(-2)] LONG IconIndex, [in, defaultvalue(0)] LONG BandData, [in, defaultvalue(-1)] OLE_XSIZE_PIXELS TitleWidth, [in, defaultvalue(0)] VARIANT_BOOL HideIfVertical, [in, defaultvalue(0)] VARIANT_BOOL AddMarginsAroundChild, [out, retval] IReBarBand** ppAddedBand);
		/// \brief <em>Retrieves whether the specified band is part of the band collection</em>
		///
		/// \param[in] bandIdentifier A value that identifies the band to be checked.
		/// \param[in] bandIdentifierType A value specifying the meaning of \c bandIdentifier. Any of the
		///            values defined by the \c BandIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified band is part of the collection; otherwise \c False.
		///
		/// \sa Filter, Add, Remove, BandIdentifierTypeConstants
		[id(DISPID_RBBS_CONTAINS), helpstring("Retrieves whether the specified band is part of the band collection.")]
		HRESULT Contains([in] LONG bandIdentifier, [in, defaultvalue(bitIndex)] BandIdentifierTypeConstants bandIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the bands in the collection</em>
		///
		/// Retrieves the number of \c ReBarBand objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_RBBS_COUNT), helpstring("Retrieves the number of 'ReBarBand' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified band in the collection from the rebar</em>
		///
		/// \param[in] bandIdentifier A value that identifies the rebar band to be removed.
		/// \param[in] bandIdentifierType A value specifying the meaning of \c bandIdentifier. Any of the
		///            values defined by the \c BandIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Add, Count, RemoveAll, Contains, BandIdentifierTypeConstants
		[id(DISPID_RBBS_REMOVE), helpstring("Removes the specified band in the collection from the control.")]
		HRESULT Remove([in] LONG bandIdentifier, [in, defaultvalue(bitIndex)] BandIdentifierTypeConstants bandIdentifierType);
		/// \brief <em>Removes all bands in the collection from the rebar</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_RBBS_REMOVEALL), helpstring("Removes all bands in the collection from the control.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IReBarBandsEvents
	/// \brief <em>The \c ReBarBands class' events interface</em>
	///
	/// This interface defines all events the \c ReBarBands class may raise.
	///
	/// \sa IReBarBands
	[
		uuid(EE4E1170-A63C-4a68-8A22-E5EA0FE85700),
		helpstring("IReBarBands-event-interface")
	]
	dispinterface _IReBarBandsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ReBarBands class</em>
	///
	/// This COM class implements the \c IReBarBands and \c _IReBarBandsEvents interfaces.
	///
	/// \sa IReBarBands, _IReBarBandsEvents, ReBar, ReBarBand
	[
		uuid(3B4FB3DB-226D-46db-8C72-39B4C9F207B6),
		version(1.3),
		noncreatable,
		helpstring("ReBarBands Class 1.3 (ANSI)")
	]
	coclass ReBarBands
	{
		[default] interface IReBarBands;
		[default, source] dispinterface _IReBarBandsEvents;
	};


	/// \interface IReBar
	/// \brief <em>The main interface</em>
	///
	/// This is the date time picker control's main interface. It wraps the control window.
	///
	/// \sa _IReBarEvents
	[
		object,
		uuid(1DF89D4A-C1A0-44d0-B733-50063B8594D0),
		dual,
		nonextensible,
		helpstring("IReBar interface"),
		pointer_default(unique)
	]
	interface IReBar : IDispatch
	{
		/// \brief <em>Specifies whether the bands can be reordered by the user</em>
		///
		/// Retrieves or sets whether the user can bring the bands into a different order using drag'n'drop. If
		/// set to \c True, reordering is possible; otherwise not.
		///
		/// \sa IReBarBand::SizingGripVisibility
		[propget, id(DISPID_RB_ALLOWBANDREORDERING), helpstring("Retrieves or sets whether the user can bring the bands into a different order using drag'n'drop.")]
		HRESULT AllowBandReordering([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_ALLOWBANDREORDERING), helpstring("Retrieves or sets whether the user can bring the bands into a different order using drag'n'drop.")]
		HRESULT AllowBandReordering([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, AppearanceConstants
		[propget, id(DISPID_RB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_RB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RB_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RB_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RB_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Controls the band layouting</em>
		///
		/// Retrieves or sets whether the bands are layouted automatically if the control's size or position
		/// changes. If set to \c True, the layout is changed automatically; otherwise not.
		///
		/// \sa _IReBarEvents::AutoSized, _IReBarEvents::LayoutChanged
		[propget, id(DISPID_RB_AUTOUPDATELAYOUT), helpstring("Retrieves or sets whether the bands are layouted automatically if the control's size or position changes.")]
		HRESULT AutoUpdateLayout([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_AUTOUPDATELAYOUT), helpstring("Retrieves or sets whether the bands are layouted automatically if the control's size or position changes.")]
		HRESULT AutoUpdateLayout([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color. If set to -1, the system's default is used.
		///
		/// \remarks This property isn't supported for themed rebars.
		///
		/// \sa ForeColor, HighlightColor, ShadowColor, IReBarBand::BackColor, IReBarBand::hBackgroundBitmap
		[propget, id(DISPID_RB_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property isn't supported for themed rebars.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_RB_BACKCOLOR), helpstring("Retrieves or sets the control's background color. This property isn't supported for themed rebars.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Retrieves the control's bands</em>
		///
		/// Retrieves a collection object wrapping the rebar bands.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IReBarBands
		[propget, id(DISPID_RB_BANDS), helpstring("Retrieves a collection object wrapping the control's bands."), nonbrowsable]
		HRESULT Bands([out, retval] IReBarBands** ppBands);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderStyleConstants
		[propget, id(DISPID_RB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_RB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RB_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RB_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Retrieves the control's height in pixels</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa IReBarBand::RowHeight
		[propget, id(DISPID_RB_CONTROLHEIGHT), helpstring("Retrieves the control's height in pixels."), nonbrowsable]
		HRESULT ControlHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_RB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_RB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Specifies whether the bands are visually separated</em>
		///
		/// Retrieves or sets whether adjacent bands are separated by a thin border. If set to \c True, a
		/// border is drawn between adjacent bands; otherwise not.
		///
		/// \sa DisplaySplitter, HighlightColor, ShadowColor, IReBarBand::AddMarginsAroundChild
		[propget, id(DISPID_RB_DISPLAYBANDSEPARATORS), helpstring("Retrieves or sets whether adjacent bands are separated by a thin border.")]
		HRESULT DisplayBandSeparators([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_DISPLAYBANDSEPARATORS), helpstring("Retrieves or sets whether adjacent bands are separated by a thin border.")]
		HRESULT DisplayBandSeparators([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control displays a splitter at its bottom</em>
		///
		/// Retrieves or sets whether a splitter is displayed at the bottom of the control. If the mouse is
		/// moved over this splitter, the cursor is changed to a sizing cursor. Dragging the splitter doesn't
		/// resize the control, but raises the \c DraggingSplitter event. If set to \c True, the splitter is
		/// displayed; otherwise not.
		///
		/// \remarks Requires comctl32.dll version 6.10 or higher.
		///
		/// \sa DisplayBandSeparators, _IReBarEvents::DraggingSplitter
		[propget, id(DISPID_RB_DISPLAYSPLITTER), helpstring("Retrieves or sets whether a splitter is displayed at the bottom of the control. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DisplaySplitter([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_DISPLAYSPLITTER), helpstring("Retrieves or sets whether a splitter is displayed at the bottom of the control. Requires comctl32.dll version 6.10 or higher.")]
		HRESULT DisplaySplitter([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_RB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		[propget, id(DISPID_RB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the bands all have the same height</em>
		///
		/// Retrieves or sets whether the rebar bands are sized using each individual band's minimum height
		/// or using the tallest band's height. If set to \c True, the tallest band's height is used for all
		/// bands; otherwise each band is sized individually using its minimum height.
		///
		/// \sa IReBarBand::CurrentHeight
		[propget, id(DISPID_RB_FIXEDBANDHEIGHT), helpstring("Retrieves or sets whether the rebar bands are sized using each individual band's minimum height or using the tallest band's height.")]
		HRESULT FixedBandHeight([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_FIXEDBANDHEIGHT), helpstring("Retrieves or sets whether the rebar bands are sized using each individual band's minimum height or using the tallest band's height.")]
		HRESULT FixedBandHeight([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the band captions.
		///
		/// \remarks This property isn't supported for themed rebars.
		///
		/// \sa UseSystemFont
		[propget, id(DISPID_RB_FONT), helpstring("Retrieves or sets the control's font. This property isn't supported for themed rebars.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_RB_FONT), helpstring("Retrieves or sets the control's font. This property isn't supported for themed rebars.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_RB_FONT), helpstring("Retrieves or sets the control's font. This property isn't supported for themed rebars.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the control's text color</em>
		///
		/// Retrieves or sets the control's text color. If set to -1, the system's default is used.
		///
		/// \remarks This property isn't supported for themed rebars.
		///
		/// \sa BackColor, HighlightColor, ShadowColor, IReBarBand::ForeColor
		[propget, id(DISPID_RB_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property isn't supported for themed rebars.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_RB_FORECOLOR), helpstring("Retrieves or sets the control's text color. This property isn't supported for themed rebars.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies the control's 3D highlight color</em>
		///
		/// Retrieves or sets the color used by the control to draw highlighted parts of 3D elements like band
		/// borders and sizing grips. If set to -1, the default color is used.
		///
		/// \remarks This property isn't supported for themed rebars.
		///
		/// \sa ShadowColor, BackColor, ForeColor, DisplayBandSeparators, IReBarBand::SizingGripVisibility
		[propget, id(DISPID_RB_HIGHLIGHTCOLOR), helpstring("Retrieves or sets the color used by the control to draw highlighted parts of 3D elements like band borders and sizing grips. If set to -1, the default color is used. This property isn't supported for themed rebars.")]
		HRESULT HighlightColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_RB_HIGHLIGHTCOLOR), helpstring("Retrieves or sets the color used by the control to draw highlighted parts of 3D elements like band borders and sizing grips. If set to -1, the default color is used. This property isn't supported for themed rebars.")]
		HRESULT HighlightColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies one of the control's associated imagelist</em>
		///
		/// Retrieves or sets the handle of the specified imagelist.
		///
		/// \param[in] imageList The imageList to retrieve or set. Some of the values defined by the
		///            \c ImageListConstants enumeration is valid.
		///
		/// \remarks The previously set image list does NOT get destroyed automatically.
		///
		/// \sa ImageListConstants
		[propget, id(DISPID_RB_HIMAGELIST), helpstring("Retrieves or sets the handle of the specified imagelist."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_RB_HIMAGELIST), helpstring("Retrieves or sets the handle of the specified imagelist."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [in] OLE_HANDLE newValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IReBarEvents::MouseHover
		[propget, id(DISPID_RB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_RB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Specifies the palette used by the control</em>
		///
		/// Retrieves or sets the palette used by the control when drawing itself.
		///
		/// \remarks The previously set palette does NOT get destroyed automatically.
		///
		/// \sa IReBarBand::hBackgroundBitmap
		[propget, id(DISPID_RB_HPALETTE), helpstring("Retrieves or sets the palette used by the control when drawing itself."), nonbrowsable]
		HRESULT hPalette([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_RB_HPALETTE), helpstring("Retrieves or sets the palette used by the control when drawing itself."), nonbrowsable]
		HRESULT hPalette([in] OLE_HANDLE newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWndNotificationReceiver, _IReBarEvents::RecreatedControlWindow,
		///     _IReBarEvents::DestroyedControlWindow
		[propget, id(DISPID_RB_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the handle of the window that the control sends notifications to</em>
		///
		/// Retrieves or sets the handle of the window that the control sends notifications to.
		///
		/// \sa hWnd
		[propget, id(DISPID_RB_HWNDNOTIFICATIONRECEIVER), helpstring("Retrieves or sets the handle of the window that the control sends notifications to."), nonbrowsable]
		HRESULT hWndNotificationReceiver([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_RB_HWNDNOTIFICATIONRECEIVER), helpstring("Retrieves or sets the handle of the window that the control sends notifications to."), nonbrowsable]
		HRESULT hWndNotificationReceiver([in] OLE_HANDLE newValue);
		// \brief <em>Specifies the tooltip control's window handle</em>
		//
		// Retrieves or sets the tooltip control's window handle.
		//
		// \remarks The previously set tooltip window does NOT get destroyed automatically.
		//
		// \sa ShowToolTips
		//[propget, id(DISPID_RB_HWNDTOOLTIP), helpstring("Retrieves or sets the tooltip control's window handle."), nonbrowsable]
		//HRESULT hWndToolTip([out, retval] OLE_HANDLE* pValue);
		//[propput, id(DISPID_RB_HWNDTOOLTIP), helpstring("Retrieves or sets the tooltip control's window handle."), nonbrowsable]
		//HRESULT hWndToolTip([in] OLE_HANDLE newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RB_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies which rebar band replaces the menu bar in MDI windows</em>
		///
		/// Retrieves or sets the rebar band that replaces the parent window's menu bar if the parent window is
		/// a MDI frame window and the \c ReplaceMDIFrameMenu property is set to \c rmfmFullReplace.
		///
		/// \sa ReplaceMDIFrameMenu, Bands, IReBarBand, ReplaceMDIFrameMenuConstants
		[propget, id(DISPID_RB_MDIFRAMEMENUBAND), helpstring("Retrieves or sets the rebar band that replaces the parent window's menu bar if the parent window is a MDI frame window and the 'ReplaceMDIFrameMenu' property is set to 'rmfmFullReplace'."), nonbrowsable]
		HRESULT MDIFrameMenuBand([out, retval] IReBarBand** ppMenuBand);
		[propputref, id(DISPID_RB_MDIFRAMEMENUBAND), helpstring("Retrieves or sets the rebar band that replaces the parent window's menu bar if the parent window is a MDI frame window and the 'ReplaceMDIFrameMenu' property is set to 'rmfmFullReplace'."), nonbrowsable]
		HRESULT MDIFrameMenuBand([in] IReBarBand* pNewMenuBand);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_RB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_RB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_RB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_RB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_RB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Retrieves the native rebar control's \c IDropTarget implementation</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa RegisterForOLEDragDrop
		[propget, id(DISPID_RB_NATIVEDROPTARGET), helpstring("Retrieves the native rebar control's 'IDropTarget' implementation."), nonbrowsable]
		HRESULT NativeDropTarget([out, retval] IUnknown** ppValue);
		/// \brief <em>Retrieves the number of band rows</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa IReBarBand::RowHeight
		[propget, id(DISPID_RB_NUMBEROFROWS), helpstring("Retrieves the number of band rows."), nonbrowsable]
		HRESULT NumberOfRows([out, retval] LONG* pValue);
		/// \brief <em>Controls the control's orientation</em>
		///
		/// Retrieves or sets the direction, in which the control displays bands. Any of the values defined by
		/// the \c OrientationConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa IReBarBand::HideIfVertical, VerticalSizingGripsOnVerticalOrientation, OrientationConstants
		[propget, id(DISPID_RB_ORIENTATION), helpstring("Retrieves or sets the direction, in which the control displays bands. Changing this property destroys and recreates the control window.")]
		HRESULT Orientation([out, retval] OrientationConstants* pValue);
		[propput, id(DISPID_RB_ORIENTATION), helpstring("Retrieves or sets the direction, in which the control displays bands. Changing this property destroys and recreates the control window.")]
		HRESULT Orientation([in] OrientationConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_RB_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. Any of the
		/// values defined by the \c RegisterForOLEDragDropConstants enumeration is valid.
		///
		/// \sa SupportOLEDragImages, _IReBarEvents::OLEDragEnter, RegisterForOLEDragDropConstants
		[propget, id(DISPID_RB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] RegisterForOLEDragDropConstants* pValue);
		[propput, id(DISPID_RB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] RegisterForOLEDragDropConstants newValue);
		/// \brief <em>Specifies whether the control replaces the menu bar if it sits inside a MDI frame window</em>
		///
		/// Retrieves or sets whether the control replaces the parent window's menu bar if the parent window is
		/// a MDI frame window. Any of the values defined by the \c ReplaceMDIFrameMenuConstants enumeration is
		/// valid.
		///
		/// \remarks This property cannot be set at runtime.
		///
		/// \sa MDIFrameMenuBand, ReplaceMDIFrameMenuConstants
		[propget, id(DISPID_RB_REPLACEMDIFRAMEMENU), helpstring("Retrieves or sets whether the control replaces the parent window's menu bar if the parent window is a MDI frame window. This property cannot be set at runtime.")]
		HRESULT ReplaceMDIFrameMenu([out, retval] ReplaceMDIFrameMenuConstants* pValue);
		[propput, id(DISPID_RB_REPLACEMDIFRAMEMENU), helpstring("Retrieves or sets whether the control replaces the parent window's menu bar if the parent window is a MDI frame window. This property cannot be set at runtime.")]
		HRESULT ReplaceMDIFrameMenu([in] ReplaceMDIFrameMenuConstants newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_RB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_RB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies the control's 3D shadow color</em>
		///
		/// Retrieves or sets the color used by the control to draw shadowed parts of 3D elements like band
		/// borders and sizing grips. If set to -1, the default color is used.
		///
		/// \remarks This property isn't supported for themed rebars.
		///
		/// \sa HighlightColor, BackColor, ForeColor, DisplayBandSeparators, IReBarBand::SizingGripVisibility
		[propget, id(DISPID_RB_SHADOWCOLOR), helpstring("Retrieves or sets the color used by the control to draw shadowed parts of 3D elements like band borders and sizing grips. If set to -1, the default color is used. This property isn't supported for themed rebars.")]
		HRESULT ShadowColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_RB_SHADOWCOLOR), helpstring("Retrieves or sets the color used by the control to draw shadowed parts of 3D elements like band borders and sizing grips. If set to -1, the default color is used. This property isn't supported for themed rebars.")]
		HRESULT ShadowColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_RB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_RB_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Controls when the control minimizes or maximizes a band</em>
		///
		/// Retrieves or sets whether a double-click is required to toggle a band's minimized or maximized
		/// state. If set to \c True, a band is minimized or maximized if it is double-clicked; otherwise
		/// if it is single-clicked.
		///
		/// \sa IReBarBand::Maximize, IReBarBand::Minimize, _IReBarEvents::DblClick,
		///     _IReBarEvents::TogglingBand
		[propget, id(DISPID_RB_TOGGLEONDOUBLECLICK), helpstring("Retrieves or sets whether a double-click is required to toggle a band's minimized or maximized state.")]
		HRESULT ToggleOnDoubleClick([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_TOGGLEONDOUBLECLICK), helpstring("Retrieves or sets whether a double-click is required to toggle a band's minimized or maximized state.")]
		HRESULT ToggleOnDoubleClick([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \remarks This property isn't supported for themed rebars.
		///
		/// \sa Font
		[propget, id(DISPID_RB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property. This property isn't supported for themed rebars.")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property. This property isn't supported for themed rebars.")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_RB_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);
		/// \brief <em>Specifies how the sizing grips are drawn if the control is orientated vertically</em>
		///
		/// Retrieves or sets whether sizing grips are drawn vertically if the \c Orientation property is set
		/// to \c oVertical. If set to \c True, sizing grips are drawn vertically then; otherwise horizontally.
		///
		/// \sa Orientation, IReBarBand::SizingGripVisibility
		[propget, id(DISPID_RB_VERTICALSIZINGGRIPSONVERTICALORIENTATION), helpstring("Retrieves or sets whether sizing grips are drawn vertically if the 'Orientation' property is set to 'oVertical'.")]
		HRESULT VerticalSizingGripsOnVerticalOrientation([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RB_VERTICALSIZINGGRIPSONVERTICALORIENTATION), helpstring("Retrieves or sets whether sizing grips are drawn vertically if the 'Orientation' property is set to 'oVertical'.")]
		HRESULT VerticalSizingGripsOnVerticalOrientation([in] VARIANT_BOOL newValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_RB_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Starts dragging a band</em>
		///
		/// Puts the control into drag'n'drop mode.
		///
		/// \param[in] bandToDrag The band to drag.
		/// \param[in] xMousePosition The x-coordinate (in pixels) of the mouse cursor's position relative to
		///            the control's upper-left corner.
		/// \param[in] yMousePosition The y-coordinate (in pixels) of the mouse cursor's position relative to
		///            the control's upper-left corner.
		///
		/// \remarks If \c xMousePosition or \c yMousePosition is set to -1, the position, that the mouse
		///          cursor had on the last processed message, is used. If \c xMousePosition or
		///          \c yMousePosition is set to -2, the mouse cursor's position on the last \c MouseDown
		///          message is used.\n
		///          The \c BandBeginDrag event won't be raised.
		///
		/// \sa DragMoveBand, EndDragBand, _IReBarEvents::BandBeginDrag
		[id(DISPID_RB_BEGINDRAGBAND), helpstring("Puts the control into drag'n'drop mode. The 'BandBeginDrag' event won't be raised.")]
		HRESULT BeginDragBand([in] IReBarBand* bandToDrag, [in, defaultvalue(-1)] LONG xMousePosition, [in, defaultvalue(-1)] LONG yMousePosition);
		/// \brief <em>Sets the drag position while dragging a band</em>
		///
		/// Sets the drag position is the control is in drag'n'drop mode.
		///
		/// \param[in] xMousePosition The x-coordinate (in pixels) of the mouse cursor's position relative to
		///            the control's upper-left corner.
		/// \param[in] yMousePosition The y-coordinate (in pixels) of the mouse cursor's position relative to
		///            the control's upper-left corner.
		///
		/// \remarks If \c xMousePosition or \c yMousePosition is set to -1, the position, that the mouse
		///          cursor had on the last processed message, is used.
		///
		/// \sa BeginDragBand, EndDragBand
		[id(DISPID_RB_DRAGMOVEBAND), helpstring("Sets the drag position is the control is in drag'n'drop mode.")]
		HRESULT DragMoveBand([in, defaultvalue(-1)] LONG xMousePosition, [in, defaultvalue(-1)] LONG yMousePosition);
		/// \brief <em>Ends drag'n'drop mode</em>
		///
		/// \remarks The \c BandEndDrag event won't be raised.
		///
		/// \sa BeginDragBand, EndDragBand, _IReBarEvents::BandEndDrag
		[id(DISPID_RB_ENDDRAGBAND), helpstring("Ends drag'n'drop mode. The 'BandEndDrag' event won't be raised.")]
		HRESULT EndDragBand(void);
		/// \brief <em>Retrieves the margins around a band</em>
		///
		/// Retrieves the size (in pixels) of the margins around a band.
		///
		/// \param[out] leftMargin The width (in pixels) of the margin on the left of a band.
		/// \param[out] topMargin The height (in pixels) of the margin on the top of a band.
		/// \param[out] rightMargin The width (in pixels) of the margin on the right of a band.
		/// \param[out] bottomMargin The height (in pixels) of the margin on the bottom of a band.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa IReBarBand::AddMarginsAroundChild, IReBarBand::GetBorderSizes, IReBarBand::GetRectangle
		[id(DISPID_RB_GETMARGINS), helpstring("Retrieves the size (in pixels) of the margins around a band. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT GetMargins([in, out, defaultvalue(0)] OLE_XSIZE_PIXELS* leftMargin, [in, out, defaultvalue(0)] OLE_YSIZE_PIXELS* topMargin, [in, out, defaultvalue(0)] OLE_XSIZE_PIXELS* rightMargin, [in, out, defaultvalue(0)] OLE_YSIZE_PIXELS* bottomMargin);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in,out] hitTestDetails Receives a value specifying the exact part of the control the
		///                specified point lies in. Any of the values defined by the \c HitTestConstants
		///                enumeration is valid.
		///
		/// \return The band that the specified point belongs to. \c Nothing, if no band was "hit".
		///
		/// \sa HitTestConstants
		// \sa BandBoundingBoxDefinition, HitTestConstants
		[id(DISPID_RB_HITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] HitTestConstants* hitTestDetails, [out, retval] IReBarBand** ppHitBand);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile
		[id(DISPID_RB_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_RB_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile
		[id(DISPID_RB_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Resizes the control and changes its layout to best fit a given rectangle</em>
		///
		/// Resizes the control and reorganizes the bands so that the control's bounding rectangle matches the
		/// specified rectangle as good as possible.
		///
		/// \param[in] xLeft The x-coordinate (in pixels) of the rectangle's upper-left corner.
		/// \param[in] yTop The y-coordinate (in pixels) of the rectangle's upper-left corner.
		/// \param[in] xRight The x-coordinate (in pixels) of the rectangle's lower-right corner.
		/// \param[in] yBottom The y-coordinate (in pixels) of the rectangle's lower-right corner.
		///
		/// \return \c True if the layout has been changed; otherwise \c False.
		///
		/// \sa _IReBarEvents::ResizedControlWindow, _IReBarEvents::LayoutChanged
		[id(DISPID_RB_SIZETORECTANGLE), helpstring("Resizes the control and reorganizes the bands so that the control's bounding rectangle matches the specified rectangle as good as possible.")]
		HRESULT SizeToRectangle([in] OLE_XPOS_PIXELS xLeft, [in] OLE_YPOS_PIXELS yTop, [in] OLE_XPOS_PIXELS xRight, [in] OLE_YPOS_PIXELS yBottom, [out, retval] VARIANT_BOOL* pLayoutChanged);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IReBarEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_RB_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IReBarEvents
	/// \brief <em>The \c ReBar class' events interface</em>
	///
	/// This interface defines all events the \c ReBar class may raise.
	///
	/// \sa IReBar
	[
		uuid(C059D9FA-138E-400b-9D41-22E44476BF36),
		helpstring("IReBar-event-interface")
	]
	dispinterface _IReBarEvents
	{
		properties:
		methods:
			/// \brief <em>The layout of the bands has been changed</em>
			///
			/// Will be fired after the layout of the bands has been changed.
			///
			/// \remarks This is the control's default event.
			///
			/// \sa ResizingContainedWindow, AutoSized, HeightChanged, ResizedControlWindow
			[id(DISPID_RBE_LAYOUTCHANGED), helpstring("Will be fired after the layout of the bands has been changed.")]
			void LayoutChanged(void);
			/// \brief <em>A band is about to be moved to a new line</em>
			///
			/// Will be fired before a band is moved to a new line uring an automatic update to the layout.
			///
			/// \param[in] band The band that is about to be moved.
			/// \param[in,out] doAutoBreak If set to \c True, the band is moved to a new line; otherwise it
			///                remains in the current row.
			///
			/// \remarks Requires comctl32.dll version 6.0 or higher.
			///
			/// \sa LayoutChanged, IReBarBand::NewLine
			[id(DISPID_RBE_AUTOBREAKINGBAND), helpstring("Will be fired before a band is moved to a new line uring an automatic update to the layout. Requires comctl32.dll version 6.0 or higher.")]
			void AutoBreakingBand(IReBarBand* band, VARIANT_BOOL* doAutoBreak);
			/// \brief <em>The control has resized itself automatically</em>
			///
			/// Will be fired after the control has resized itself automatically.
			///
			/// \param[in] targetRectangle The rectangle to which the control tried to size itself.
			/// \param[in] actualRectangle The rectangle to which the control actually sized itself.
			/// \param[in] changedBandHeightOrStyle Indicates if the bands' height or style has changed. If set
			///            to \c True, it has changed; otherwise not.
			///
			/// \sa HeightChanged, LayoutChanged, ResizedControlWindow, RECTANGLE, IReBar::AutoUpdateLayout
			[id(DISPID_RBE_AUTOSIZED), helpstring("Will be fired after the control has resized itself automatically.")]
			void AutoSized(RECTANGLE* targetRectangle, RECTANGLE* actualRectangle, VARIANT_BOOL changedBandHeightOrStyle);
			/// \brief <em>The user seems to want to drag a band</em>
			///
			/// Will be fired if the user seems to want to drag a band using the left mouse button.
			///
			/// \param[in] band The band that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbLeftButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			/// \param[in,out] cancelDrag If set to \c True, drag'n'drop is aborted, i. e. the band isn't moved.
			///                If set to \c False, the band is dragged.
			///
			/// \sa BandBeginRDrag, BandEndDrag, IReBar::BeginDragBand, IReBar::AllowBandReordering,
			///     HitTestConstants
			[id(DISPID_RBE_BANDBEGINDRAG), helpstring("Will be fired if the user seems to want to drag a band using the left mouse button.")]
			void BandBeginDrag(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* cancelDrag);
			/// \brief <em>The user seems to want to drag a band</em>
			///
			/// Will be fired if the user seems to want to drag a band using the right mouse button.
			///
			/// \param[in] band The band that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbRightButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			/// \param[in,out] cancelDrag If set to \c True, drag'n'drop is aborted, i. e. the band isn't moved.
			///                If set to \c False, the band is dragged.
			///
			/// \sa BandBeginDrag, BandEndDrag, IReBar::BeginDragBand, IReBar::AllowBandReordering,
			///     HitTestConstants
			[id(DISPID_RBE_BANDBEGINRDRAG), helpstring("Will be fired if the user seems to want to drag a band using the right mouse button.")]
			void BandBeginRDrag(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* cancelDrag);
			/// \brief <em>The user has stopped dragging a band</em>
			///
			/// Will be fired if the user has stopped dragging a band.
			///
			/// \param[in] band The band that the user has dragged.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbLeftButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa BandBeginDrag, BandBeginRDrag, IReBar::EndDragBand, IReBar::AllowBandReordering,
			///     HitTestConstants
			[id(DISPID_RBE_BANDENDDRAG), helpstring("Will be fired if the user has stopped dragging a band.")]
			void BandEndDrag(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into a band's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor into the specified band's bounding rectangle.
			///
			/// \param[in] band The band that was entered.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa BandMouseLeave, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IReBar::DisabledEvents
			[id(DISPID_RBE_BANDMOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the specified band's bounding rectangle. This event may be disabled.")]
			void BandMouseEnter(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of a band's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor out of the specified band's bounding rectangle.
			///
			/// \param[in] band The band that was left.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa BandMouseEnter, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IReBar::DisabledEvents
			[id(DISPID_RBE_BANDMOUSELEAVE), helpstring("Will be fired if the user moved the mouse cursor out of the specified band's bounding rectangle. This event may be disabled.")]
			void BandMouseLeave(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The currently active (and maximized) MDI child window's system menu is about to be displayed</em>
			///
			/// Will be fired before the system menu of the currently active MDI child window is displayed. The
			/// child window has to be maximized and the \c ReplaceMDIFrameMenu property has to be set to either
			/// \c rmfmJustRemove or \c rmfmFullReplace, otherwise this event won't be fired.
			///
			/// \param[in] hActiveMDIChild The handle of the currently active MDI child window of which the
			///            system menu is about to be displayed.
			/// \param[in] hMenu The handle of the system menu that is about to be displayed.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[out] cancelMenu If set to \c True, the menu won't be displayed.
			///
			/// \sa CleanupMDIChildSystemMenu, IReBar::ReplaceMDIFrameMenu
			[id(DISPID_RBE_BEFOREDISPLAYMDICHILDSYSTEMMENU), helpstring("Will be fired before the system menu of the currently active MDI child window is displayed. The child window has to be maximized, otherwise this event won't be fired.")]
			void BeforeDisplayMDIChildSystemMenu(LONG hActiveMDIChild, LONG hMenu, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, VARIANT_BOOL* cancelMenu);
			/// \brief <em>A band's chevron button has been clicked</em>
			///
			/// Will be fired if a band's chevron button has been clicked. The application should display a
			/// popup window with those parts of the contained window, that cannot be displayed in the band
			/// itself.
			///
			/// \param[in] band The band whose chevron button has been clicked.
			/// \param[in] chevronRectangle The chevron button's bounding rectangle.
			/// \param[in] userData The \c Long value that has been passed to the \c ClickChevron method. If the
			///            chevron button has been clicked by the user, this parameter will be 0.
			/// \param[out] doDefault If set to \c True and the band's child window is a \c ToolBar control, the
			///             rebar control creates and displays a chevron popup automatically.
			///
			/// \sa IReBarBand::UseChevron, IReBarBand::ClickChevron
			[id(DISPID_RBE_CHEVRONCLICK), helpstring("Will be fired if a band's chevron button has been clicked.")]
			void ChevronClick(IReBarBand* band, RECTANGLE* chevronRectangle, LONG userData, VARIANT_BOOL* doDefault);
			/// \brief <em>Any modifications to the currently active (and maximized) MDI child window's system menu need to be removed</em>
			///
			/// Will be fired after the system menu of the currently active MDI child window has been displayed.
			/// The child window has to be maximized and the \c ReplaceMDIFrameMenu property has to be set to either
			/// \c rmfmJustRemove or \c rmfmFullReplace, otherwise this event won't be fired.\n
			/// Use this event to remove modifications made to the menu when handling the
			/// \c BeforeDisplayMDIChildSystemMenu event.
			///
			/// \param[in] hActiveMDIChild The handle of the currently active MDI child window of which the
			///            system menu should be cleaned up.
			/// \param[in] hMenu The handle of the system menu that should be cleaned up.
			///
			/// \sa BeforeDisplayMDIChildSystemMenu, IReBar::ReplaceMDIFrameMenu
			[id(DISPID_RBE_CLEANUPMDICHILDSYSTEMMENU), helpstring("Will be fired after the system menu of the currently active MDI child window has been displayed. The child window has to be maximized, otherwise this event won't be fired.")]
			void CleanupMDIChildSystemMenu(LONG hActiveMDIChild, LONG hMenu);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] band The band that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, HitTestConstants, IReBar::DisabledEvents
			[id(DISPID_RBE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] band The band the context menu refers to. Will be \c Nothing if the context
			///            menu should be displayed for the whole control instead of only for a single band.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the menu's proposed position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa RClick, HitTestConstants
			[id(DISPID_RBE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>Custom drawing should be done here</em>
			///
			/// Will be fired after the control processed a \c NM_CUSTOMDRAW notification allowing custom
			/// drawing of the control's content.
			///
			/// \param[in] band The band that the notification refers to. May be \c Nothing.
			/// \param[in] drawStage The stage of custom drawing this event is raised for. Most of the values
			///            defined by the \c CustomDrawStageConstants enumeration are valid.
			/// \param[in] bandState The band's current state. For current versions of Windows this seems to be
			///            always 0.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			/// \param[in,out] furtherProcessing Controls further drawing. Most of the values defined by the
			///                \c CustomDrawReturnValuesConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RECTANGLE, CustomDrawStageConstants, CustomDrawItemStateConstants,
			///     CustomDrawReturnValuesConstants, IReBar::DisabledEvents,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb774397.aspx">NM_CUSTOMDRAW (rebar)</a>
			[id(DISPID_RBE_CUSTOMDRAW), helpstring("Will be fired after the control processed a 'NM_CUSTOMDRAW' notification allowing custom drawing of the control's content. This event may be disabled.")]
			void CustomDraw(IReBarBand* band, CustomDrawStageConstants drawStage, CustomDrawItemStateConstants bandState, LONG hDC, RECTANGLE* drawingRectangle, CustomDrawReturnValuesConstants* furtherProcessing);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] band The band that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, HitTestConstants, IReBar::DisabledEvents
			[id(DISPID_RBE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IReBar::hWnd
			[id(DISPID_RBE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The control's splitter is being dragged</em>
			///
			/// Will be fired if the splitter, that may be used to change the control's height, is being dragged.
			///
			/// \remarks Requires comctl32.dll version 6.10 or higher.
			///
			/// \sa IReBar::DisplaySplitter
			[id(DISPID_RBE_DRAGGINGSPLITTER), helpstring("Will be fired if the splitter, that may be used to change the control's height, is being dragged. Requires comctl32.dll version 6.10 or higher.")]
			void DraggingSplitter(void);
			/// \brief <em>Any data associated with a band should be freed</em>
			///
			/// Will be fired if any data associated with the specified band should be freed.
			///
			/// \param[in] band The band for which to free the data. If \c Nothing, all bands' associated data
			///            shall be removed.
			///
			/// \remarks On program termination the application probably won't receive this event anymore,
			///          because Visual Basic shuts down the event receiver too early. So if you use this
			///          event to free any data, you should also add an event handler for \c Form_Unload (or
			///          similar) in which you iterate all bands freeing their associated data.\n
			///          This event may be disabled.
			///
			/// \sa RemovingBand, RemovedBand, IReBarBand::BandData, IReBar::DisabledEvents
			[id(DISPID_RBE_FREEBANDDATA), helpstring("Will be fired if any data associated with the specified band should be freed. This event may be disabled.")]
			void FreeBandData(IReBarBand* band);
			/// \brief <em>The control's height has changed</em>
			///
			/// Will be fired after the control's height has changed.
			///
			/// \sa AutoSized, LayoutChanged, ResizedControlWindow
			[id(DISPID_RBE_HEIGHTCHANGED), helpstring("Will be fired after the control's height has changed.")]
			void HeightChanged(void);
			/// \brief <em>A band was inserted</em>
			///
			/// Will be fired after a new band was inserted.
			///
			/// \param[in] band The band that was inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertingBand, RemovedBand, IReBarBand, IReBar::DisabledEvents
			[id(DISPID_RBE_INSERTEDBAND), helpstring("Will be fired after a new band was inserted. This event may be disabled.")]
			void InsertedBand(IReBarBand* band);
			/// \brief <em>A band is about to be inserted</em>
			///
			/// Will be fired before a new band is inserted.
			///
			/// \param[in] band The band that is about to be inserted.
			/// \param[in,out] cancelInsertion If set to \c True, insertion is aborted, i. e. the band
			///                isn't inserted. If set to \c False, the band is inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertedBand, RemovingBand, IVirtualReBarBand, IReBar::DisabledEvents
			[id(DISPID_RBE_INSERTINGBAND), helpstring("Will be fired before a new band is inserted. This event may be disabled.")]
			void InsertingBand(IVirtualReBarBand* band, VARIANT_BOOL* cancelInsertion);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] band The band that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, HitTestConstants, IReBar::DisabledEvents
			[id(DISPID_RBE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] band The band that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, HitTestConstants, IReBar::DisabledEvents
			[id(DISPID_RBE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] band The band that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IReBar::DisabledEvents
			[id(DISPID_RBE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] band The band that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, BandMouseEnter, MouseHover, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IReBar::DisabledEvents
			[id(DISPID_RBE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c IReBar::HoverTime property.
			///
			/// \param[in] band The band that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IReBar::HoverTime, HitTestConstants,
			///     ExtendedMouseButtonConstants, IReBar::DisabledEvents
			[id(DISPID_RBE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] band The band that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, BandMouseLeave, MouseHover, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IReBar::DisabledEvents
			[id(DISPID_RBE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] band The band that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, HitTestConstants, ExtendedMouseButtonConstants,
			///     IReBar::DisabledEvents
			[id(DISPID_RBE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] band The band that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IReBar::DisabledEvents
			[id(DISPID_RBE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control has received a \c WM_NCHITTEST message</em>
			///
			/// Will be fired if the control receives a \c WM_NCHITTEST message.
			///
			/// \param[in] band The band that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[out] returnValue The value to return in response of the \c WM_NCHITTEST message. Any of
			///             the \c HT* values specified on
			///             <a href="https://msdn.microsoft.com/en-us/library/ms645618.aspx">MSDN</a> is valid.\n
			///             Set this parameter to 0 to let the control process this message itself.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, HitTestConstants, IReBar::DisabledEvents,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms645618.aspx">WM_NCHITTEST</a>
			[id(DISPID_RBE_NONCLIENTHITTEST), helpstring("Will be fired if the control receives a 'WM_NCHITTEST' message. This event may be disabled.")]
			void NonClientHitTest(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, LONG* returnValue);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] dropTarget The band that is the nearest one from the mouse cursor's position.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, IReBar::RegisterForOLEDragDrop,
			///     IReBar::FinishOLEDragDrop, OLEDropEffectConstants, HitTestConstants
			[id(DISPID_RBE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IReBarBand* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The band that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another band.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, IReBar::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, HitTestConstants
			[id(DISPID_RBE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IReBarBand** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The band that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, IReBar::RegisterForOLEDragDrop,
			///     HitTestConstants
			[id(DISPID_RBE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, IReBarBand* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The band that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another band.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, IReBar::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, HitTestConstants
			[id(DISPID_RBE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IReBarBand** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A menu message needs to be processed</em>
			///
			/// Will be fired if a menu message has been received. Use this event to e.g. owner-draw the system
			/// menu of the currently active (and maximized) MDI child window.
			///
			/// \param[in] message The received message. The event is fired for the following messages:
			///            - \c WM_DRAWITEM
			///            - \c WM_INITMENUPOPUP
			///            - \c WM_MEASUREITEM
			///            - \c WM_MENUCHAR
			///            - \c WM_MENUSELECT
			///            - \c WM_NEXTMENU
			/// \param[in] wParam The message's \c wParam parameter.
			/// \param[in] lParam The message's \c lParam parameter.
			/// \param[out] result If the message has been handled, this parameter must be set to an appropriate
			///             return value as specified by the docs for this message.
			/// \param[out] handledEvent If the message has been handled, this parameter must be set to \c True.
			///
			/// \remarks This event may be disabled.\n
			///          This event won't be fired if the \c ReplaceMDIFrameMenu property is set to
			///          \c rmfmDontReplace.
			///
			/// \sa IReBar::ReplaceMDIFrameMenu, SelectedMenuItem, BeforeDisplayMDIChildSystemMenu,
			///     IReBar::DisabledEvents,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb775923.aspx">WM_DRAWITEM</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms646347.aspx">WM_INITMENUPOPUP</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb775925.aspx">WM_MEASUREITEM</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms646349.aspx">WM_MENUCHAR</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms646352.aspx">WM_MENUSELECT</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms647612.aspx">WM_NEXTMENU</a>
			[id(DISPID_RBE_RAWMENUMESSAGE), helpstring("Will be fired if a menu message has been received. Use this event to e.g. owner-draw the system menu of the currently active (and maximized) MDI child window. This event may be disabled.")]
			void RawMenuMessage(LONG message, LONG wParam, LONG lParam, LONG* result, VARIANT_BOOL* handledEvent);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] band The band that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, HitTestConstants, IReBar::DisabledEvents
			[id(DISPID_RBE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] band The band that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, HitTestConstants, IReBar::DisabledEvents
			[id(DISPID_RBE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IReBar::hWnd
			[id(DISPID_RBE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>The control is no longer capturing the mouse</em>
			///
			/// Will be fired after the control has released mouse capture.
			///
			/// \sa MouseMove
			[id(DISPID_RBE_RELEASEDMOUSECAPTURE), helpstring("Will be fired after the control has released mouse capture.")]
			void ReleasedMouseCapture(void);
			/// \brief <em>A band was removed</em>
			///
			/// Will be fired after a band was removed.
			///
			/// \param[in] band The band that was removed. If \c Nothing, all bands were removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovingBand, InsertedBand, IVirtualReBarBand, IReBar::DisabledEvents
			[id(DISPID_RBE_REMOVEDBAND), helpstring("Will be fired after a band was removed. If 'band' is 'Nothing', all bands were removed. This event may be disabled.")]
			void RemovedBand(IVirtualReBarBand* band);
			/// \brief <em>A band is about to be removed</em>
			///
			/// Will be fired before a band is removed.
			///
			/// \param[in] band The band that is about to be removed. If \c Nothing, all bands are removed.
			/// \param[in,out] cancelDeletion If set to \c True, deletion is aborted, i. e. the band isn't
			///                removed. If set to \c False, the band is removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovedBand, InsertingBand, IReBarBand, IReBar::DisabledEvents
			[id(DISPID_RBE_REMOVINGBAND), helpstring("Will be fired before a band is removed. If 'band' is 'Nothing', all bands are removed. This event may be disabled.")]
			void RemovingBand(IReBarBand* band, VARIANT_BOOL* cancelDeletion);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			///
			/// \sa HeightChanged, LayoutChanged, ResizingContainedWindow
			[id(DISPID_RBE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The size of a window contained in a band is changed</em>
			///
			/// Will be fired before the size of the window contained in the specified band is changed.
			///
			/// \param[in] band The band whose contained window is about to be resized.
			/// \param[in] bandClientRectangle The rectangle surrounding the area that the contained window may
			///            occupy.
			/// \param[in,out] containedWindowRectangle The rectangle to which the contained window is being
			///                resized. This rectangle may be changed by the event handler.
			///
			/// \sa ResizedControlWindow, LayoutChanged, IReBarBand::hContainedWindow
			[id(DISPID_RBE_RESIZINGCONTAINEDWINDOW), helpstring("Will be fired before the size of the window contained in the specified band is changed.")]
			void ResizingContainedWindow(IReBarBand* band, RECTANGLE* bandClientRectangle, RECTANGLE* containedWindowRectangle);
			/// \brief <em>The user has selected a menu item</em>
			///
			/// Will be fired if the user has selected a menu item. Use this event to e.g. display an
			/// explanatory text in the status bar for the system menu of the currently active (and maximized)
			/// MDI child window.
			///
			/// \param[in] commandIDOrSubMenuIndex The unique ID of the selected menu command. If the menu item
			///            opens a sub-menu, this parameter contains the zero-based index of the menu item within
			///            its containing menu. If the menu is closed, this parameter will be 0.
			/// \param[in] menuItemState A bit-field describing the state of the menu item. Any combination of
			///            the values defined by the \c MenuItemStateConstants enumeration is valid. If the menu
			///            is closed, this parameter will be 0xFFFF.
			/// \param[in] hMenu The handle of the menu that contains the selected menu item. If the menu is
			///            closed, this parameter will be 0.
			///
			/// \remarks This event won't be fired if the \c ReplaceMDIFrameMenu property is set to
			///          \c rmfmDontReplace.
			///
			/// \sa IReBar::ReplaceMDIFrameMenu, RawMenuMessage, BeforeDisplayMDIChildSystemMenu,
			///     MenuItemStateConstants
			[id(DISPID_RBE_SELECTEDMENUITEM), helpstring("Will be fired if the user has selected a menu item. Use this event to e.g. display an explanatory text in the status bar for the system menu of the currently active (and maximized) MDI child window.")]
			void SelectedMenuItem(LONG commandIDOrSubMenuIndex, MenuItemStateConstants menuItemState, LONG hMenu);
			/// \brief <em>A band is about to be minimized or maximized</em>
			///
			/// Will be fired before a band's minimized or maximized state is toggled.
			///
			/// \param[in] band The band whose minimized or maximized state is about to be toggled.
			/// \param[in,out] cancelToggling If set to \c True, toggling is aborted, i. e. the band's minimized
			///                or maximized state isn't changed. If set to \c False, the band's minimized or
			///                maximized state is toggled.
			///
			/// \remarks Current versions of Windows don't provide a way to determine which band's state will be
			///          toggled. Therefore the \c band parameter will always be \c Nothing.
			///
			/// \sa IReBar::ToggleOnDoubleClick
			[id(DISPID_RBE_TOGGLINGBAND), helpstring("Will be fired before a band's minimized or maximized state is toggled.")]
			void TogglingBand(IReBarBand* band, VARIANT_BOOL* cancelToggling);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] band The band that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IReBar::DisabledEvents
			[id(DISPID_RBE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] band The band that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IReBar::DisabledEvents
			[id(DISPID_RBE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(IReBarBand* band, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	};


	/// \brief <em>The \c ReBar class</em>
	///
	/// The control's main COM class. It implements the \c IReBar and
	/// \c _IReBarEvents interfaces.
	///
	/// \sa IReBar, _IReBarEvents
	[
		uuid(2E904F05-3C11-49d8-82F4-F06B6FC300F9),
		version(1.3),
		helpstring("ReBar Control 1.3 (ANSI)")
	]
	coclass ReBar
	{
		[default] interface IReBar;
		[default, source] dispinterface _IReBarEvents;
	};


	/// \interface IVirtualToolBarButton
	/// \brief <em>Wraps a not existing button</em>
	///
	/// This interface is a wrapper around a tool bar button that does not yet or not anymore exist within
	/// the control.
	///
	/// \sa _IVirtualToolBarButtonEvents, IToolBarButton, _IToolBarEvents
	[
		object,
		uuid(2F9E8608-3D95-4148-8229-55D659C1C760),
		dual,
		nonextensible,
		helpstring("IVirtualToolBarButton interface"),
		pointer_default(unique)
	]
	interface IVirtualToolBarButton : IDispatch
	{
		/// \brief <em>Specifies whether the button's width is adjusted automatically</em>
		///
		/// Retrieves or sets whether the button's width will be or was adjusted automatically depending on its
		/// text and icon. If set to \c True, the button's width will be or was adjusted automatically;
		/// otherwise not.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa Width, Text, IconIndex, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_AUTOSIZE), helpstring("Retrieves or sets whether the button's width will be or was adjusted automatically depending on its text and icon.")]
		HRESULT AutoSize([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_AUTOSIZE), helpstring("Retrieves or sets whether the button's width will be or was adjusted automatically depending on its text and icon.")]
		HRESULT AutoSize([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the button's associated data</em>
		///
		/// Retrieves or sets the \c Long value that will be or was associated with the button. Use this
		/// property to associate any data with the button.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa _IToolBarEvents::FreeButtonData, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_BUTTONDATA), helpstring("Retrieves or sets the Long value that will be or was associated with the button.")]
		HRESULT ButtonData([out, retval] LONG* pValue);
		[propput, id(DISPID_VTBB_BUTTONDATA), helpstring("Retrieves or sets the Long value that will be or was associated with the button.")]
		HRESULT ButtonData([in] LONG newValue);
		/// \brief <em>Controls the button's appearance and behavior</em>
		///
		/// Retrieves or sets which kind of button this button will be or was. Any of the values defined by the
		/// \c ButtonTypeConstants enumeration is valid.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa PartOfGroup, ButtonTypeConstants, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_BUTTONTYPE), helpstring("Retrieves or sets which kind of button this button will be or was.")]
		HRESULT ButtonType([out, retval] ButtonTypeConstants* pValue);
		[propput, id(DISPID_VTBB_BUTTONTYPE), helpstring("Retrieves or sets which kind of button this button will be or was.")]
		HRESULT ButtonType([in] ButtonTypeConstants newValue);
		/// \brief <em>Specifies whether the button's text is displayed</em>
		///
		/// Retrieves or sets whether the button's text will be or was displayed. If set to \c True, the
		/// button's text will be or was displayed next to the icon; otherwise it will be or was not displayed
		/// next to the icon, but as tool tip if the mouse cursor is moved over the button.
		///
		/// \remarks This property will be or was ignored, if the \c IToolBar::ButtonTextPosition is not set to
		///          \c btpRightToIcon or the \c IToolBar::AlwaysDisplayButtonText is set to \c True.\n
		///          This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa Text, IToolBar::AlwaysDisplayButtonText, IToolBar::ButtonTextPosition,
		///     _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_DISPLAYTEXT), helpstring("Retrieves or sets whether the button's text will be or was displayed.")]
		HRESULT DisplayText([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_DISPLAYTEXT), helpstring("Retrieves or sets whether the button's text will be or was displayed.")]
		HRESULT DisplayText([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the button's appearance and behavior</em>
		///
		/// Retrieves or sets whether the button will be or was a drop-down button and how the drop-down arrow
		/// will be or was displayed. Any of the values defined by the \c DropDownStyleConstants enumeration is
		/// valid.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa IToolBar::NormalDropDownButtonStyle, DropDownStyleConstants,
		///     _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_DROPDOWNSTYLE), helpstring("Retrieves or sets whether the button will be or was a drop-down button and how the drop-down arrow will be or was displayed.")]
		HRESULT DropDownStyle([out, retval] DropDownStyleConstants* pValue);
		[propput, id(DISPID_VTBB_DROPDOWNSTYLE), helpstring("Retrieves or sets whether the button will be or was a drop-down button and how the drop-down arrow will be or was displayed.")]
		HRESULT DropDownStyle([in] DropDownStyleConstants newValue);
		/// \brief <em>Controls whether the button accepts user input</em>
		///
		/// Retrieves or sets whether the button will accept or has accepted user input. If set to \c True, it
		/// will react or has reacted to user input;otherwise not.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa IToolBar::Enabled, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_ENABLED), helpstring("Retrieves or sets whether the button will accept or has accepted user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_ENABLED), helpstring("Retrieves or sets whether the button will accept or has accepted user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the next button after this one is placed on a new line</em>
		///
		/// Retrieves or sets whether the next button after this one will be or was placed on a new line. If
		/// set to \c True, the next button will be or was placed on a new line; otherwise not.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa IToolBar::WrapButtons, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_FOLLOWEDBYLINEBREAK), helpstring("Retrieves or sets whether the next button after this one will be or was placed on a new line.")]
		HRESULT FollowedByLineBreak([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_FOLLOWEDBYLINEBREAK), helpstring("Retrieves or sets whether the next button after this one will be or was placed on a new line.")]
		HRESULT FollowedByLineBreak([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the button's icon</em>
		///
		/// Retrieves or sets the zero-based index of the button's icon in the control's image lists. If set
		/// to -1, the control will fire or has fired the \c ButtonGetDisplayInfo event each time this
		/// property's value will be or was required. If set to -2, no icon will be or was displayed for
		/// this button.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa ImageListIndex, IToolBar::hImageList, _IToolBarEvents::ButtonGetDisplayInfo,
		///     ImageListConstants, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the button's icon in the control's image lists. If -1, the 'ButtonGetDisplayInfo' event is fired each time this property's value is required. If -2, no icon is displayed for this button.")]
		HRESULT IconIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_VTBB_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the button's icon in the control's image lists. If -1, the 'ButtonGetDisplayInfo' event is fired each time this property's value is required. If -2, no icon is displayed for this button.")]
		HRESULT IconIndex([in] LONG newValue);
		/// \brief <em>Specifies the button's ID</em>
		///
		/// Retrieves or sets an unique ID identifying this tool bar button.
		///
		/// \remarks This is the default property of the \c IVirtualToolBarButton interface.\n
		///          This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa Index, ButtonIdentifierTypeConstants, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_ID), helpstring("Retrieves or sets the tool bar button's unique ID.")]
		HRESULT ID([out, retval] LONG* pValue);
		[propput, id(DISPID_VTBB_ID), helpstring("Retrieves or sets the tool bar button's unique ID.")]
		HRESULT ID([in] LONG newValue);
		/// \brief <em>Specifies the button's image list</em>
		///
		/// Retrieves or sets the zero-based index of the control's image lists that the button's icons will be
		/// or were taken from. If set to -1, the control will fire or has fired the \c ButtonGetDisplayInfo
		/// event each time this property's value will be or was required.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa IconIndex, IToolBar::hImageList, _IToolBarEvents::ButtonGetDisplayInfo, ImageListConstants,
		///     _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_IMAGELISTINDEX), helpstring("Retrieves or sets the zero-based index of the control's image lists that the button's icons will be or were taken from. If set to -1, the control will fire or has fired the 'ButtonGetDisplayInfo' event each time this property's value is required.")]
		HRESULT ImageListIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_VTBB_IMAGELISTINDEX), helpstring("Retrieves or sets the zero-based index of the control's image lists that the button's icons will be or were taken from. If set to -1, the control will fire or has fired the 'ButtonGetDisplayInfo' event each time this property's value is required.")]
		HRESULT ImageListIndex([in] LONG newValue);
		/// \brief <em>Retrieves the button's zero-based index</em>
		///
		/// Retrieves the zero-based index identifying this tool bar button.
		///
		/// \remarks Although adding or removing buttons changes other buttons' indexes, the index is the best
		///          (and fastest) option to identify a button.\n
		///          This property is read-only.
		///
		/// \sa ID, ButtonIdentifierTypeConstants
		[propget, id(DISPID_VTBB_INDEX), helpstring("Retrieves the zero-based index identifying this tool bar button.")]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Specifies whether the button is tagged as "Marked"</em>
		///
		/// Retrieves or sets whether the button will be or was tagged as "Marked". It's up to the application
		/// how marked buttons are interpreted. If set to \c True, the button will be or was tagged as
		/// "Marked"; otherwise not.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa SelectionState, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_MARKED), helpstring("Retrieves or sets whether the button will be or was tagged as ""Marked"". It's up to the application how marked buttons are interpreted.")]
		HRESULT Marked([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_MARKED), helpstring("Retrieves or sets whether the button will be or was tagged as ""Marked"". It's up to the application how marked buttons are interpreted.")]
		HRESULT Marked([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the button is part of a button group</em>
		///
		/// Retrieves or sets whether the button will be or was part of a button group. If set to \c True, it
		/// will be or was part of a group; otherwise not.\n
		/// Among all consecutive buttons that are part of a group, only one button can be checked. A check
		/// button that is part of a group cannot be unchecked by simply clicking it a second time. This can be
		/// used to create option-button like behavior.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa ButtonType, SelectionState, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_PARTOFGROUP), helpstring("Retrieves or sets whether the button will be or was part of a button group.")]
		HRESULT PartOfGroup([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_PARTOFGROUP), helpstring("Retrieves or sets whether the button will be or was part of a button group.")]
		HRESULT PartOfGroup([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the button is drawn like being pushed</em>
		///
		/// Retrieves or sets whether the button will be or was drawn like being pushed. If set to \c True, it
		/// will be or was drawn like being pushed; otherwise not.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa SelectionState, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_PUSHED), helpstring("Retrieves or sets whether the button will be or was drawn like being pushed.")]
		HRESULT Pushed([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_PUSHED), helpstring("Retrieves or sets whether the button will be or was drawn like being pushed.")]
		HRESULT Pushed([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the state of the button if it is a check button</em>
		///
		/// Retrieves or sets the state of check buttons. Any of the values defined by the
		/// \c SelectionStateConstants enumeration is valid.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa ButtonType, Pushed, SelectionStateConstants, _IToolBarEvents::GetAvailableButton
		// \sa ButtonType, Pushed, SelectionStateConstants, _IToolBarEvents::ButtonSelectionStateChanged,
		//     _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_SELECTIONSTATE), helpstring("Retrieves or sets the state of check buttons.")]
		HRESULT SelectionState([out, retval] SelectionStateConstants* pValue);
		[propput, id(DISPID_VTBB_SELECTIONSTATE), helpstring("Retrieves or sets the state of check buttons.")]
		HRESULT SelectionState([in] SelectionStateConstants newValue);
		/// \brief <em>Specifies whether the button's text is cut off</em>
		///
		/// Retrieves or sets whether the button's text will be or was cut off. If set to \c True, the text
		/// will be or was cut off and an ellipsis will be or was displayed; otherwise not.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa Text, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_SHOWINGELLIPSIS), helpstring("Retrieves or sets whether the button's text will be or was cut off.")]
		HRESULT ShowingEllipsis([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_SHOWINGELLIPSIS), helpstring("Retrieves or sets whether the button's text will be or was cut off.")]
		HRESULT ShowingEllipsis([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the button's text</em>
		///
		/// Retrieves or sets the button's text. The maximum number of characters in this text is 8192.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa DisplayText, IconIndex, UseMnemonic, ShowingEllipsis, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_TEXT), helpstring("Retrieves or sets the button's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_VTBB_TEXT), helpstring("Retrieves or sets the button's text.")]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Specifies whether the button has an accelerator prefix associated with it</em>
		///
		/// Retrieves or sets whether the button has or had an accelerator prefix associated with it. If set to
		/// \c True, the first character of the button's text that is prefixed by an ampersand (&amp;), will be
		/// or was used as the button's accelerator prefix and this character will be or was underlined. If set
		/// to \c False, ampersands in the button's text will be or were interpreted as normal text.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa Text, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_USEMNEMONIC), helpstring("Retrieves or sets whether the button has or had an accelerator prefix associated with it.")]
		HRESULT UseMnemonic([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_USEMNEMONIC), helpstring("Retrieves or sets whether the button has or had an accelerator prefix associated with it.")]
		HRESULT UseMnemonic([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the button is visible</em>
		///
		/// Retrieves or sets whether the button will be or was visible. If set to \c True, the button will be
		/// or was displayed; otherwise not.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa IToolBarButtons::Remove, IToolBarButtons::Add, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_VISIBLE), helpstring("Retrieves or sets whether the button will be or was visible.")]
		HRESULT Visible([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_VTBB_VISIBLE), helpstring("Retrieves or sets whether the button will be or was visible.")]
		HRESULT Visible([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the button's current width</em>
		///
		/// Retrieves or sets the button's current width in pixels.
		///
		/// \remarks This property can be set from within the \c GetAvailableButton and
		///          \c RestoreButtonFromRegistryStream events only.
		///
		/// \sa AutoSize, _IToolBarEvents::GetAvailableButton
		[propget, id(DISPID_VTBB_WIDTH), helpstring("Retrieves or sets the button's current width in pixels.")]
		HRESULT Width([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_VTBB_WIDTH), helpstring("Retrieves or sets the button's current width in pixels.")]
		HRESULT Width([in] OLE_XSIZE_PIXELS newValue);
	}


	/// \interface _IVirtualToolBarButtonEvents
	/// \brief <em>The \c VirtualToolBarButton class' events interface</em>
	///
	/// This interface defines all events the \c VirtualToolBarButton class may raise.
	///
	/// \sa IVirtualToolBarButton
	[
		uuid(A23DBD54-B33C-40c7-ADA0-6316A4FB2899),
		helpstring("IVirtualToolBarButton-event-interface")
	]
	dispinterface _IVirtualToolBarButtonEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c VirtualToolBarButton class</em>
	///
	/// This COM class implements the \c IVirtualToolBarButton and \c _IVirtualToolBarButtonEvents
	/// interfaces.
	///
	/// \sa IVirtualToolBarButton, _IVirtualToolBarButtonEvents, ToolBar, ToolBarButton
	[
		uuid(ACF745F4-DFD6-4115-A1B6-F1DFF1C45C78),
		version(1.0),
		noncreatable,
		helpstring("VirtualToolBarButton Class 1.0 (ANSI)")
	]
	coclass VirtualToolBarButton
	{
		[default] interface IVirtualToolBarButton;
		[default, source] dispinterface _IVirtualToolBarButtonEvents;
	};


	/// \interface IToolBarButton
	/// \brief <em>Wraps an existing tool bar button</em>
	///
	/// This interface is a wrapper around a button that - unlike a button wrapped by
	/// \c IVirtualToolBarButton - really exists within the control.
	///
	/// \sa _IToolBarButtonEvents, IVirtualToolBarButton, IToolBarButtons, IToolBarButtonContainer, IToolBar,
	///     _IToolBarEvents
	[
		object,
		uuid(A9B66FE1-51BE-461a-A45B-C7F7DFDF5B4F),
		dual,
		nonextensible,
		helpstring("IToolBarButton interface"),
		pointer_default(unique)
	]
	interface IToolBarButton : IDispatch
	{
		/// \brief <em>Specifies whether the button's width is adjusted automatically</em>
		///
		/// Retrieves or sets whether the button's width is adjusted automatically depending on its text and
		/// icon. If set to \c True, the button's width is adjusted automatically; otherwise not.
		///
		/// \sa Width, Text, IconIndex
		[propget, id(DISPID_TBB_AUTOSIZE), helpstring("Retrieves or sets whether the button's width is adjusted automatically depending on its text and icon.")]
		HRESULT AutoSize([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_AUTOSIZE), helpstring("Retrieves or sets whether the button's width is adjusted automatically depending on its text and icon.")]
		HRESULT AutoSize([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the button's associated data</em>
		///
		/// Retrieves or sets the \c Long value associated with the button. Use this property to associate
		/// any data with the button.
		///
		/// \sa _IToolBarEvents::FreeButtonData
		[propget, id(DISPID_TBB_BUTTONDATA), helpstring("Retrieves or sets the Long value associated with the button.")]
		HRESULT ButtonData([out, retval] LONG* pValue);
		[propput, id(DISPID_TBB_BUTTONDATA), helpstring("Retrieves or sets the Long value associated with the button.")]
		HRESULT ButtonData([in] LONG newValue);
		/// \brief <em>Controls the button's appearance and behavior</em>
		///
		/// Retrieves or sets which kind of button this button is. Any of the values defined by the
		/// \c ButtonTypeConstants enumeration is valid.
		///
		/// \sa PartOfGroup, ButtonTypeConstants
		[propget, id(DISPID_TBB_BUTTONTYPE), helpstring("Retrieves or sets which kind of button this button is.")]
		HRESULT ButtonType([out, retval] ButtonTypeConstants* pValue);
		[propput, id(DISPID_TBB_BUTTONTYPE), helpstring("Retrieves or sets which kind of button this button is.")]
		HRESULT ButtonType([in] ButtonTypeConstants newValue);
		/// \brief <em>Specifies whether the button's text is displayed</em>
		///
		/// Retrieves or sets whether the button's text is displayed. If set to \c True, the button's text is
		/// displayed next to the icon; otherwise it is not displayed next to the icon, but as tool tip if the
		/// mouse cursor is moved over the button.
		///
		/// \remarks This property is ignored, if the \c IToolBar::ButtonTextPosition property is not set to
		///          \c btpRightToIcon or the \c IToolBar::AlwaysDisplayButtonText property is set to \c True.
		///
		/// \sa Text, IToolBar::AlwaysDisplayButtonText, IToolBar::ButtonTextPosition
		[propget, id(DISPID_TBB_DISPLAYTEXT), helpstring("Retrieves or sets whether the button's text is displayed.")]
		HRESULT DisplayText([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_DISPLAYTEXT), helpstring("Retrieves or sets whether the button's text is displayed.")]
		HRESULT DisplayText([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the button's appearance and behavior</em>
		///
		/// Retrieves or sets whether the button is a drop-down button and how the drop-down arrow is
		/// displayed. Any of the values defined by the \c DropDownStyleConstants enumeration is valid.
		///
		/// \sa IToolBar::NormalDropDownButtonStyle, DroppedDown, DropDownStyleConstants
		[propget, id(DISPID_TBB_DROPDOWNSTYLE), helpstring("Retrieves or sets whether the button is a drop-down button and how the drop-down arrow is displayed.")]
		HRESULT DropDownStyle([out, retval] DropDownStyleConstants* pValue);
		[propput, id(DISPID_TBB_DROPDOWNSTYLE), helpstring("Retrieves or sets whether the button is a drop-down button and how the drop-down arrow is displayed.")]
		HRESULT DropDownStyle([in] DropDownStyleConstants newValue);
		/// \brief <em>Specifies whether the button is currently dropped down</em>
		///
		/// Retrieves whether the button is currently dropped down. If this property is set to \c True, the
		/// button is currently dropped down; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa DropDownStyle
		[propget, id(DISPID_TBB_DROPPEDDOWN), helpstring("Retrieves whether the button is currently dropped down.")]
		HRESULT DroppedDown([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Controls whether the button accepts user input</em>
		///
		/// Enables or disables the button for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		///
		/// \sa IToolBar::CommandEnabled, IToolBar::Enabled
		[propget, id(DISPID_TBB_ENABLED), helpstring("Enables or disables the button for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_ENABLED), helpstring("Enables or disables the button for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the next button after this one is placed on a new line</em>
		///
		/// Retrieves or sets whether the next button after this one is placed on a new line. If set to
		/// \c True, the next button is placed on a new line; otherwise not.
		///
		/// \sa IToolBar::WrapButtons
		[propget, id(DISPID_TBB_FOLLOWEDBYLINEBREAK), helpstring("Retrieves or sets whether the next button after this one is placed on a new line.")]
		HRESULT FollowedByLineBreak([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_FOLLOWEDBYLINEBREAK), helpstring("Retrieves or sets whether the next button after this one is placed on a new line.")]
		HRESULT FollowedByLineBreak([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves whether the button is the control's hot button</em>
		///
		/// Retrieves whether the button is the control's hot button. The hot button is the button under the
		/// mouse cursor. If it is the hot button, this property is set to \c True; otherwise it's set to
		/// \c False.
		///
		/// \remarks This property is read-only.
		///
		/// \sa Pushed, Marked, IToolBar::HotButton
		[propget, id(DISPID_TBB_HOT), helpstring("Retrieves whether the button is the control's hot button. The hot button is the button under the mouse cursor.")]
		HRESULT Hot([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies the button's icon</em>
		///
		/// Retrieves or sets the zero-based index of the button's icon in the control's image lists. If set
		/// to -1, the control will fire the \c ButtonGetDisplayInfo event each time this property's value is
		/// required. If set to -2, no icon is displayed for this button.
		///
		/// \sa ImageListIndex, IToolBar::hImageList, _IToolBarEvents::ButtonGetDisplayInfo, ImageListConstants
		[propget, id(DISPID_TBB_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the button's icon in the control's image lists. If set to -1, the control will fire the 'ButtonGetDisplayInfo' event each time this property's value is required. If set to -2, no icon is displayed for this button.")]
		HRESULT IconIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_TBB_ICONINDEX), helpstring("Retrieves or sets the zero-based index of the button's icon in the control's image lists. If set to -1, the control will fire the 'ButtonGetDisplayInfo' event each time this property's value is required. If set to -2, no icon is displayed for this button.")]
		HRESULT IconIndex([in] LONG newValue);
		/// \brief <em>Specifies the button's ID</em>
		///
		/// Retrieves or sets an unique ID identifying this tool bar button.
		///
		/// \remarks This is the default property of the \c IToolBarButton interface.
		///
		/// \sa Index, ButtonIdentifierTypeConstants
		[propget, id(DISPID_TBB_ID), helpstring("Retrieves or sets the tool bar button's unique ID.")]
		HRESULT ID([out, retval] LONG* pValue);
		[propput, id(DISPID_TBB_ID), helpstring("Retrieves or sets the tool bar button's unique ID.")]
		HRESULT ID([in] LONG newValue);
		/// \brief <em>Specifies the button's image list</em>
		///
		/// Retrieves or sets the zero-based index of the control's image lists that the button's icons will be
		/// taken from. If set to -1, the control will fire the \c ButtonGetDisplayInfo event each time this
		/// property's value is required.
		///
		/// \sa IconIndex, IToolBar::hImageList, _IToolBarEvents::ButtonGetDisplayInfo, ImageListConstants
		[propget, id(DISPID_TBB_IMAGELISTINDEX), helpstring("Retrieves or sets the zero-based index of the control's image lists that the button's icons will be taken from. If set to -1, the control will fire the 'ButtonGetDisplayInfo' event each time this property's value is required.")]
		HRESULT ImageListIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_TBB_IMAGELISTINDEX), helpstring("Retrieves or sets the zero-based index of the control's image lists that the button's icons will be taken from. If set to -1, the control will fire the 'ButtonGetDisplayInfo' event each time this property's value is required.")]
		HRESULT ImageListIndex([in] LONG newValue);
		/// \brief <em>Specifies the button's zero-based index</em>
		///
		/// Retrieves or sets the zero-based index identifying this tool bar button. Setting this property
		/// moves the button.
		///
		/// \remarks Although adding or removing buttons changes other buttons' indexes, the index is the best
		///          (and fastest) option to identify a button.
		///
		/// \sa ID, ButtonIdentifierTypeConstants
		[propget, id(DISPID_TBB_INDEX), helpstring("Retrieves or sets the zero-based index identifying this tool bar button. Setting this property moves the button.")]
		HRESULT Index([out, retval] LONG* pValue);
		[propput, id(DISPID_TBB_INDEX), helpstring("Retrieves or sets the zero-based index identifying this tool bar button. Setting this property moves the button.")]
		HRESULT Index([in] LONG newValue);
		/// \brief <em>Specifies whether the button is tagged as "Marked"</em>
		///
		/// Retrieves or sets whether the button is tagged as "Marked". It's up to the application how marked
		/// buttons are interpreted. If set to \c True, the button is tagged as "Marked"; otherwise not.
		///
		/// \sa Hot, SelectionState
		[propget, id(DISPID_TBB_MARKED), helpstring("Retrieves or sets whether the button is tagged as ""Marked"". It's up to the application how marked buttons are interpreted.")]
		HRESULT Marked([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_MARKED), helpstring("Retrieves or sets whether the button is tagged as ""Marked"". It's up to the application how marked buttons are interpreted.")]
		HRESULT Marked([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the button is a member of the chevron popup tool bar control</em>
		///
		/// Retrieves whether the button is a part of the chevron popup tool bar control. If this property is
		/// set to \c True, the button is a part of the chevron popup tool bar control; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ShouldBeDisplayedInChevronPopup, IToolBar::DisplayChevronPopupWindow
		[propget, id(DISPID_TBB_PARTOFCHEVRONTOOLBAR), helpstring("Retrieves whether the button is a part of the chevron popup tool bar control.")]
		HRESULT PartOfChevronToolBar([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies whether the button is part of a button group</em>
		///
		/// Retrieves or sets whether the button is part of a button group. If set to \c True, it is part of a
		/// group; otherwise not.\n
		/// Among all consecutive buttons that are part of a group, only one button can be checked. A check
		/// button that is part of a group cannot be unchecked by simply clicking it a second time. This can be
		/// used to create option-button like behavior.
		///
		/// \sa ButtonType, SelectionState
		[propget, id(DISPID_TBB_PARTOFGROUP), helpstring("Retrieves or sets whether the button is part of a button group.")]
		HRESULT PartOfGroup([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_PARTOFGROUP), helpstring("Retrieves or sets whether the button is part of a button group.")]
		HRESULT PartOfGroup([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the button is drawn like being pushed</em>
		///
		/// Retrieves or sets whether the button is drawn like being pushed. If set to \c True, it is drawn
		/// like being pushed; otherwise not.
		///
		/// \sa Hot, SelectionState
		[propget, id(DISPID_TBB_PUSHED), helpstring("Retrieves or sets whether the button is drawn like being pushed.")]
		HRESULT Pushed([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_PUSHED), helpstring("Retrieves or sets whether the button is drawn like being pushed.")]
		HRESULT Pushed([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the state of the button if it is a check button</em>
		///
		/// Retrieves or sets the state of check buttons. Any of the values defined by the
		/// \c SelectionStateConstants enumeration is valid.
		///
		/// \sa ButtonType, Pushed, SelectionStateConstants
		// \sa ButtonType, Pushed, SelectionStateConstants, _IToolBarEvents::ButtonSelectionStateChanged
		[propget, id(DISPID_TBB_SELECTIONSTATE), helpstring("Retrieves or sets the state of check buttons.")]
		HRESULT SelectionState([out, retval] SelectionStateConstants* pValue);
		[propput, id(DISPID_TBB_SELECTIONSTATE), helpstring("Retrieves or sets the state of check buttons.")]
		HRESULT SelectionState([in] SelectionStateConstants newValue);
		/// \brief <em>Specifies whether the button should be displayed in the chevron popup window</em>
		///
		/// Retrieves whether the button should be displayed in the chevron popup window. If this property is
		/// set to \c True, the button should be displayed in the chevron popup window; otherwise not.
		///
		/// \remarks This property is read-only.
		///
		/// \sa PartOfChevronToolBar, IToolBar::DisplayChevronPopupWindow
		[propget, id(DISPID_TBB_SHOULDBEDISPLAYEDINCHEVRONPOPUP), helpstring("Retrieves whether the button should be displayed in the chevron popup window.")]
		HRESULT ShouldBeDisplayedInChevronPopup([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies whether the button's text is cut off</em>
		///
		/// Retrieves or sets whether the button's text is cut off. If set to \c True, the text is cut off and
		/// an ellipsis is displayed; otherwise not.
		///
		/// \sa Text
		[propget, id(DISPID_TBB_SHOWINGELLIPSIS), helpstring("Retrieves or sets whether the button's text is cut off.")]
		HRESULT ShowingEllipsis([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_SHOWINGELLIPSIS), helpstring("Retrieves or sets whether the button's text is cut off.")]
		HRESULT ShowingEllipsis([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the button's text</em>
		///
		/// Retrieves or sets the button's text.
		///
		/// \sa DisplayText, IconIndex, UseMnemonic, ShowingEllipsis
		[propget, id(DISPID_TBB_TEXT), helpstring("Retrieves or sets the button's text.")]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_TBB_TEXT), helpstring("Retrieves or sets the button's text.")]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Specifies whether the button has an accelerator prefix associated with it</em>
		///
		/// Retrieves or sets whether the button has an accelerator prefix associated with it. If set to
		/// \c True, the first character of the button's text that is prefixed by an ampersand (&amp;), is used
		/// as the button's accelerator prefix and this character is underlined. If set to \c False, ampersands
		/// in the button's text are interpreted as normal text.
		///
		/// \sa Text
		[propget, id(DISPID_TBB_USEMNEMONIC), helpstring("Retrieves or sets whether the button has an accelerator prefix associated with it.")]
		HRESULT UseMnemonic([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_USEMNEMONIC), helpstring("Retrieves or sets whether the button has an accelerator prefix associated with it.")]
		HRESULT UseMnemonic([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the button is visible</em>
		///
		/// Retrieves or sets whether the button is visible. If set to \c True, the button will be displayed;
		/// otherwise not.
		///
		/// \sa IToolBarButtons::Remove, IToolBarButtons::Add
		[propget, id(DISPID_TBB_VISIBLE), helpstring("Retrieves or sets whether the button is visible.")]
		HRESULT Visible([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBB_VISIBLE), helpstring("Retrieves or sets whether the button is visible.")]
		HRESULT Visible([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the button's current width</em>
		///
		/// Retrieves or sets the button's current width in pixels.
		///
		/// \sa AutoSize
		[propget, id(DISPID_TBB_WIDTH), helpstring("Retrieves or sets the button's current width in pixels.")]
		HRESULT Width([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TBB_WIDTH), helpstring("Retrieves or sets the button's current width in pixels.")]
		HRESULT Width([in] OLE_XSIZE_PIXELS newValue);

		/// \brief <em>Retrieves the window contained in the placeholder button</em>
		///
		/// Retrieves the handle of the window that is displayed at the position of the button if the button is
		/// a placeholder button.
		///
		/// \param[out] horizontalAlignment The horizontal alignment of the window inside the placeholder
		///             button's rectangle. Any of the values defined by the \c HAlignmentConstants enumeration
		///             is valid.
		/// \param[out] verticalAlignment The vertical alignment of the window inside the placeholder button's
		///             rectangle. Any of the values defined by the \c VAlignmentConstants enumeration is
		///             valid.
		///
		/// \return The handle of the window that is displayed at the position of the placeholder button.
		///
		/// \sa SetContainedWindow, ButtonType, HAlignmentConstants, VAlignmentConstants
		[id(DISPID_TBB_GETCONTAINEDWINDOW), helpstring("Retrieves the handle of the window that is displayed at the position of the button if the button is a placeholder button.")]
		HRESULT GetContainedWindow([in, out, defaultvalue(0)] HAlignmentConstants* horizontalAlignment, [in, out, defaultvalue(0)] VAlignmentConstants* verticalAlignment, [out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the bounding rectangle of either the button or a part of it</em>
		///
		/// Retrieves the bounding rectangle (in pixels relative to the control's client area) of either the
		/// button or a part of it.
		///
		/// \param[in] rectangleType The rectangle to retrieve. Any of the values defined by the
		///            \c ButtonRectangleTypeConstants enumeration is valid.
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
		///             relative to the control's upper-left corner.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
		///             relative to the control's upper-left corner.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
		///             relative to the control's upper-left corner.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
		///             relative to the control's upper-left corner.
		///
		/// \sa ButtonRectangleTypeConstants
		[id(DISPID_TBB_GETRECTANGLE), helpstring("Retrieves the bounding rectangle (in pixels relative to the control's client area) of either the button or a part of it.")]
		HRESULT GetRectangle(ButtonRectangleTypeConstants rectangleType, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
		/// \brief <em>Sets the window contained in the placeholder button</em>
		///
		/// Sets the handle of the window that is displayed at the position of the button if the button is a
		/// placeholder button.
		///
		/// \param[in] hWnd The handle of the window that is positioned at the position of the placeholder
		///            button.
		/// \param[in] horizontalAlignment The horizontal alignment of the window inside the placeholder
		///            button's rectangle. Any of the values defined by the \c HAlignmentConstants enumeration
		///            is valid.
		/// \param[in] verticalAlignment The vertical alignment of the window inside the placeholder button's
		///            rectangle. Any of the values defined by the \c VAlignmentConstants enumeration is valid.
		///
		/// \sa GetContainedWindow, ButtonType, HAlignmentConstants, VAlignmentConstants
		[id(DISPID_TBB_SETCONTAINEDWINDOW), helpstring("Sets the handle of the window that is displayed at the position of the button if the button is a placeholder button.")]
		HRESULT SetContainedWindow([in] OLE_HANDLE hWnd, [in, defaultvalue(halCenter)] HAlignmentConstants horizontalAlignment, [in, defaultvalue(valCenter)] VAlignmentConstants verticalAlignment);
	}


	/// \interface _IToolBarButtonEvents
	/// \brief <em>The \c ToolBarButton class' events interface</em>
	///
	/// This interface defines all events the \c ToolBarButton class may raise.
	///
	/// \sa IToolBarButton
	[
		uuid(7C498735-7CEA-4c19-8E54-3D548E5C5D8A),
		helpstring("IToolBarButton-event-interface")
	]
	dispinterface _IToolBarButtonEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ToolBarButton class</em>
	///
	/// This COM class implements the \c IToolBarButton and \c _IToolBarButtonEvents interfaces.
	///
	/// \sa IToolBarButton, _IToolBarButtonEvents, ToolBar, ToolBarButtons
	[
		uuid(0FBE707B-D5D9-4fad-AA44-AF70DD9FE7BD),
		version(1.3),
		noncreatable,
		helpstring("ToolBarButton Class 1.3 (ANSI)")
	]
	coclass ToolBarButton
	{
		[default] interface IToolBarButton;
		[default, source] dispinterface _IToolBarButtonEvents;
	};


	/// \interface IToolBarButtons
	/// \brief <em>Manages a collection of \c ToolBarButton objects</em>
	///
	/// This interface provides easy access (including filtering) to collections of \c ToolBarButton objects.
	/// While a \c ToolBarButtonContainer object is used to group any tool bar buttons and acts more like a
	/// clipboard, a \c ToolBarButtons object is used to group buttons that have certain properties in
	/// common.
	///
	/// \sa _IToolBarButtonsEvents, IToolBarButton, IToolBarButtonContainer, IToolBar
	[
		object,
		uuid(064B16AC-7ED1-42e4-B09B-89D2E0F97FCF),
		dual,
		nonextensible,
		helpstring("IToolBarButtons interface"),
		pointer_default(unique)
	]
	interface IToolBarButtons : IDispatch
	{
		/// \brief <em>Specifies whether filters for string properties are case sensitive</em>
		///
		/// Retrieves or sets whether string comparisons, that are done when applying the filters on a button,
		/// are case sensitive. If this property is set to \c True, string comparisons are case sensitive;
		/// otherwise not.
		///
		/// \sa Filter, ComparisonFunction
		[propget, id(DISPID_TBBS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on a button, are case sensitive.")]
		HRESULT CaseSensitiveFilters([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBBS_CASESENSITIVEFILTERS), helpstring("Retrieves or sets whether string comparisons, that are done when applying the filters on a button, are case sensitive.")]
		HRESULT CaseSensitiveFilters([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies a filter's comparison function</em>
		///
		/// Retrieves or sets a button filter's comparison function. This property takes the address of a
		/// function having the following signature:\n
		/// \code
		///   IsEqual(ByVal bandProperty As T, ByVal pattern As T) As Long
		/// \endcode
		/// where T stands for the filtered property's type (\c Boolean, \c Long or \c String). This function
		/// must compare its arguments and return a non-zero value if the arguments are equal and zero
		/// otherwise.\n
		/// If this property is set to 0, the control compares the values itself using the "=" operator
		/// (\c lstrcmp and \c lstrcmpi for string filters).
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, CaseSensitiveFilters, FilteredPropertyConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647488.aspx">lstrcmp</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms647489.aspx">lstrcmpi</a>
		[propget, id(DISPID_TBBS_COMPARISONFUNCTION), helpstring("Retrieves or sets a button filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [out, retval] LONG* pValue);
		[propput, id(DISPID_TBBS_COMPARISONFUNCTION), helpstring("Retrieves or sets a button filter's comparison function.")]
		HRESULT ComparisonFunction([in] FilteredPropertyConstants filteredProperty, [in] LONG newValue);
		/// \brief <em>Specifies a filter for a property</em>
		///
		/// Retrieves or sets a button filter.\n
		/// An \c IToolBarButtons collection can be filtered by any of \c IToolBarButton's properties, that the
		/// \c FilteredPropertyConstants enumeration defines a constant for. Combinations of multiple filters
		/// are possible, too. A filter is a \c Variant containing an array whose elements are of type
		/// \c Variant. Each element of this array contains a valid value for the property, that the filter
		/// refers to.\n
		/// When applying the filter, the elements of the array are connected using the logical Or operator.\n\n
		/// Setting this property to \c Empty or any other value, that doesn't match the described structure,
		/// deactivates the filter.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa FilterType, ComparisonFunction, FilteredPropertyConstants
		[propget, id(DISPID_TBBS_FILTER), helpstring("Retrieves or sets a button filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [out, retval] VARIANT* pValue);
		[propput, id(DISPID_TBBS_FILTER), helpstring("Retrieves or sets a button filter.")]
		HRESULT Filter([in] FilteredPropertyConstants filteredProperty, [in] VARIANT newValue);
		/// \brief <em>Specifies a filter's type</em>
		///
		/// Retrieves or sets a button filter's type.
		///
		/// \param[in] filteredProperty A value specifying the property that the filter refers to. Any of the
		///            values defined by the \c FilteredPropertyConstants enumeration is valid.
		///
		/// \sa Filter, FilteredPropertyConstants, FilterTypeConstants
		[propget, id(DISPID_TBBS_FILTERTYPE), helpstring("Retrieves or sets a button filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [out, retval] FilterTypeConstants* pValue);
		[propput, id(DISPID_TBBS_FILTERTYPE), helpstring("Retrieves or sets a button filter's type.")]
		HRESULT FilterType([in] FilteredPropertyConstants filteredProperty, [in] FilterTypeConstants newValue);
		/// \brief <em>Retrieves a \c ToolBarButton object from the collection</em>
		///
		/// Retrieves a \c ToolBarButton object from the collection that wraps the tool bar button identified
		/// by \c buttonIdentifier.
		///
		/// \param[in] buttonIdentifier A value that identifies the tool bar button to be retrieved.
		/// \param[in] buttonIdentifierType A value specifying the meaning of \c buttonIdentifier. Any of the
		///            values defined by the \c ButtonIdentifierTypeConstants enumeration is valid.
		/// \param[in] getChevronToolBarButton If \c True, the retrieved button will refer to the chevron popup
		///            tool bar control.
		///
		/// \remarks This is the default property of the \c IToolBarButtons interface.\n
		///          This property is read-only.
		///
		/// \sa IToolBarButton, ButtonIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_TBBS_ITEM), helpstring("Retrieves a 'ToolBarButton' object from the collection that wraps the tool bar button identified by 'buttonIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG buttonIdentifier, [in, defaultvalue(btitIndex)] ButtonIdentifierTypeConstants buttonIdentifierType, [in, defaultvalue(0)] VARIANT_BOOL getChevronToolBarButton, [out, retval] IToolBarButton** ppButton);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c ToolBarButton objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_TBBS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds a button to the tool bar control</em>
		///
		/// Adds a button with the specified properties at the specified position in the control and returns a
		/// \c ToolBarButton object wrapping the inserted button.
		///
		/// \param[in] ID A unique ID identifying the new button. Actually button IDs do not need to be unique,
		///            but it is strongly recommended that they are.
		/// \param[in] insertAt The new button's zero-based index. If set to -1, the button will be inserted
		///            as the last button.
		/// \param[in] iconIndex The zero-based index of the new button's icon in the control's image lists.
		///            If set to -1, the control will fire the \c ButtonGetDisplayInfo event each time this
		///            property's value is required. If set to -2, no icon is displayed for this button.
		/// \param[in] imageListIndex The zero-based index of the control's image lists that the button's icons
		///            will be taken from. If set to -1, the control will fire the \c ButtonGetDisplayInfo
		///            event each time this property's value is required.
		/// \param[in] text The new button's text.
		/// \param[in] displayText If set to \c True, the new button's text is displayed next to its icon;
		///            otherwise it is displayed as tool tip.
		/// \param[in] useMnemonic If set to \c True, the first character of the new button's text that is
		///            prefixed by an ampersand (&amp;), is used as the button's accelerator prefix and this
		///            character is underlined. If set to \c False, ampersands in the button's text are
		///            interpreted as normal text.
		/// \param[in] buttonType Specifies which kind of button the new button is. Any of the values defined
		///            by the \c ButtonTypeConstants enumeration is valid.
		/// \param[in] partOfGroup If set to \c True, the new button is part of a button group; otherwise
		///            not.\n
		///            Among all consecutive buttons that are part of a group, only one button can be checked.
		///            A check button that is part of a group cannot be unchecked by simply clicking it a
		///            second time. This can be used to create option-button like behavior.
		/// \param[in] selectionState Specifies the state of the new button if it is a check button. Any of
		///            the values defined by the \c SelectionStateConstants enumeration is valid.
		/// \param[in] dropDownStyle Specifies whether the new button is a drop-down button and how the
		///            drop-down arrow is displayed. Any of the values defined by the \c DropDownStyleConstants
		///            enumeration is valid.
		/// \param[in] buttonData A \c Long value that will be associated with the new button.
		/// \param[in] visible If set to \c True, the new button is made visible; otherwise not.
		/// \param[in] enabled If set to \c True, the new button reacts to user input; otherwise not.
		/// \param[in] autoSize If set to \c True, the new button's width is adjusted automatically depending
		///            on its text and icon; otherwise not.
		/// \param[in] width The new button's width in pixels.
		/// \param[in] followedByLineBreak If set to \c True, the next button after the new button is placed on
		///            a new line; otherwise not.
		/// \param[in] showingEllipsis If set to \c True, the new button's text is cut off and an ellipsis is
		///            displayed; otherwise not.
		/// \param[in] marked If set to \c True, the new button is tagged as "Marked"; otherwise not. It's up
		///            to the application how marked buttons are interpreted.
		///
		/// \return The inserted button.
		///
		/// \remarks The parameter \c displayText is ignored, if the \c IToolBar::ButtonTextPosition property
		///          is not set to \c btpRightToIcon or the \c IToolBar::AlwaysDisplayButtonText property is
		///          set to \c True.\n
		///          When inserting a separator, the \c autoSize parameter should be set to \c False.\n
		///          For placeholder buttons (buttons of type \c btyPlaceholder), only the following parameters
		///          are used:
		///          - \c id
		///          - \c insertAt
		///          - \c buttonType
		///          - \c partOfGroup
		///          - \c buttonData
		///          - \c visible
		///          - \c width
		///          - \c followedByLineBreak
		///
		/// \sa Count, Remove, RemoveAll, IToolBarButton::ID, IToolBarButton::IconIndex,
		///     IToolBarButton::ImageListIndex, IToolBarButton::Text, IToolBarButton::DisplayText,
		///     IToolBarButton::UseMnemonic, IToolBarButton::ButtonType, IToolBarButton::PartOfGroup,
		///     IToolBarButton::SelectionState, IToolBarButton::DropDownStyle, IToolBarButton::ButtonData,
		///     IToolBarButton::Visible, IToolBarButton::Enabled, IToolBarButton::AutoSize,
		///     IToolBarButton::Width, IToolBarButton::FollowedByLineBreak, IToolBarButton::ShowingEllipsis,
		///     IToolBarButton::Marked, ButtonTypeConstants, SelectionStateConstants, DropDownStyleConstants
		[id(DISPID_TBBS_ADD), helpstring("Adds a new tool bar button with the specified properties.")]
		HRESULT Add([in] LONG ID, [in, defaultvalue(-1)] LONG insertAt, [in, defaultvalue(-2)] LONG IconIndex, [in, defaultvalue(0)] LONG ImageListIndex, [in, defaultvalue("")] BSTR Text, [in, defaultvalue(0)] VARIANT_BOOL DisplayText, [in, defaultvalue(-1)] VARIANT_BOOL UseMnemonic, [in, defaultvalue(btyCommandButton)] ButtonTypeConstants ButtonType, [in, defaultvalue(0)] VARIANT_BOOL PartOfGroup, [in, defaultvalue(ssUnchecked)] SelectionStateConstants SelectionState, [in, defaultvalue(ddstNoDropDown)] DropDownStyleConstants DropDownStyle, [in, defaultvalue(0)] LONG ButtonData, [in, defaultvalue(-1)] VARIANT_BOOL Visible, [in, defaultvalue(-1)] VARIANT_BOOL Enabled, [in, defaultvalue(-1)] VARIANT_BOOL AutoSize, [in, defaultvalue(-1)] OLE_XSIZE_PIXELS Width, [in, defaultvalue(0)] VARIANT_BOOL FollowedByLineBreak, [in, defaultvalue(0)] VARIANT_BOOL ShowingEllipsis, [in, defaultvalue(0)] VARIANT_BOOL Marked, [out, retval] IToolBarButton** ppAddedButton);
		/// \brief <em>Retrieves whether the specified button is part of the button collection</em>
		///
		/// \param[in] buttonIdentifier A value that identifies the button to be checked.
		/// \param[in] buttonIdentifierType A value specifying the meaning of \c buttonIdentifier. Any of the
		///            values defined by the \c ButtonIdentifierTypeConstants enumeration is valid.
		/// \param[in] checkChevronToolBarButton If \c True, the method will check the chevron popup tool bar
		///            control.
		///
		/// \return \c True, if the specified button is part of the collection; otherwise \c False.
		///
		/// \sa Filter, Add, Remove, ButtonIdentifierTypeConstants
		[id(DISPID_TBBS_CONTAINS), helpstring("Retrieves whether the specified button is part of the button collection.")]
		HRESULT Contains([in] LONG buttonIdentifier, [in, defaultvalue(btitIndex)] ButtonIdentifierTypeConstants buttonIdentifierType, [in, defaultvalue(0)] VARIANT_BOOL checkChevronToolBarButton, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the buttons in the collection</em>
		///
		/// Retrieves the number of \c ToolBarButton objects in the collection.
		///
		/// \param[in] countChevronToolBarButtons If \c True, the method will count the buttons of the chevron
		///            popup tool bar control.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_TBBS_COUNT), helpstring("Retrieves the number of 'ToolBarButton' objects in the collection.")]
		HRESULT Count([in, defaultvalue(0)] VARIANT_BOOL countChevronToolBarButtons, [out, retval] LONG* pValue);
		/// \brief <em>Removes the specified button in the collection from the tool bar</em>
		///
		/// \param[in] buttonIdentifier A value that identifies the tool bar button to be removed.
		/// \param[in] buttonIdentifierType A value specifying the meaning of \c buttonIdentifier. Any of the
		///            values defined by the \c ButtonIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Add, Count, RemoveAll, Contains, ButtonIdentifierTypeConstants
		[id(DISPID_TBBS_REMOVE), helpstring("Removes the specified button in the collection from the control.")]
		HRESULT Remove([in] LONG buttonIdentifier, [in, defaultvalue(btitIndex)] ButtonIdentifierTypeConstants buttonIdentifierType);
		/// \brief <em>Removes all buttons in the collection from the tool bar</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_TBBS_REMOVEALL), helpstring("Removes all buttons in the collection from the control.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IToolBarButtonsEvents
	/// \brief <em>The \c ToolBarButtons class' events interface</em>
	///
	/// This interface defines all events the \c ToolBarButtons class may raise.
	///
	/// \sa IToolBarButtons
	[
		uuid(F6FC4F52-FB67-48d2-97B5-94A3B9C5B474),
		helpstring("IToolBarButtons-event-interface")
	]
	dispinterface _IToolBarButtonsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ToolBarButtons class</em>
	///
	/// This COM class implements the \c IToolBarButtons and \c _IToolBarButtonsEvents interfaces.
	///
	/// \sa IToolBarButtons, _IToolBarButtonsEvents, ToolBar, ToolBarButton
	[
		uuid(0C8B46A4-9969-4e26-9E36-E90900F4E7A1),
		version(1.3),
		noncreatable,
		helpstring("ToolBarButtons Class 1.3 (ANSI)")
	]
	coclass ToolBarButtons
	{
		[default] interface IToolBarButtons;
		[default, source] dispinterface _IToolBarButtonsEvents;
	};


	/// \interface IToolBarButtonContainer
	/// \brief <em>Manages a collection of \c ToolBarButton objects</em>
	///
	/// This interface provides easy access to collections of \c ToolBarButton objects. While a
	/// \c ToolBarButtons object is used to group buttons that have certain properties in common, a
	/// \c ToolBarButtonContainer object is used to group any buttons and acts more like a clipboard.
	///
	/// \sa _IToolBarButtonContainerEvents, IToolBarButton, IToolBarButtons, IToolBar
	[
		object,
		uuid(33137B46-6112-485D-AB1F-BEDB3C243EA9),
		dual,
		nonextensible,
		helpstring("IToolBarButtonContainer interface"),
		pointer_default(unique)
	]
	interface IToolBarButtonContainer : IDispatch
	{
		/// \brief <em>Retrieves a \c ToolBarButton object from the collection</em>
		///
		/// Retrieves a \c ToolBarButton object from the collection that wraps the tool bar button identified
		/// by \c buttonID.
		///
		/// \param[in] buttonID The unique ID of the button to retrieve.
		///
		/// \remarks This is the default property of the \c IToolBarButtonContainer interface.\n
		///          This property is read-only.
		///
		/// \sa IToolBarButton::ID, Add, Remove
		[propget, id(DISPID_TBBC_ITEM), helpstring("Retrieves a 'ToolBarButton' object from the collection that wraps the tool bar button identified by 'buttonID'."), nonbrowsable]
		HRESULT Item([in] LONG buttonID, [out, retval] IToolBarButton** ppButton);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c ToolBarButton objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_TBBC__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds the specified button(s) to the collection</em>
		///
		/// \param[in] buttons The button(s) to add. May be either a tool bar button ID, a \c ToolBarButton
		///            object or a \c ToolBarButtons collection.
		///
		/// \sa IToolBarButton::ID, Count, Remove, RemoveAll
		[id(DISPID_TBBC_ADD), helpstring("Adds the specified button(s) to the collection.")]
		HRESULT Add([in] VARIANT Buttons);
		/// \brief <em>Clones the collection object</em>
		///
		/// Retrieves an exact copy of the collection.
		///
		/// \return The cloned object.
		///
		/// \sa IToolBar::CreateButtonContainer
		[id(DISPID_TBBC_CLONE), helpstring("Creates an exact copy of the collection.")]
		HRESULT Clone([out, retval] IToolBarButtonContainer** ppClone);
		/// \brief <em>Counts the buttons in the collection</em>
		///
		/// Retrieves the number of \c ToolBarButton objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_TBBC_COUNT), helpstring("Retrieves the number of 'ToolBarButton' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Retrieves an imagelist containing the buttons' common drag image</em>
		///
		/// Retrieves the handle to an imagelist containing a bitmap that can be used to visualize
		/// dragging of the tool bar buttons of this collection.
		///
		/// \param[out] xUpperLeft The x-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		/// \param[out] yUpperLeft The y-coordinate (in pixels) of the drag image's upper-left corner relative
		///             to the control's upper-left corner.
		///
		/// \return The handle to the imagelist containing the bitmap.
		///
		/// \remarks The caller is responsible for destroying the imagelist.
		[id(DISPID_TBBC_CREATEDRAGIMAGE), helpstring("Retrieves the handle to an imagelist containing a bitmap that can be used to visualize dragging of the tool bar buttons of this collection.")]
		HRESULT CreateDragImage([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xUpperLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yUpperLeft, [out, retval] OLE_HANDLE* phImageList);
		/// \brief <em>Removes the specified tool bar button from the collection</em>
		///
		/// \param[in] buttonID The unique ID of the button to remove.
		/// \param[in] removePhysically If \c True, the button is removed from the control, too.
		///
		/// \sa IToolBarButton::ID, Add, Count, RemoveAll
		[id(DISPID_TBBC_REMOVE), helpstring("Removes the specified tool bar button from the collection.")]
		HRESULT Remove([in] LONG buttonID, [in, defaultvalue(0)] VARIANT_BOOL removePhysically);
		/// \brief <em>Removes all tool bar buttons from the collection</em>
		///
		/// \param[in] removePhysically If \c True, the buttons are removed from the control, too.
		///
		/// \sa Add, Count, Remove
		[id(DISPID_TBBC_REMOVEALL), helpstring("Removes all tool bar buttons from the collection.")]
		HRESULT RemoveAll([in, defaultvalue(0)] VARIANT_BOOL removePhysically);
	}


	/// \interface _IToolBarButtonContainerEvents
	/// \brief <em>The \c ToolBarButtonContainer class' events interface</em>
	///
	/// This interface defines all events the \c ToolBarButtonContainer class may raise.
	///
	/// \sa IToolBarButtonContainer
	[
		uuid(23019FB7-9FAB-40E3-A6F7-DF71ECCEBFCC),
		helpstring("IToolBarButtonContainer-event-interface")
	]
	dispinterface _IToolBarButtonContainerEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c ToolBarButtonContainer class</em>
	///
	/// This COM class implements the \c IToolBarButtonContainer and \c _IToolBarButtonContainerEvents
	/// interfaces.
	///
	/// \sa IToolBarButtonContainer, _IToolBarButtonContainerEvents, ToolBar, ToolBarButton
	[
		uuid(136209FB-5EDD-4C3B-B6CB-D0619A93E219),
		version(1.3),
		noncreatable,
		helpstring("ToolBarButtonContainer Class 1.3 (ANSI)")
	]
	coclass ToolBarButtonContainer
	{
		[default] interface IToolBarButtonContainer;
		[default, source] dispinterface _IToolBarButtonContainerEvents;
	};


	/// \interface IToolBar
	/// \brief <em>The main interface</em>
	///
	/// This is the calendar control's main interface. It wraps the control window.
	///
	/// \sa _IToolBarEvents
	[
		object,
		uuid(994817E2-1E36-4fb1-9065-CBDE3ED19D9D),
		dual,
		nonextensible,
		helpstring("IToolBar interface"),
		pointer_default(unique)
	]
	interface IToolBar : IDispatch
	{
		/// \brief <em>Specifies whether the tool bar can be customized</em>
		///
		/// Retrieves or sets whether the control can be customized via comctl32's built-in customization
		/// features. If set to \c True, the built-in customization features are enabled; otherwise not.
		///
		/// \remarks The built-in customization features include a dialog for button management, that can be
		///          opened by double-clicking the control, and the capability to manage buttons using
		///          drag'n'drop.
		///
		/// \sa DragDropCustomizationModifierKey, Customize
		[propget, id(DISPID_TB_ALLOWCUSTOMIZATION), helpstring("Retrieves or sets whether the control can be customized via comctl32's built-in customization features.")]
		HRESULT AllowCustomization([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_ALLOWCUSTOMIZATION), helpstring("Retrieves or sets whether the control can be customized via comctl32's built-in customization features.")]
		HRESULT AllowCustomization([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether button texts are always displayed</em>
		///
		/// Retrieves or sets whether the visibility of button's texts can be set on a per-button basis. If set
		/// to \c True, the \c IToolBarButton::DisplayText property is ignored and button texts are always
		/// displayed; otherwise the visibility of the text depends on the setting of the
		/// \c IToolBarButton::DisplayText property.
		///
		/// \remarks This property is ignored, if the \c ButtonTextPosition is not set to \c btpRightToIcon.
		///
		/// \sa ButtonTextPosition, IToolBarButton::Text, IToolBarButton::DisplayText
		[propget, id(DISPID_TB_ALWAYSDISPLAYBUTTONTEXT), helpstring("Retrieves or sets whether the visibility of button's texts can be set on a per-button basis.")]
		HRESULT AlwaysDisplayButtonText([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_ALWAYSDISPLAYBUTTONTEXT), helpstring("Retrieves or sets whether the visibility of button's texts can be set on a per-button basis.")]
		HRESULT AlwaysDisplayButtonText([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the highlighting of buttons</em>
		///
		/// Retrieves or sets whether the highlighted button remains highlighted until another button is
		/// highlighted. If set to \c True, the highlighted button remains highlighted even if the mouse cursor
		/// is moved outside the control's client area. The button remains highligthed until another button is
		/// highlighted. If set to \c False, the highlighting is removed as soon as the mouse cursor leaves the
		/// button's bounding rectangle.
		///
		/// \sa HotButton
		[propget, id(DISPID_TB_ANCHORHIGHLIGHTING), helpstring("Retrieves or sets whether the highlighted button remains highlighted until another button is highlighted.")]
		HRESULT AnchorHighlighting([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_ANCHORHIGHLIGHTING), helpstring("Retrieves or sets whether the highlighted button remains highlighted until another button is highlighted.")]
		HRESULT AnchorHighlighting([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration is valid.
		///
		/// \sa BorderStyle, AppearanceConstants
		[propget, id(DISPID_TB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_TB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TB_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TB_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TB_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Specifies how the control's background is drawn</em>
		///
		/// Retrieves or sets how the control's background is drawn. Any of the values defined by the
		/// \c BackStyleConstants enumeration is valid.
		///
		/// \remarks The \c BackStyle property should be set to \c bksOpaque, if the \c Orientation property is
		///          set to \c oVertical and the control is not placed inside a rebar control.
		///
		/// \sa ButtonStyle, Orientation, BackStyleConstants
		[propget, id(DISPID_TB_BACKSTYLE), helpstring("Retrieves or sets how the control's background is drawn.")]
		HRESULT BackStyle([out, retval] BackStyleConstants* pValue);
		[propput, id(DISPID_TB_BACKSTYLE), helpstring("Retrieves or sets how the control's background is drawn.")]
		HRESULT BackStyle([in] BackStyleConstants newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, BorderStyleConstants
		[propget, id(DISPID_TB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_TB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TB_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Controls the buttons' height</em>
		///
		/// Retrieves or sets the height (in pixels) of a button. If set to 0, the system's default button
		/// height is used.
		///
		/// \sa ButtonWidth, IdealHeight
		[propget, id(DISPID_TB_BUTTONHEIGHT), helpstring("Retrieves or sets the height (in pixels) of a button. If set to 0, the system's default button height is used.")]
		HRESULT ButtonHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_BUTTONHEIGHT), helpstring("Retrieves or sets the height (in pixels) of a button. If set to 0, the system's default button height is used.")]
		HRESULT ButtonHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the number of rows used to display the tool bar buttons</em>
		///
		/// Retrieves the number of rows used to display the tool bar buttons.
		///
		/// \remarks This property is read-only.
		///
		/// \sa SetButtonRowCount, WrapButtons
		[propget, id(DISPID_TB_BUTTONROWCOUNT), helpstring("Retrieves the number of rows used to display the tool bar buttons."), nonbrowsable]
		HRESULT ButtonRowCount([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the control's buttons</em>
		///
		/// Retrieves a collection object wrapping the tool bar buttons.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IToolBarButtons
		[propget, id(DISPID_TB_BUTTONS), helpstring("Retrieves a collection object wrapping the control's buttons."), nonbrowsable]
		HRESULT Buttons([out, retval] IToolBarButtons** ppButtons);
		/// \brief <em>Controls the buttons' appearance</em>
		///
		/// Retrieves or sets the appearance of the tool bar buttons. Any of the values defined by the
		/// \c ButtonStyleConstants enumeration is valid.
		///
		/// \remarks The \c ButtonStyle property should be set to \c bst3D, if the \c Orientation property is
		///          set to \c oVertical and the control is not placed inside a rebar control.
		///
		/// \sa ButtonTextPosition, Orientation, ButtonStyleConstants
		[propget, id(DISPID_TB_BUTTONSTYLE), helpstring("Retrieves or sets the appearance of the tool bar buttons.")]
		HRESULT ButtonStyle([out, retval] ButtonStyleConstants* pValue);
		[propput, id(DISPID_TB_BUTTONSTYLE), helpstring("Retrieves or sets the appearance of the tool bar buttons.")]
		HRESULT ButtonStyle([in] ButtonStyleConstants newValue);
		/// \brief <em>Controls the layout of the button captions</em>
		///
		/// Retrieves or sets the position of the button texts relative to the button icons. Any of the values
		/// defined by the \c ButtonTextPositionConstants enumeration is valid.
		///
		/// \sa ButtonStyle, IToolBarButton::Text, ButtonTextPositionConstants
		[propget, id(DISPID_TB_BUTTONTEXTPOSITION), helpstring("Retrieves or sets the position of the button texts relative to the button icons.")]
		HRESULT ButtonTextPosition([out, retval] ButtonTextPositionConstants* pValue);
		[propput, id(DISPID_TB_BUTTONTEXTPOSITION), helpstring("Retrieves or sets the position of the button texts relative to the button icons.")]
		HRESULT ButtonTextPosition([in] ButtonTextPositionConstants newValue);
		/// \brief <em>Controls the buttons' width</em>
		///
		/// Retrieves or sets the width (in pixels) of a button. If set to 0, the system's default button width
		/// is used.
		///
		/// \sa ButtonHeight, MinimumButtonWidth, MaximumButtonWidth
		[propget, id(DISPID_TB_BUTTONWIDTH), helpstring("Retrieves or sets the width (in pixels) of a button. If set to 0, the system's default button width is used.")]
		HRESULT ButtonWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_BUTTONWIDTH), helpstring("Retrieves or sets the width (in pixels) of a button. If set to 0, the system's default button width is used.")]
		HRESULT ButtonWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TB_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Controls whether the specified command can be executed</em>
		///
		/// Enables or disables a command for execution. If set to \c True, the control will fire the
		/// \c ExecuteCommand event if the command's associated button or menu entry is clicked or its
		/// associated hotkey is pressed; otherwise not.
		///
		/// \param[in] commandID The unique ID of the command to enable or disable.
		///
		/// \remarks If a tool bar button with the specified command ID exists, it will be enabled or disabled
		///          when setting this property.
		///
		/// \sa Enabled, IToolBarButton::Enabled, RegisterHotkey, _IToolBarEvents::ExecuteCommand
		[propget, id(DISPID_TB_COMMANDENABLED), helpstring("Enables or disables a command for execution. If a tool bar button with the specified command ID exists, it will be enabled or disabled when setting this property."), nonbrowsable]
		HRESULT CommandEnabled([in] LONG commandID, [out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_COMMANDENABLED), helpstring("Enables or disables a command for execution. If a tool bar button with the specified command ID exists, it will be enabled or disabled when setting this property."), nonbrowsable]
		HRESULT CommandEnabled([in] LONG commandID, [in] VARIANT_BOOL newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_TB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_TB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Specifies whether a thin line is drawn on top of the control</em>
		///
		/// Retrieves or sets whether a thin line is drawn on top of the control, that visually separates the
		/// tool bar from the menu. If set to \c True, the divider is displayed; otherwise not.
		///
		/// \attention Changing this property may destroy and recreate the control window.
		[propget, id(DISPID_TB_DISPLAYMENUDIVIDER), helpstring("Retrieves or sets whether a thin line is drawn on top of the control, that visually separates the tool bar from the menu. Changing this property may destroy and recreate the control window.")]
		HRESULT DisplayMenuDivider([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_DISPLAYMENUDIVIDER), helpstring("Retrieves or sets whether a thin line is drawn on top of the control, that visually separates the tool bar from the menu. Changing this property may destroy and recreate the control window.")]
		HRESULT DisplayMenuDivider([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether buttons, that are partially clipped, are displayed</em>
		///
		/// Retrieves or sets whether partially clipped buttons are displayed or hidden. If set to \c True,
		/// partially clipped buttons are displayed; otherwise hidden.
		///
		/// \remarks This property is ignored, if the \c WrapButtons property is set to \c True.\n
		///          This property cannot be set to \c False, if the \c Orientation property is set to
		///          \c oVertical.
		///
		/// \sa Buttons, WrapButtons, Orientation, OrientationConstants
		[propget, id(DISPID_TB_DISPLAYPARTIALLYCLIPPEDBUTTONS), helpstring("Retrieves or sets whether partially clipped buttons are displayed or hidden. This property cannot be set to 'False', if the 'Orientation' property is set to 'oVertical'.")]
		HRESULT DisplayPartiallyClippedButtons([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_DISPLAYPARTIALLYCLIPPEDBUTTONS), helpstring("Retrieves or sets whether partially clipped buttons are displayed or hidden. This property cannot be set to 'False', if the 'Orientation' property is set to 'oVertical'.")]
		HRESULT DisplayPartiallyClippedButtons([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls redrawing of the control</em>
		///
		/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
		/// on the control may increase performance. If set to \c False, the control will redraw itself
		/// automatically; otherwise not.
		[propget, id(DISPID_TB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_DONTREDRAW), helpstring("Enables or disables automatic redrawing of the control.")]
		HRESULT DontRedraw([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the speed of automatic button clicking during drag'n'drop</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be placed over a button during a
		/// drag'n'drop operation before this button will be clicked automatically. If set to 0, auto-clicking
		/// is disabled. If set to -1, the system's double-click time is used.
		///
		/// \sa RegisterForOLEDragDrop, _IToolBarEvents::OLEDragMouseMove
		[propget, id(DISPID_TB_DRAGCLICKTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over a button during a drag'n'drop operation before this button will be clicked automatically.")]
		HRESULT DragClickTime([out, retval] LONG* pValue);
		[propput, id(DISPID_TB_DRAGCLICKTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be placed over a button during a drag'n'drop operation before this button will be clicked automatically.")]
		HRESULT DragClickTime([in] LONG newValue);
		/// \brief <em>Specifies how the tool bar can be customized using drag'n'drop</em>
		///
		/// Retrieves or sets the modifier key that must be pressed to customize the tool bar (i. e. move
		/// buttons) using drag'n'drop. Any of the values defined by the
		/// \c DragDropCustomizationModifierKeyConstants enumeration is valid.
		///
		/// \remarks If the \c AllowCustomization property is set to \c False, this property is ignored.
		///
		/// \sa AllowCustomization, Customize, DragDropCustomizationModifierKeyConstants
		[propget, id(DISPID_TB_DRAGDROPCUSTOMIZATIONMODIFIERKEY), helpstring("Retrieves or sets the modifier key that must be pressed to customize the tool bar (i. e. move buttons) using drag'n'drop If the 'AllowCustomization' property is set to 'False', this property is ignored.")]
		HRESULT DragDropCustomizationModifierKey([out, retval] DragDropCustomizationModifierKeyConstants* pValue);
		[propput, id(DISPID_TB_DRAGDROPCUSTOMIZATIONMODIFIERKEY), helpstring("Retrieves or sets the modifier key that must be pressed to customize the tool bar (i. e. move buttons) using drag'n'drop If the 'AllowCustomization' property is set to 'False', this property is ignored.")]
		HRESULT DragDropCustomizationModifierKey([in] DragDropCustomizationModifierKeyConstants newValue);
		/// \brief <em>Retrieves the buttons currently dragged</em>
		///
		/// Retrieves a collection object wrapping the buttons that are currently dragged. These are the
		/// same buttons that were passed to the \c OLEDrag method.
		///
		/// \remarks This property is read-only.
		///
		/// \sa OLEDrag, IToolBarButtonContainer, Buttons
		[propget, id(DISPID_TB_DRAGGEDBUTTONS), helpstring("Retrieves a collection object wrapping the buttons that are currently dragged."), nonbrowsable]
		HRESULT DraggedButtons([out, retval] IToolBarButtonContainer** ppButtons);
		/// \brief <em>Controls the buttons' inner layout</em>
		///
		/// Retrieves or sets the extra space in pixels between a button's text and its drop down section. If
		/// set to -1, the system's default value is used.
		///
		/// \remarks This property is ignored if the \c ButtonTextPosition property is set to a value other
		///          than \c btpRightToIcon or if the \c NormalDropDownButtonStyle property is set to a value
		///          other than \c nddbsSplitButton.
		///
		/// \sa HorizontalButtonPadding, HorizontalIconCaptionGap, ButtonTextPosition,
		///     NormalDropDownButtonStyle
		[propget, id(DISPID_TB_DROPDOWNGAP), helpstring("Retrieves or sets the extra space in pixels between a button's text and its drop down section. This property is ignored if 'ButtonTextPosition' isn't set to 'btpRightToIcon' or 'NormalDropDownButtonStyle' isn't set to 'nddbsSplitButton'.")]
		HRESULT DropDownGap([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_DROPDOWNGAP), helpstring("Retrieves or sets the extra space in pixels between a button's text and its drop down section. This property is ignored if 'ButtonTextPosition' isn't set to 'btpRightToIcon' or 'NormalDropDownButtonStyle' isn't set to 'nddbsSplitButton'.")]
		HRESULT DropDownGap([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		///
		/// \sa CommandEnabled, IToolBarButton::Enabled
		[propget, id(DISPID_TB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the buttons' alignment</em>
		///
		/// Retrieves or sets the number of pixels between the control's left edge and the left edge of the
		/// first button in a row.
		///
		/// \sa HorizontalButtonSpacing
		[propget, id(DISPID_TB_FIRSTBUTTONINDENTATION), helpstring("Retrieves or sets the number of pixels between the control's left edge and the left edge of the first button in a row.")]
		HRESULT FirstButtonIndentation([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_FIRSTBUTTONINDENTATION), helpstring("Retrieves or sets the number of pixels between the control's left edge and the left edge of the first button in a row.")]
		HRESULT FirstButtonIndentation([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls when the control accepts the keyboard focus</em>
		///
		/// Retrieves or sets whether the control accepts the keyboard focus always or only if it is required
		/// to support keyboard navigation. If set to \c True, the control accepts the keyboard focus always.
		/// If set to \c False, keyboard focus is accepted in the following situations:
		/// - The control is in menu mode and the user closes the currently displayed menus by pressing
		///   the [ESC] button. In this case the control will actively steal the focus. It will set the focus
		///   back to the previously focused control if the user presses the [ESC] button again.
		/// - The focus is set to the control by walking through the dialog's tab order (using the [TAB]
		///   button).
		///
		/// \sa MenuMode
		[propget, id(DISPID_TB_FOCUSONCLICK), helpstring("Retrieves or sets whether the control accepts the keyboard focus always or only if it is required to support keyboard navigation. See the help file for important details.")]
		HRESULT FocusOnClick([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_FOCUSONCLICK), helpstring("Retrieves or sets whether the control accepts the keyboard focus always or only if it is required to support keyboard navigation. See the help file for important details.")]
		HRESULT FocusOnClick([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the button captions.
		///
		/// \remarks This property isn't supported for themed tool bars (except on Windows XP).
		///
		/// \sa UseSystemFont
		[propget, id(DISPID_TB_FONT), helpstring("Retrieves or sets the control's font. This property isn't supported for themed tool bars. (except on Windows XP)")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_TB_FONT), helpstring("Retrieves or sets the control's font. This property isn't supported for themed tool bars. (except on Windows XP)")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_TB_FONT), helpstring("Retrieves or sets the control's font. This property isn't supported for themed tool bars. (except on Windows XP)")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Retrieves the window handle of the tool bar that is displayed as part of the chevron popup window</em>
		///
		/// The chevron popup that the control may display is a simple popup menu (if the control is in menu
		/// mode) or a popup window that contains a tool bar control. This property retrieves the handle of the
		/// popup menu.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hWndChevronToolBar, DisplayChevronPopupWindow
		[propget, id(DISPID_TB_HCHEVRONMENU), helpstring("The chevron popup that the control may display is a simple popup menu (if the control is in menu mode) or a popup window that contains a tool bar control. This property retrieves the handle of the popup menu."), nonbrowsable]
		HRESULT hChevronMenu([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the control's 3D highlight color</em>
		///
		/// Retrieves or sets the color used by the control to draw highlighted parts of tool bar buttons. If
		/// set to -1, the default color is used.
		///
		/// \remarks This property isn't supported for themed tool bars.
		///
		/// \sa ShadowColor
		[propget, id(DISPID_TB_HIGHLIGHTCOLOR), helpstring("Retrieves or sets the color used by the control to draw highlighted parts of tool bar buttons. If set to -1, the default color is used. This property isn't supported for themed tool bars.")]
		HRESULT HighlightColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TB_HIGHLIGHTCOLOR), helpstring("Retrieves or sets the color used by the control to draw highlighted parts of tool bar buttons. If set to -1, the default color is used. This property isn't supported for themed tool bars.")]
		HRESULT HighlightColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies one of the control's associated imagelist</em>
		///
		/// Retrieves or sets the handle of the specified imagelist.
		///
		/// \param[in] imageList The imageList to retrieve or set. Most of the values defined by the
		///            \c ImageListConstants enumeration is valid.
		/// \param[in] imageListIndex The zero-based index of the image list of the type specified by
		///            \c imageList. The tool bar buttons' icons can be taken from different image lists, e. g.
		///            the 1st button's icon can be from image list A, the 2nd button's icon from image list B
		///            and so on.
		///
		/// \remarks The previously set image list does NOT get destroyed automatically.
		///
		/// \sa IToolBarButton::IconIndex, IToolBarButton::ImageListIndex, ImageListCount, SuggestedIconSize,
		///     ImageListConstants
		[propget, id(DISPID_TB_HIMAGELIST), helpstring("Retrieves or sets the handle of the specified imagelist."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [in, defaultvalue(0)] LONG imageListIndex, [out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_TB_HIMAGELIST), helpstring("Retrieves or sets the handle of the specified imagelist."), nonbrowsable]
		HRESULT hImageList([in] ImageListConstants imageList, [in, defaultvalue(0)] LONG imageListIndex, [in] OLE_HANDLE newValue);
		/// \brief <em>Controls the buttons' inner layout</em>
		///
		/// Retrieves or sets the number of pixels in horizontal direction between a button's border and its
		/// content. If set to -1, the system's default value is used.
		///
		/// \remarks Padding is applied to automatically-sized buttons only.\n
		///          This property is ignored if the \c AlwaysDisplayButtonText property is set to \c False.
		///
		/// \sa VerticalButtonPadding, HorizontalIconCaptionGap, HorizontalButtonSpacing,
		///     IToolBarButton::AutoSize, AlwaysDisplayButtonText
		[propget, id(DISPID_TB_HORIZONTALBUTTONPADDING), helpstring("Retrieves or sets the number of pixels in horizontal direction between a button's border and its content. Padding is applied to automatically-sized buttons only. This property is ignored if the 'AlwaysDisplayButtonText' property is set to 'False'.")]
		HRESULT HorizontalButtonPadding([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_HORIZONTALBUTTONPADDING), helpstring("Retrieves or sets the number of pixels in horizontal direction between a button's border and its content. Padding is applied to automatically-sized buttons only. This property is ignored if the 'AlwaysDisplayButtonText' property is set to 'False'.")]
		HRESULT HorizontalButtonPadding([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the buttons' alignment</em>
		///
		/// Retrieves or sets the number of pixels between buttons in horizontal direction.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa VerticalButtonSpacing, HorizontalIconCaptionGap, FirstButtonIndentation,
		///     HorizontalButtonPadding
		[propget, id(DISPID_TB_HORIZONTALBUTTONSPACING), helpstring("Retrieves or sets the number of pixels between buttons in horizontal direction. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT HorizontalButtonSpacing([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_HORIZONTALBUTTONSPACING), helpstring("Retrieves or sets the number of pixels between buttons in horizontal direction. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT HorizontalButtonSpacing([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the buttons' inner layout</em>
		///
		/// Retrieves or sets the number of pixels in horizontal direction between a button's icon and its
		/// text. If set to -1, the system's default value is used.
		///
		/// \remarks This property is ignored if the \c ButtonTextPosition property is set to a value other
		///          than \c btpRightToIcon.
		///
		/// \sa HorizontalButtonPadding, DropDownGap, VerticalButtonSpacing, VerticalButtonSpacing,
		///     ButtonTextPosition
		[propget, id(DISPID_TB_HORIZONTALICONCAPTIONGAP), helpstring("Retrieves or sets the number of pixels in horizontal direction between a button's icon and its text. This property is ignored if the 'ButtonTextPosition' property is set to a value other than 'btpRightToIcon'.")]
		HRESULT HorizontalIconCaptionGap([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_HORIZONTALICONCAPTIONGAP), helpstring("Retrieves or sets the number of pixels in horizontal direction between a button's icon and its text. This property is ignored if the 'ButtonTextPosition' property is set to a value other than 'btpRightToIcon'.")]
		HRESULT HorizontalIconCaptionGap([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the horizontal alignment of the button texts</em>
		///
		/// Retrieves or sets the horizontal alignment of the button texts. Any of the values defined by the
		/// \c HAlignmentConstants enumeration is valid.
		///
		/// \sa VerticalTextAlignment, IToolBarButton::Text, HAlignmentConstants
		[propget, id(DISPID_TB_HORIZONTALTEXTALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the button texts.")]
		HRESULT HorizontalTextAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_TB_HORIZONTALTEXTALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the button texts.")]
		HRESULT HorizontalTextAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Specifies the control's hot button</em>
		///
		/// Retrieves or sets the control's hot button. The hot button is the button under the mouse cursor.
		/// If set to \c Nothing, the control does not have a hot button.
		///
		/// \remarks This property is ignored if the \c ButtonStyle property is set to \c bst3D.
		///
		/// \sa SetHotButton, IToolBarButton::Hot, _IToolBarEvents::HotButtonChanging
		[propget, id(DISPID_TB_HOTBUTTON), helpstring("Retrieves or sets the control's hot button. The hot button is the button under the mouse cursor. If set to 'Nothing', the control does not have a hot button. This property is ignored if the 'ButtonStyle' property is set to 'bst3D'."), nonbrowsable]
		HRESULT HotButton([out, retval] IToolBarButton** ppHotButton);
		[propputref, id(DISPID_TB_HOTBUTTON), helpstring("Retrieves or sets the control's hot button. The hot button is the button under the mouse cursor. If set to 'Nothing', the control does not have a hot button. This property is ignored if the 'ButtonStyle' property is set to 'bst3D'."), nonbrowsable]
		HRESULT HotButton([in] IToolBarButton* pNewHotButton);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IToolBarEvents::MouseHover
		[propget, id(DISPID_TB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_TB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IToolBarEvents::RecreatedControlWindow, _IToolBarEvents::DestroyedControlWindow
		[propget, id(DISPID_TB_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Retrieves the window handle of the tool bar that is displayed as part of the chevron popup window</em>
		///
		/// The chevron popup that the control may display is a simple popup menu (if the control is in menu
		/// mode) or a popup window that contains a tool bar control. This property retrieves the window handle
		/// of the tool bar control that is part of the chevron popup.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hChevronMenu, DisplayChevronPopupWindow, hWnd
		[propget, id(DISPID_TB_HWNDCHEVRONTOOLBAR), helpstring("The chevron popup that the control may display is a simple popup menu (if the control is in menu mode) or a popup window that contains a tool bar control. This property retrieves the window handle of the tool bar control that is part of the chevron popup."), nonbrowsable]
		HRESULT hWndChevronToolBar([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the tooltip control's window handle</em>
		///
		/// Retrieves or sets the tooltip control's window handle.
		///
		/// \remarks The previously set tooltip window does NOT get destroyed automatically.
		///
		/// \sa ShowToolTips
		[propget, id(DISPID_TB_HWNDTOOLTIP), helpstring("Retrieves or sets the tooltip control's window handle."), nonbrowsable]
		HRESULT hWndToolTip([out, retval] OLE_HANDLE* pValue);
		[propput, id(DISPID_TB_HWNDTOOLTIP), helpstring("Retrieves or sets the tooltip control's window handle."), nonbrowsable]
		HRESULT hWndToolTip([in] OLE_HANDLE newValue);
		/// \brief <em>Retrieves the control's ideal height</em>
		///
		/// Retrieves the control's ideal height, i. e. the height at which all buttons would be displayed.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IdealWidth, AutoSize, MaximumHeight
		[propget, id(DISPID_TB_IDEALHEIGHT), helpstring("Retrieves the control's ideal height, i. e. the height at which all buttons would be displayed."), nonbrowsable]
		HRESULT IdealHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the control's ideal width</em>
		///
		/// Retrieves the control's ideal width, i. e. the width at which all buttons would be displayed.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IdealHeight, AutoSize, MaximumWidth
		[propget, id(DISPID_TB_IDEALWIDTH), helpstring("Retrieves the control's ideal width, i. e. the width at which all buttons would be displayed."), nonbrowsable]
		HRESULT IdealWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		/// \brief <em>Retrieves the number of image lists associated with the control</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa hImageList
		[propget, id(DISPID_TB_IMAGELISTCOUNT), helpstring("Retrieves the number of image lists associated with the control."), nonbrowsable]
		HRESULT ImageListCount([out, retval] LONG* pValue);
		/// \brief <em>Specifies the color of the control's insertion mark</em>
		///
		/// Retrieves or sets the color that the control's insertion mark is drawn in.
		///
		/// \sa SetInsertMarkPosition
		[propget, id(DISPID_TB_INSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT InsertMarkColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TB_INSERTMARKCOLOR), helpstring("Retrieves or sets the color that the control's insertion mark is drawn in.")]
		HRESULT InsertMarkColor([in] OLE_COLOR newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_TB_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Controls the buttons' width</em>
		///
		/// Retrieves or sets the maximum width of a button. If this width would be exceeded, the button's
		/// text is drawn with ellipsis.
		///
		/// \sa MinimumButtonWidth, ButtonWidth
		[propget, id(DISPID_TB_MAXIMUMBUTTONWIDTH), helpstring("Retrieves or sets the maximum width of a button. If this width would be exceeded, the button's text is drawn with ellipsis.")]
		HRESULT MaximumButtonWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_MAXIMUMBUTTONWIDTH), helpstring("Retrieves or sets the maximum width of a button. If this width would be exceeded, the button's text is drawn with ellipsis.")]
		HRESULT MaximumButtonWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Retrieves the control's maximum height</em>
		///
		/// Retrieves the control's maximum height, i. e. the calculated total height of all visible buttons
		/// and separators together.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MaximumWidth, AutoSize, IdealHeight
		[propget, id(DISPID_TB_MAXIMUMHEIGHT), helpstring("Retrieves the control's maximum height, i. e. the calculated total height of all visible buttons and separators together."), nonbrowsable]
		HRESULT MaximumHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		/// \brief <em>Controls the drawing of button texts</em>
		///
		/// Retrieves or sets the maximum number of lines used to display button texts.
		///
		/// \remarks The button text is wrapped at word breaks only, line breaks are ignored.\n
		///          This property is ignored if the \c ButtonTextPosition property is set to
		///          \c btpRightToIcon.
		///
		/// \sa IToolBarButton::Text, ButtonTextPosition
		[propget, id(DISPID_TB_MAXIMUMTEXTROWS), helpstring("Retrieves or sets the maximum number of lines used to display button texts. The button text is wrapped at word breaks only, line breaks are ignored. This property is ignored if the 'ButtonTextPosition' property is set to 'btpRightToIcon'.")]
		HRESULT MaximumTextRows([out, retval] LONG* pValue);
		[propput, id(DISPID_TB_MAXIMUMTEXTROWS), helpstring("Retrieves or sets the maximum number of lines used to display button texts. The button text is wrapped at word breaks only, line breaks are ignored. This property is ignored if the 'ButtonTextPosition' property is set to 'btpRightToIcon'.")]
		HRESULT MaximumTextRows([in] LONG newValue);
		/// \brief <em>Retrieves the control's maximum width</em>
		///
		/// Retrieves the control's maximum width, i. e. the calculated total width of all visible buttons and
		/// separators together.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MaximumHeight, AutoSize, IdealWidth
		[propget, id(DISPID_TB_MAXIMUMWIDTH), helpstring("Retrieves the control's maximum width, i. e. the calculated total width of all visible buttons and separators together."), nonbrowsable]
		HRESULT MaximumWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		/// \brief <em>Controls the control's appearance in menu mode</em>
		///
		/// Retrieves or sets how the tool bar buttons are drawn if the control is in menu mode. Any of the
		/// values defined by the \c MenuBarThemeConstants enumeration is valid.
		///
		/// \sa MenuMode, MenuBarThemeConstants
		[propget, id(DISPID_TB_MENUBARTHEME), helpstring("Retrieves or sets how the tool bar buttons are drawn if the control is in menu mode.")]
		HRESULT MenuBarTheme([out, retval] MenuBarThemeConstants* pValue);
		[propput, id(DISPID_TB_MENUBARTHEME), helpstring("Retrieves or sets how the tool bar buttons are drawn if the control is in menu mode.")]
		HRESULT MenuBarTheme([in] MenuBarThemeConstants newValue);
		/// \brief <em>Specifies whether the control is used as a menu bar replacement</em>
		///
		/// Retrieves or sets whether the control emulates a menu bar. If set to \c True, the control emulates
		/// a menu bar; otherwise not.
		///
		/// \remarks This property cannot be set at runtime.\n
		///          Emulating a menu bar activates a couple of restrictions:
		///          - The \c AlwaysDisplayButtonText property has to be set to \c True.
		///          - The \c ButtonTextPosition property has to be set to \c btpRightToIcon.
		///          - The \c HorizontalTextAlignment property has to be set to \c halCenter.
		///          - The \c NormalDropDownButtonStyle property has to be set to \c nddbsWithoutArrow.
		///          - The \c VerticalTextAlignment property has to be set to \c valCenter.
		///
		/// \sa MenuBarTheme, RegisterHotkey
		[propget, id(DISPID_TB_MENUMODE), helpstring("Retrieves or sets whether the control emulates a menu bar. This property cannot be set at runtime.")]
		HRESULT MenuMode([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_MENUMODE), helpstring("Retrieves or sets whether the control emulates a menu bar. This property cannot be set at runtime.")]
		HRESULT MenuMode([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the buttons' width</em>
		///
		/// Retrieves or sets the minimum width of a button. Auto-sized buttons won't become smaller than this.
		///
		/// \sa MaximumButtonWidth, ButtonWidth
		[propget, id(DISPID_TB_MINIMUMBUTTONWIDTH), helpstring("Retrieves or sets the minimum width of a button. Auto-sized buttons won't become smaller than this.")]
		HRESULT MinimumButtonWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_MINIMUMBUTTONWIDTH), helpstring("Retrieves or sets the minimum width of a button. Auto-sized buttons won't become smaller than this.")]
		HRESULT MinimumButtonWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, MousePointerConstants
		[propget, id(DISPID_TB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_TB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_TB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, MousePointerConstants
		[propget, id(DISPID_TB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_TB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether the buttons are organized in multiple columns if the control's orientation is vertical</em>
		///
		/// Retrieves or sets whether the control displays the buttons in multiple columns. If set to \c True,
		/// the buttons are organized in multiple columns; otherwise not.
		///
		/// \remarks This property cannot be set to \c True, if the \c Orientation property is set to
		///          \c oHorizontal.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa Orientation
		[propget, id(DISPID_TB_MULTICOLUMN), helpstring("Retrieves or sets whether the control displays the buttons in multiple columns. This property cannot be set to 'True', if the 'Orientation' property is set to 'oHorizontal'. Changing this property destroys and recreates the control window.")]
		HRESULT MultiColumn([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_MULTICOLUMN), helpstring("Retrieves or sets whether the control displays the buttons in multiple columns. This property cannot be set to 'True', if the 'Orientation' property is set to 'oHorizontal'. Changing this property destroys and recreates the control window.")]
		HRESULT MultiColumn([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the native tool bar control's \c IDropTarget implementation</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa RegisterForOLEDragDrop
		[propget, id(DISPID_TB_NATIVEDROPTARGET), helpstring("Retrieves the native tool bar control's 'IDropTarget' implementation."), nonbrowsable]
		HRESULT NativeDropTarget([out, retval] IUnknown** ppValue);
		/// \brief <em>Controls the appearance of drop-down buttons</em>
		///
		/// Retrieves or sets how buttons with the \c DropDownStyle property being set to \c ddstNormal are
		/// drawn. Any of the values defined by the \c NormalDropDownButtonStyleConstants enumeration is valid.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa IToolBarButton::DropDownStyle, NormalDropDownButtonStyleConstants
		[propget, id(DISPID_TB_NORMALDROPDOWNBUTTONSTYLE), helpstring("Retrieves or sets how buttons with the 'DropDownStyle' property being set to 'ddstNormal' are drawn. Changing this property destroys and recreates the control window.")]
		HRESULT NormalDropDownButtonStyle([out, retval] NormalDropDownButtonStyleConstants* pValue);
		[propput, id(DISPID_TB_NORMALDROPDOWNBUTTONSTYLE), helpstring("Retrieves or sets how buttons with the 'DropDownStyle' property being set to 'ddstNormal' are drawn. Changing this property destroys and recreates the control window.")]
		HRESULT NormalDropDownButtonStyle([in] NormalDropDownButtonStyleConstants newValue);
		/// \brief <em>Specifies the appearance of the OLE drag images generated by the control</em>
		///
		/// Retrieves or sets the appearance of the OLE drag images generated by the control. Any of the values
		/// defined by the \c OLEDragImageStyleConstants enumeration is valid.
		///
		/// \sa SupportOLEDragImages, OLEDrag, OLEDragImageStyleConstants
		[propget, id(DISPID_TB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([out, retval] OLEDragImageStyleConstants* pValue);
		[propput, id(DISPID_TB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([in] OLEDragImageStyleConstants newValue);
		/// \brief <em>Controls the control's orientation</em>
		///
		/// Retrieves or sets the direction, in which the control displays buttons. Any of the values defined
		/// by the \c OrientationConstants enumeration is valid.
		///
		/// \remarks If this property is set to \c oVertical, the \c DisplayPartiallyClippedButtons property
		///          must be set to \c True. Additionally the \c BackStyle property should be set to
		///          \c bksOpaque and the \c ButtonStyle property should be set to \c bst3D, if the control
		///          is not placed inside a rebar control.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa DisplayPartiallyClippedButtons, BackStyle, ButtonStyle, MultiColumn, OrientationConstants
		[propget, id(DISPID_TB_ORIENTATION), helpstring("Retrieves or sets the direction, in which the control displays buttons. If this property is set to 'oVertical', the 'DisplayPartiallyClippedButtons' property must be set to 'True'. Changing this property destroys and recreates the control window.")]
		HRESULT Orientation([out, retval] OrientationConstants* pValue);
		[propput, id(DISPID_TB_ORIENTATION), helpstring("Retrieves or sets the direction, in which the control displays buttons. If this property is set to 'oVertical', the 'DisplayPartiallyClippedButtons' property must be set to 'True'. Changing this property destroys and recreates the control window.")]
		HRESULT Orientation([in] OrientationConstants newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the event is fired; otherwise not.
		///
		/// \sa _IToolBarEvents::ContextMenu
		[propget, id(DISPID_TB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_TB_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether the \c CustomDraw event is raised when erasing the control's background</em>
		///
		/// Retrieves or sets whether the \c CustomDraw event is raised when erasing the control's background.
		/// If this property is set to \c True, the event is raised when the control erases its background.
		/// Otherwise the event is not raised in this case.
		///
		/// \sa _IToolBarEvents::CustomDraw, CustomDrawStageConstants
		[propget, id(DISPID_TB_RAISECUSTOMDRAWEVENTONERASEBACKGROUND), helpstring("Retrieves or sets whether the 'CustomDraw' event is raised when erasing the control's background.")]
		HRESULT RaiseCustomDrawEventOnEraseBackground([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_RAISECUSTOMDRAWEVENTONERASEBACKGROUND), helpstring("Retrieves or sets whether the 'CustomDraw' event is raised when erasing the control's background.")]
		HRESULT RaiseCustomDrawEventOnEraseBackground([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. Any of the
		/// values defined by the \c RegisterForOLEDragDropConstants enumeration is valid.
		///
		/// \sa SupportOLEDragImages, _IToolBarEvents::OLEDragEnter, RegisterForOLEDragDropConstants
		[propget, id(DISPID_TB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] RegisterForOLEDragDropConstants* pValue);
		[propput, id(DISPID_TB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] RegisterForOLEDragDropConstants newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \sa RightToLeftConstants
		[propget, id(DISPID_TB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_TB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Specifies the control's 3D shadow color</em>
		///
		/// Retrieves or sets the color used by the control to draw shadowed parts of tool bar buttons. If set
		/// to -1, the default color is used.
		///
		/// \remarks This property isn't supported for themed tool bars.
		///
		/// \sa HighlightColor
		[propget, id(DISPID_TB_SHADOWCOLOR), helpstring("Retrieves or sets the color used by the control to draw shadowed parts of tool bar buttons. If set to -1, the default color is used. This property isn't supported for themed tool bars.")]
		HRESULT ShadowColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TB_SHADOWCOLOR), helpstring("Retrieves or sets the color used by the control to draw shadowed parts of tool bar buttons. If set to -1, the default color is used. This property isn't supported for themed tool bars.")]
		HRESULT ShadowColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls the visibility of the control's drag image</em>
		///
		/// Retrieves or sets whether the drag image is currently visible or hidden. If set to \c True, it
		/// is visible; otherwise it is hidden.
		///
		/// \sa SupportOLEDragImages
		[propget, id(DISPID_TB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control displays any tooltips</em>
		///
		/// Retrieves or sets whether the control displays any tooltips. If this property is set to \c True,
		/// the buttons' tooltips retrieved through the \c ButtonGetInfoTipText event are displayed. Otherwise
		/// no tooltips are shown.
		///
		/// \sa hWndToolTip, _IToolBarEvents::ButtonGetInfoTipText
		[propget, id(DISPID_TB_SHOWTOOLTIPS), helpstring("Retrieves or sets whether the control displays any tooltips.")]
		HRESULT ShowToolTips([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_SHOWTOOLTIPS), helpstring("Retrieves or sets whether the control displays any tooltips.")]
		HRESULT ShowToolTips([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves which icon size should be used</em>
		///
		/// Retrieves a value specifying which icon size should be used for the tool bar button icons. This
		/// suggestion is based upon the system's DPI settings. Any of the values defined by the
		/// \c SuggestedIconSizeConstants enumeration is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa hImageList, SuggestedIconSizeConstants
		[propget, id(DISPID_TB_SUGGESTEDICONSIZE), helpstring("Retrieves a value specifying which icon size should be used for the tool bar button icons. This suggestion is based upon the system's DPI settings."), nonbrowsable]
		HRESULT SuggestedIconSize([out, retval] SuggestedIconSizeConstants* pValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, hImageList, ShowDragImage, OLEDragImageStyle, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_TB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_TB_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies how ampersands in button texts are handled</em>
		///
		/// Retrieves or sets whether the control handles ampersands in button texts as accelerator keys. If
		/// set to \c True, ampersands are handled as marking accelerator keys; otherwise they are handled as
		/// normal characters.
		///
		/// \sa IToolBarButton::Text
		[propget, id(DISPID_TB_USEMNEMONICS), helpstring("Retrieves or sets whether the control handles ampersands in button texts as accelerator keys.")]
		HRESULT UseMnemonics([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_USEMNEMONICS), helpstring("Retrieves or sets whether the control handles ampersands in button texts as accelerator keys.")]
		HRESULT UseMnemonics([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses the system font</em>
		///
		/// Retrieves or sets whether the control uses the MS Shell Dlg font (which is mapped to the system's
		/// default GUI font) or the font specified by the \c Font property. If set to \c True, the system
		/// font; otherwise the specified font is used.
		///
		/// \remarks This property isn't supported for themed tool bars (except on Windows XP).
		///
		/// \sa Font
		[propget, id(DISPID_TB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property. This property isn't supported for themed tool bars (except on Windows XP).")]
		HRESULT UseSystemFont([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_USESYSTEMFONT), helpstring("Retrieves or sets whether the control uses the MS Shell Dlg font or the font specified by the 'Font' property. This property isn't supported for themed tool bars (except on Windows XP).")]
		HRESULT UseSystemFont([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_TB_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);
		/// \brief <em>Controls the buttons' inner layout</em>
		///
		/// Retrieves or sets the number of pixels in vertical direction between a button's border and its
		/// content. If set to -1, the system's default value is used.
		///
		/// \remarks Padding is applied to automatically-sized buttons only.\n
		///          This property is ignored if the \c AlwaysDisplayButtonText property is set to \c False.
		///
		/// \sa HorizontalButtonPadding, VerticalButtonSpacing, IToolBarButton::AutoSize,
		///     AlwaysDisplayButtonText
		[propget, id(DISPID_TB_VERTICALBUTTONPADDING), helpstring("Retrieves or sets the number of pixels in vertical direction between a button's border and its content. Padding is applied to automatically-sized buttons only. This property is ignored if the 'AlwaysDisplayButtonText' property is set to 'False'.")]
		HRESULT VerticalButtonPadding([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_VERTICALBUTTONPADDING), helpstring("Retrieves or sets the number of pixels in vertical direction between a button's border and its content. Padding is applied to automatically-sized buttons only. This property is ignored if the 'AlwaysDisplayButtonText' property is set to 'False'.")]
		HRESULT VerticalButtonPadding([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the buttons' alignment</em>
		///
		/// Retrieves or sets the number of pixels between buttons in vertical direction.
		///
		/// \remarks Requires comctl32.dll version 6.0 or higher.
		///
		/// \sa HorizontalButtonSpacing, VerticalButtonPadding
		[propget, id(DISPID_TB_VERTICALBUTTONSPACING), helpstring("Retrieves or sets the number of pixels between buttons in vertical direction. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT VerticalButtonSpacing([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_TB_VERTICALBUTTONSPACING), helpstring("Retrieves or sets the number of pixels between buttons in vertical direction. Requires comctl32.dll version 6.0 or higher.")]
		HRESULT VerticalButtonSpacing([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Controls the vertical alignment of the button texts</em>
		///
		/// Retrieves or sets the vertical alignment of the button texts. Any of the values defined by the
		/// \c VAlignmentConstants enumeration is valid.
		///
		/// \sa HorizontalTextAlignment, IToolBarButton::Text, VAlignmentConstants
		[propget, id(DISPID_TB_VERTICALTEXTALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the button texts.")]
		HRESULT VerticalTextAlignment([out, retval] VAlignmentConstants* pValue);
		[propput, id(DISPID_TB_VERTICALTEXTALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the button texts.")]
		HRESULT VerticalTextAlignment([in] VAlignmentConstants newValue);
		/// \brief <em>Specifies whether buttons may be wrapped to multiple lines</em>
		///
		/// Retrieves or sets whether buttons may be displayed on multiple lines, if the tool bar becomes too
		/// narrow to include all buttons on the same line. If set to \c True, buttons may be wrapped;
		/// otherwise not.
		///
		/// \sa DisplayPartiallyClippedButtons, IToolBarButton::FollowedByLineBreak, IToolBarButton::Width,
		///     ButtonRowCount, SetButtonRowCount
		[propget, id(DISPID_TB_WRAPBUTTONS), helpstring("Retrieves or sets whether buttons may be displayed on multiple lines, if the tool bar becomes too narrow to include all buttons on the same line.")]
		HRESULT WrapButtons([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TB_WRAPBUTTONS), helpstring("Retrieves or sets whether buttons may be displayed on multiple lines, if the tool bar becomes too narrow to include all buttons on the same line.")]
		HRESULT WrapButtons([in] VARIANT_BOOL newValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_TB_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Advises the control to resize itself to the best extent</em>
		///
		/// \sa IdealWidth, IdealHeight
		[id(DISPID_TB_AUTOSIZE), helpstring("Advises the control to resize itself to the best extent.")]
		HRESULT AutoSize(void);
		/// \brief <em>Counts the buttons that use the specified character as accelerator character</em>
		///
		/// Retrieves the number of tool bar buttons that use the specified character as accelerator character.
		///
		/// \param[in] accelerator The accelerator character for which to count the buttons.
		///
		/// \return The number of buttons with the specified accelerator character.
		///
		/// \sa IToolBarButton::Text, _IToolBarEvents::MapAccelerator
		[id(DISPID_TB_COUNTACCELERATOROCCURRENCES), helpstring("Retrieves the number of tool bar buttons that use the specified character as accelerator character.")]
		HRESULT CountAcceleratorOccurrences([in] SHORT accelerator, [out, retval] LONG* pCount);
		/// \brief <em>Creates a new \c ToolBarButtonContainer object</em>
		///
		/// Retrieves a new \c ToolBarButtonContainer object and fills it with the specified buttons.
		///
		/// \param[in] buttons The button(s) to add to the collection. May be either \c Empty, a button ID, a
		///            \c ToolBarButton object or a \c ToolBarButtons collection.
		///
		/// \return The created \c ToolBarButtonContainer object.
		///
		/// \sa IToolBarButtonContainer::Clone, IToolBarButtonContainer::Add
		[id(DISPID_TB_CREATEBUTTONCONTAINER), helpstring("Retrieves a new 'ToolBarButtonContainer' object and fills it with 'Buttons'.")]
		HRESULT CreateButtonContainer([in, optional] VARIANT Buttons, [out, retval] IToolBarButtonContainer** ppContainer);
		/// \brief <em>Displays a dialog that allows customizing the tool bar</em>
		///
		/// \sa AllowCustomization, DragDropCustomizationModifierKey, _IToolBarEvents::QueryInsertButton,
		///     _IToolBarEvents::CustomizedControl
		[id(DISPID_TB_CUSTOMIZE), helpstring("Displays a dialog that allows customizing the tool bar.")]
		HRESULT Customize(void);
		/// \brief <em>Creates and displays a popup window with the hidden tool bar buttons</em>
		///
		/// Creates a popup window that contains the tool bar buttons that are currently not visible and
		/// displays this window at the specified location.
		///
		/// \param[in] x The x-coordinate (in pixels relative to the screen's upper-left corner) at which the
		///            popup window will be displayed.
		/// \param[in] y The y-coordinate (in pixels relative to the screen's upper-left corner) at which the
		///            popup window will be displayed.
		///
		/// \sa _IReBarEvents::ChevronClick
		[id(DISPID_TB_DISPLAYCHEVRONPOPUPWINDOW), helpstring("Creates a popup window that contains the tool bar buttons that are currently not visible and displays this window at the specified location.")]
		HRESULT DisplayChevronPopupWindow([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y);
		/// \brief <em>Proposes a position for the control's insertion mark</em>
		///
		/// Retrieves the insertion mark position that is closest to the specified point.
		///
		/// \param[in] x The x-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point for which to retrieve the closest
		///            insertion mark position. It must be relative to the control's upper-left corner.
		/// \param[out] relativePosition The insertion mark's position relative to the specified button. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] toolButton The button at which the insertion mark should be displayed.
		/// \param[out] isOverButton If \c True, the specified position is over or near the button specified
		///             by \c toolButton; otherwise it is over the control's background or outside the
		///             control's client area.
		///
		/// \remarks If \c toolButton is not \c Nothing, but \c relativePosition is \c impNowhere, the
		///          specified position is directly over the button specified by \c toolButton.
		///
		/// \sa SetInsertMarkPosition, GetInsertMarkPosition, InsertMarkPositionConstants
		[id(DISPID_TB_GETCLOSESTINSERTMARKPOSITION), helpstring("Retrieves the insertion mark position that is closest to the specified point.")]
		HRESULT GetClosestInsertMarkPosition([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] InsertMarkPositionConstants* relativePosition, [in, out] IToolBarButton** toolButton, [in, out, defaultvalue(0)] VARIANT_BOOL* isOverButton);
		/// \brief <em>Retrieves the command ID that is registered for the specified shortcut key combination</em>
		///
		/// Retrieves the command ID that has been registered for the specified shortcut key combination.
		///
		/// \param[in] modifierKeys Specifies which modifier keys must be pressed to trigger the command. Any
		///            combination of the values specified by the \c ModifierKeysConstants enumeration is
		///            valid.
		/// \param[in] acceleratorKeyCode Specifies the virtual key code of the key that must be pressed to
		///            trigger the command.
		///
		/// \return The command ID that is triggered if the key combination is pressed. If no command is
		///         registered for the specified hot key, -1 is returned.
		///
		/// \sa RegisterHotkey, UnregisterHotkey, _IToolBarEvents::ExecuteCommand, ModifierKeysConstants
		[id(DISPID_TB_GETCOMMANDFORHOTKEY), helpstring("Retrieves the command ID that has been registered for the specified shortcut key combination.")]
		HRESULT GetCommandForHotkey([in] ModifierKeysConstants modifierKeys, [in] SHORT acceleratorKeyCode, [out, retval] LONG* pCommandID);
		/// \brief <em>Retrieves the position of the control's insertion mark</em>
		///
		/// \param[out] relativePosition The insertion mark's position relative to the specified button. The
		///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
		///             valid: \c impBefore, \c impAfter, \c impNowhere.
		/// \param[out] toolButton The button at which the insertion mark is displayed.
		///
		/// \sa SetInsertMarkPosition, GetClosestInsertMarkPosition, InsertMarkPositionConstants
		[id(DISPID_TB_GETINSERTMARKPOSITION), helpstring("Retrieves the position of the control's insertion mark.")]
		HRESULT GetInsertMarkPosition([in, out] InsertMarkPositionConstants* relativePosition, [in, out] IToolBarButton** toolButton);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in,out] hitTestDetails Receives a value specifying the exact part of the control the
		///                specified point lies in. Any of the values defined by the \c HitTestConstants
		///                enumeration is valid.
		///
		/// \return The tool bar button that the specified point belongs to. \c Nothing, if no button was
		///         "hit".
		///
		/// \sa HitTestChevronToolBar, HitTestConstants
		// \sa HitTestChevronToolBar, ButtonBoundingBoxDefinition, HitTestConstants
		[id(DISPID_TB_HITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] HitTestConstants* hitTestDetails, [out, retval] IToolBarButton** ppHitButton);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the chevron tool bar control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            chevron tool bar control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            chevron tool bar control's upper-left corner.
		/// \param[in,out] hitTestDetails Receives a value specifying the exact part of the control the
		///                specified point lies in. Any of the values defined by the \c HitTestConstants
		///                enumeration is valid.
		///
		/// \return The tool bar button that the specified point belongs to. \c Nothing, if no button was
		///         "hit".
		///
		/// \sa HitTest, HitTestConstants
		// \sa HitTest, ButtonBoundingBoxDefinition, HitTestConstants
		[id(DISPID_TB_HITTESTCHEVRONTOOLBAR), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTestChevronToolBar([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] HitTestConstants* hitTestDetails, [out, retval] IToolBarButton** ppHitButton);
		/// \brief <em>Loads a system's default image list</em>
		///
		/// Loads one of the system's default image lists, so that the images can be used as button images.
		/// For valid predefined image indexes see the \c SystemImageIndexConstants enumeration.
		///
		/// \param[in] imageListType The image list to load. Any of the values specified by the
		///            \c SystemImageListTypeConstants enumeration is valid.
		///
		/// \return The number of images that the loaded image list contains.
		///
		/// \sa hImageList, IToolBarButton::IconIndex, SystemImageListTypeConstants, SystemImageIndexConstants
		[id(DISPID_TB_LOADDEFAULTIMAGES), helpstring("Loads one of the system's default image lists, so that the images can be used as button images.")]
		HRESULT LoadDefaultImages([in] SystemImageListTypeConstants imageListType, [out, retval] LONG* pImageCount);
		/// \brief <em>Loads the control's settings from the specified file</em>
		///
		/// \param[in] file The file to read from.
		///
		/// \return \c True if the settings could be loaded; otherwise \c False.
		///
		/// \sa SaveSettingsToFile, LoadToolBarStateFromRegistry
		[id(DISPID_TB_LOADSETTINGSFROMFILE), helpstring("Loads the control's settings from the specified file.")]
		HRESULT LoadSettingsFromFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Loads the control's state from the specified value in the registry</em>
		///
		/// \param[in] subKeyName The name of the sub key (relative to \c hParentKey) in the registry where to
		///            load the tool bar state from.
		/// \param[in] valueName The name of the registry value where to load the tool bar state from.
		/// \param[in] hParentKey The handle of the parent key of \c subKeyName. By default this is
		///            \c HKEY_CURRENT_USER.
		///
		/// \return \c True if the state could be loaded; otherwise \c False.
		///
		/// \sa SaveToolBarStateToRegistry, LoadSettingsFromFile
		[id(DISPID_TB_LOADTOOLBARSTATEFROMREGISTRY), helpstring("Loads the control's state from the specified value in the registry.")]
		HRESULT LoadToolBarStateFromRegistry([in] BSTR subKeyName, [in] BSTR valueName, [in, defaultvalue(0x80000001)] OLE_HANDLE hParentKey, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Enters OLE drag'n'drop mode</em>
		///
		/// \param[in] pDataObject A pointer to the \c IDataObject implementation to use during OLE
		///            drag'n'drop. If not specified, the control's own implementation is used.
		/// \param[in] supportedEffects A bit field defining all drop effects you want to support. Any
		///            combination of the values defined by the \c OLEDropEffectConstants enumeration
		///            (except \c odeScroll) is valid.
		/// \param[in] hWndToAskForDragImage The handle of the window, that will receive the
		///            \c DI_GETDRAGIMAGE message to specify the drag image to use. If -1, the control
		///            creates the drag image itself. If \c SupportOLEDragImages is set to \c False, no
		///            drag image is used.
		/// \param[in] draggedButtons A collection object containing the buttons to drag. This parameter is
		///            used to generate the drag image, if \c hWndToAskForDragImage is set to -1.
		/// \param[in] itemCountToDisplay The number to display in the item count label of Aero drag images.
		///            If set to 0 or 1, no item count label is displayed. If set to -1, the number of buttons
		///            contained in the \c draggedButtons collection is displayed in the item count label. If
		///            set to any value larger than 1, this value is displayed in the item count label.
		///
		/// \return The performed drop effect. Any of the values defined by the \c OLEDropEffectConstants
		///         enumeration (except \c odeScroll) is valid.
		///
		/// \sa _IToolBarEvents::ButtonBeginDrag, _IToolBarEvents::ButtonBeginRDrag,
		///     _IToolBarEvents::OLEStartDrag, _IToolBarEvents::OLEGiveFeedback,
		///     _IToolBarEvents::OLEQueryContinueDrag, SupportOLEDragImages, OLEDragImageStyle,
		///     OLEDropEffectConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
		[id(DISPID_TB_OLEDRAG), helpstring("Enters OLE drag'n'drop mode.")]
		HRESULT OLEDrag([in, defaultvalue(NULL)] LONG* pDataObject, [in, defaultvalue(odeCopyOrMove)] OLEDropEffectConstants supportedEffects, [in, defaultvalue(-1)] OLE_HANDLE hWndToAskForDragImage, [in, defaultvalue(NULL)] IToolBarButtonContainer* draggedButtons, [in, defaultvalue(-1)] LONG itemCountToDisplay, [out, retval] OLEDropEffectConstants* pPerformedEffects);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_TB_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		/// \brief <em>Connects a command ID with a shortcut key combination</em>
		///
		/// Connects a command ID with a shortcut key combination so that pressing the key combination triggers
		/// the command.
		///
		/// \param[in] modifierKeys Specifies which modifier keys must be pressed to trigger the command. Any
		///            combination of the values specified by the \c ModifierKeysConstants enumeration is
		///            valid.
		/// \param[in] acceleratorKeyCode Specifies the virtual key code of the key that must be pressed to
		///            trigger the command.
		/// \param[in] commandID Specifies the command to trigger if the key combination is pressed. If the
		///            command is triggered, the \c ExecuteCommand event is fired.
		///
		/// \sa UnregisterHotkey, GetCommandForHotkey, _IToolBarEvents::ExecuteCommand, ModifierKeysConstants
		[id(DISPID_TB_REGISTERHOTKEY), helpstring("Connects a command ID with a shortcut key combination so that pressing the key combination triggers the command.")]
		HRESULT RegisterHotkey([in] ModifierKeysConstants modifierKeys, [in] SHORT acceleratorKeyCode, [in] LONG commandID);
		/// \brief <em>Saves the control's settings to the specified file</em>
		///
		/// \param[in] file The file to write to.
		///
		/// \return \c True if the settings could be saved; otherwise \c False.
		///
		/// \sa LoadSettingsFromFile, SaveToolBarStateToRegistry
		[id(DISPID_TB_SAVESETTINGSTOFILE), helpstring("Saves the control's settings to the specified file.")]
		HRESULT SaveSettingsToFile([in] BSTR file, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Saves the control's state to the specified value in the registry</em>
		///
		/// \param[in] subKeyName The name of the sub key (relative to \c hParentKey) in the registry where to
		///            store the tool bar state.
		/// \param[in] valueName The name of the registry value where to store the tool bar state.
		/// \param[in] hParentKey The handle of the parent key of \c subKeyName. By default this is
		///            \c HKEY_CURRENT_USER.
		///
		/// \return \c True if the state could be saved; otherwise \c False.
		///
		/// \sa LoadToolBarStateFromRegistry, SaveSettingsToFile,
		///     _IToolBarEvents::InitializeToolBarStateRegistryStorage
		[id(DISPID_TB_SAVETOOLBARSTATETOREGISTRY), helpstring("Saves the control's state to the specified value in the registry.")]
		HRESULT SaveToolBarStateToRegistry([in] BSTR subKeyName, [in] BSTR valueName, [in, defaultvalue(0x80000001)] OLE_HANDLE hParentKey, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Sets the number of rows used to display the tool bar buttons</em>
		///
		/// Sets the number of rows used to display the tool bar buttons.
		///
		/// \param[in] rowCount The number of rows that the control shall display the tool bar buttons in.
		/// \param[in] allowMoreRows If set to \c True, the control is allowed to create more rows than
		///            specified by \c rowCount, for instance if the control's width is too small to display
		///            all buttons with the specified number of rows. If set to \c False, the control won't
		///            create more rows than specified.
		/// \param[out] controlWidth Receives the control's width (in pixels) after the buttons have been
		///             reorganized.
		/// \param[out] controlHeight Receives the control's height (in pixels) after the buttons have been
		///             reorganized.
		///
		/// \remarks The control does not break button groups, therefore the resulting number of rows might be
		///          different than specified.
		///
		/// \sa ButtonRowCount, WrapButtons, IToolBarButton::FollowedByLineBreak
		[id(DISPID_TB_SETBUTTONROWCOUNT), helpstring("Sets the number of rows used to display the tool bar buttons.")]
		HRESULT SetButtonRowCount([in] LONG rowCount, [in, defaultvalue(-1)] VARIANT_BOOL allowMoreRows, [in, out, defaultvalue(0)] OLE_XSIZE_PIXELS* controlWidth, [in, out, defaultvalue(0)] OLE_YSIZE_PIXELS* controlHeight);
		/// \brief <em>Sets the control's hot button</em>
		///
		/// Sets the control's hot button. The hot button is the button under the mouse cursor. If set to
		/// \c Nothing, the control does not have a hot button.\n
		/// Other than the \c HotButton property, this method allows specifying additional parameters and
		/// returns the previous hot button.
		///
		/// \param[in] newHotButton The tool bar button to set as the control's hot button. If \c Nothing,
		///            the control's hot button is cleared.
		/// \param[in] hotButtonChangeReason The reason for changing the hot button. This value is passed to
		///            the \c HotButtonChanging event. Any combination of the values defined by the
		///            \c HotButtonChangingCausedByConstants enumeration is valid.
		/// \param[in] additionalInfo Additional information describing the change of the hot button. This
		///            value is passed to the \c HotButtonChanging event. Any combination of the values defined
		///            by the \c HotButtonChangingAdditionalInfoConstants enumeration is valid.
		///
		/// \return The control's previous hot button. This may be \c Nothing.
		///
		/// \remarks This method fails if the \c ButtonStyle property is set to \c bst3D.\n
		///          Specifying the \c hbcaiDoDropDownClick flag in the \c additionalInfo parameter causes
		///          a programmatic click on the new hot button's drop-down arrow.
		///
		/// \sa HotButton, ButtonStyle, _IToolBarEvents::HotButtonChanging, HotButtonChangingCausedByConstants,
		///     HotButtonChangingAdditionalInfoConstants, IToolBarButton::DropDownStyle
		[id(DISPID_TB_SETHOTBUTTON), helpstring("Sets the control's hot button. The hot button is the button under the mouse cursor. If set to 'Nothing', the control does not have a hot button. This method fails if the 'ButtonStyle' property is set to 'bst3D'.")]
		HRESULT SetHotButton([in] IToolBarButton* newHotButton, [in, defaultvalue(hbccbOther)] HotButtonChangingCausedByConstants hotButtonChangeReason, [in, defaultvalue(0)] HotButtonChangingAdditionalInfoConstants additionalInfo, [out, retval] IToolBarButton** ppPreviousHotButton);
		/// \brief <em>Sets the position of the control's insertion mark</em>
		///
		/// \param[in] relativePosition The insertion mark's position relative to the specified button. Any
		///            of the values defined by the \c InsertMarkPositionConstants enumeration is valid.
		/// \param[in] toolButton The button at which to show the insertion mark. If set to \c Nothing, the
		///            insertion mark is removed.
		///
		/// \sa GetInsertMarkPosition, GetClosestInsertMarkPosition, InsertMarkColor, RegisterForOLEDragDrop,
		///     InsertMarkPositionConstants
		[id(DISPID_TB_SETINSERTMARKPOSITION), helpstring("Sets the position of the control's insertion mark.")]
		HRESULT SetInsertMarkPosition([in] InsertMarkPositionConstants relativePosition, [in] IToolBarButton* toolButton);
		/// \brief <em>Disconnects a command ID from a shortcut key combination</em>
		///
		/// Removes the connection of a shortcut key combination with a command ID so that pressing the key
		/// combination no longer triggers the command.
		///
		/// \param[in] modifierKeys Specifies which modifier keys must be pressed to trigger the command. Any
		///            combination of the values specified by the \c ModifierKeysConstants enumeration is
		///            valid.
		/// \param[in] acceleratorKeyCode Specifies the virtual key code of the key that must be pressed to
		///            trigger the command.
		///
		/// \sa RegisterHotkey, GetCommandForHotkey, ModifierKeysConstants
		[id(DISPID_TB_UNREGISTERHOTKEY), helpstring("Removes the connection of a shortcut key combination with a command ID so that pressing the key combination no longer triggers the command.")]
		HRESULT UnregisterHotkey([in] ModifierKeysConstants modifierKeys, [in] SHORT acceleratorKeyCode);

		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IToolBarEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_TB_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
	};


	/// \interface _IToolBarEvents
	/// \brief <em>The \c ToolBar class' events interface</em>
	///
	/// This interface defines all events the \c ToolBar class may raise.
	///
	/// \sa IToolBar
	[
		uuid(BBC1B128-44A5-4b7f-9DD0-86D93DBC28F4),
		helpstring("IToolBar-event-interface")
	]
	dispinterface _IToolBarEvents
	{
		properties:
		methods:
			/// \brief <em>The user wants to execute a command</em>
			///
			/// Will be fired if the user wants to execute the command associated with a button or menu item.
			///
			/// \param[in] commandID The unique ID of the command that shall be executed.
			/// \param[in] toolButton The tool bar button whose associated command shall be executed. May be
			///            \c Nothing.
			/// \param[in] commandOrigin Specifies whether the command was triggered by a button, a menu item or
			///            a hotkey. Any of the values defined by the \c CommandOriginConstants enumeration is
			///            valid.
			/// \param[in,out] forwardMessage If set to \c True, the command will be forwarded to the parent
			///                top-level window; otherwise not.
			///
			/// \remarks This is the control's default event.
			///
			/// \sa Click, DropDown, CommandOriginConstants
			// \sa ButtonSelectionStateChanged, Click, DropDown, CommandOriginConstants
			[id(DISPID_TBE_EXECUTECOMMAND), helpstring("Will be fired if the user wants to execute the command associated with a button or menu item.")]
			void ExecuteCommand(LONG commandID, IToolBarButton* toolButton, CommandOriginConstants commandOrigin, VARIANT_BOOL* forwardMessage);
			/// \brief <em>The chevron popup is about to be displayed</em>
			///
			/// Will be fired before the control's chevron popup is displayed. If the control is in menu mode,
			/// the popup will be a popup menu; otherwise the popup will be a vertical tool bar control.
			///
			/// \param[in] hPopup The handle of popup. In menu mode, this is the handle of the chevron popup
			///            menu; otherwise this is the window handle of the popup tool bar.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            screen's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            screen's upper-left corner.
			/// \param[in] isMenu If \c True, the handle specified by \c hPopup is a menu handle; otherwise it is
			///            a window handle.
			/// \param[out] cancelPopup If set to \c True, the popup won't be displayed.
			/// \param[out] commandToExecute If the popup is canceled, this parameter can be set to the unique ID
			///             of a command that will be executed. If set to \c 0, no command will be executed.
			///
			/// \sa DestroyingChevronPopup, IToolBar::DisplayChevronPopupWindow, IToolBar::MenuMode
			[id(DISPID_TBE_BEFOREDISPLAYCHEVRONPOPUP), helpstring("Will be fired before the control's chevron popup is displayed.")]
			void BeforeDisplayChevronPopup(LONG hPopup, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, VARIANT_BOOL isMenu, VARIANT_BOOL* cancelPopup, LONG* commandToExecute);
			/// \brief <em>The user is beginning costumizing the tool bar</em>
			///
			/// Will be fired if the user is beginning customizing the tool bar.
			///
			/// \param[in] restoringFromRegistry If \c True, the event was fired, because the control's state is
			///            being restored from the registry.
			/// \param[in,out] dontRestoreFromRegistry If set to \c True, the data stored in the registry will be
			///                ignored when restoring the control's state; otherwise it will be used. This
			///                parameter will be ignored if \c restoringFromRegistry is set to \c False.
			///
			/// \sa InitializeCustomizationDialog, EndCustomization, QueryInsertButton, QueryRemoveButton,
			///     InitializeToolBarStateRegistryRestorage, IToolBar::AllowCustomization, IToolBar::Customize,
			///     IToolBar::LoadToolBarStateFromRegistry
			[id(DISPID_TBE_BEGINCUSTOMIZATION), helpstring("Will be fired if the user is beginning customizing the tool bar.")]
			void BeginCustomization(VARIANT_BOOL restoringFromRegistry, VARIANT_BOOL* dontRestoreFromRegistry);
			/// \brief <em>The user seems to want to drag a tool bar button</em>
			///
			/// Will be fired if the user seems to want to drag a tool bar button using the left mouse button.
			///
			/// \param[in] toolButton The button that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbLeftButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IToolBar::OLEDrag, ButtonBeginRDrag, HitTestConstants
			[id(DISPID_TBE_BUTTONBEGINDRAG), helpstring("Will be fired if the user seems to want to drag a tool bar button using the left mouse button.")]
			void ButtonBeginDrag(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user seems to want to drag a tool bar button</em>
			///
			/// Will be fired if the user seems to want to drag a tool bar button using the right mouse button.
			///
			/// \param[in] toolButton The button that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbRightButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IToolBar::OLEDrag, ButtonBeginDrag, HitTestConstants
			[id(DISPID_TBE_BUTTONBEGINRDRAG), helpstring("Will be fired if the user seems to want to drag a tool bar button using the right mouse button.")]
			void ButtonBeginRDrag(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The value of a button's property is required</em>
			///
			/// Will be fired if a button property was set-up to use a callback and now this property's value is
			/// required.
			///
			/// \param[in] toolButton The button that the value is required for.
			/// \param[in] requestedInfo Specifies which properties' values are required. Any combination of
			///            the values defined by the \c RequestedInfoConstants enumeration is valid.
			/// \param[out] iconIndex Set this parameter to the zero-based index of the icon to use for the
			///             specified button. The icon is taken from the image lists specified by the
			///             \c imageListIndex parameter. If the \c requestedInfo parameter doesn't include
			///             \c riIconIndex, this value is ignored.
			/// \param[out] imageListIndex Set this parameter to the zero-based index of the control's image
			///             lists that the specified icon is taken from. If the \c requestedInfo parameter
			///             doesn't include \c riIconIndex, this value is ignored.
			/// \param[in] maxButtonTextLength The maximum number of characters the button's text may consist of.
			///            If the \c requestedInfo parameter doesn't include \c riButtonText, this value is
			///            ignored.
			/// \param[out] buttonText Set this parameter to the text to use for the specified button. If the
			///             \c requestedInfo parameter doesn't include \c riButtonText, this value is ignored.
			/// \param[in,out] dontAskAgain If set to \c True, this event won't be fired again for the
			///                specified button. Instead the specified values will be persisted.
			///
			/// \remarks Current versions of Windows don't seem to support callbacks for button texts, hence the
			///          \c maxButtonTextLength and \c buttonText parameters are not used.
			///
			/// \sa IToolBarButton::IconIndex, IToolBarButton::ImageListIndex, IToolBar::hImageList,
			///     IToolBarButton::Text, RequestedInfoConstants
			[id(DISPID_TBE_BUTTONGETDISPLAYINFO), helpstring("Will be fired if a button property was set-up to use a callback and now this property's value is required.")]
			void ButtonGetDisplayInfo(IToolBarButton* toolButton, RequestedInfoConstants requestedInfo, LONG* IconIndex, LONG* ImageListIndex, LONG maxButtonTextLength, BSTR* buttonText, VARIANT_BOOL* dontAskAgain);
			/// \brief <em>The drop-down menu of a button in menu mode is required</em>
			///
			/// Will be fired in menu mode, if the handle of a button's drop-down menu is required.
			///
			/// \param[in] toolButton The button that the menu is required for.
			/// \param[out] hMenu Set this parameter to the handle of the popup menu.
			///
			/// \remarks This event won't be raised if the \c MenuMode property is set to \c False.
			///
			/// \sa IToolBar::MenuMode, DropDown
			[id(DISPID_TBE_BUTTONGETDROPDOWNMENU), helpstring("Will be fired in menu mode, if the handle of a button's drop-down menu is required.")]
			void ButtonGetDropDownMenu(IToolBarButton* toolButton, LONG* hMenu);
			/// \brief <em>The control is about to show the button's info tip and the text to display is required</em>
			///
			/// Will be fired if the control is about to popup a tooltip to display some information about the
			/// specified button and requests the text to display.
			///
			/// \param[in] toolButton The button that the tooltip will be displayed for.
			/// \param[in] maxInfoTipLength The maximum number of characters the info tip text may consist of.
			/// \param[out] infoTipText Set this parameter to the text to display in the tooltip control.
			/// \param[in,out] abortToolTip If set to \c True, the tooltip won't be displayed.
			///
			/// \sa IToolBar::ShowToolTips, IToolBarButton::Text
			[id(DISPID_TBE_BUTTONGETINFOTIPTEXT), helpstring("Will be fired if the control is about to popup a tooltip to display some information about the specified button and requests the text to display.")]
			void ButtonGetInfoTipText(IToolBarButton* toolButton, LONG maxInfoTipLength, BSTR* infoTipText, VARIANT_BOOL* abortToolTip);
			/// \brief <em>The mouse cursor was moved into a button's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor into the specified tool bar button's bounding
			/// rectangle.
			///
			/// \param[in] toolButton The tool bar button that was entered.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ButtonMouseLeave, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IToolBar::DisabledEvents
			[id(DISPID_TBE_BUTTONMOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the specified tool bar button's bounding rectangle. This event may be disabled.")]
			void ButtonMouseEnter(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of a button's bounding rectangle</em>
			///
			/// Will be fired if the user moved the mouse cursor out of the specified tool bar button's bounding
			/// rectangle.
			///
			/// \param[in] toolButton The tool bar button that was left.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ButtonMouseEnter, MouseMove, HitTestConstants, ExtendedMouseButtonConstants,
			///     IToolBar::DisabledEvents
			[id(DISPID_TBE_BUTTONMOUSELEAVE), helpstring("Will be fired if the user moved the mouse cursor out of the specified tool bar button's bounding rectangle. This event may be disabled.")]
			void ButtonMouseLeave(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			// \brief <em>A tool bar button's selection state was changed</em>
			//
			// Will be fired after a tool bar button's selection state was changed.
			//
			// \param[in] toolButton The tool bar button for which the selection state was changed.
			// \param[in] previousSelectionState The tool bar button's previous selection state.
			// \param[in] newSelectionState The tool bar button's new selection state.
			//
			// \sa ExecuteCommand, SelectionStateConstants, IToolBarButton::SelectionState
			//[id(DISPID_TBE_BUTTONSELECTIONSTATECHANGED), helpstring("Will be fired after a tool bar button's selection state was changed.")]
			//void ButtonSelectionStateChanged(IToolBarButton* toolButton, SelectionStateConstants previousSelectionState, SelectionStateConstants newSelectionState);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] toolButton The tool bar button that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, HitTestConstants, IToolBar::DisabledEvents
			[id(DISPID_TBE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed.
			///
			/// \param[in] toolButton The tool bar button the context menu refers to. Will be \c Nothing if the
			///            context menu should be displayed for the whole control instead of only for a single
			///            button.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the menu's proposed position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \sa RClick, IToolBar::ProcessContextMenuKeys, HitTestConstants
			[id(DISPID_TBE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed.")]
			void ContextMenu(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>Custom drawing should be done here</em>
			///
			/// Will be fired after the control processed a \c NM_CUSTOMDRAW notification allowing custom
			/// drawing of the control's content.
			///
			/// \param[in] toolButton The tool bar button that the notification refers to. May be \c Nothing.
			/// \param[in,out] normalTextColor The color to draw the button's text in if the button is neither
			///                in hot nor in marked state.
			/// \param[in,out] normalButtonBackColor The color to fill the button's background with if the button
			///                is neither in hot nor in marked state.
			/// \param[in,out] normalBackgroundMode Specifies how to draw the background of the button's text if
			///                the button is neither in hot nor in marked state. Any of the values defined by the
			///                \c StringBackgroundModeConstants enumeration are valid.
			/// \param[in,out] hotTextColor The color to draw the button's text in if the button is in hot state.
			/// \param[in,out] hotButtonBackColor The color to fill the button's background with if the button
			///                is in hot state.
			/// \param[in,out] markedTextBackColor The color to draw the button's text background in if the
			///                button is in marked state.
			/// \param[in,out] markedButtonBackColor The color to fill the button's background with if the button
			///                is in marked state.
			/// \param[in,out] markedBackgroundMode Specifies how to draw the background of the button's text if
			///                the button is in marked state. Any of the values defined by the
			///                \c StringBackgroundModeConstants enumeration are valid.
			/// \param[in] drawStage The stage of custom drawing this event is raised for. Most of the values
			///            defined by the \c CustomDrawStageConstants enumeration are valid.
			/// \param[in] buttonState The tool bar button's current state (focused, selected etc.). Most of
			///            the values defined by the \c CustomDrawItemStateConstants enumeration are valid.
			/// \param[in] hDC The handle of the device context in which all drawing should take place.
			/// \param[in] drawingRectangle The bounding rectangle of the area that must be drawn.
			/// \param[in,out] textRectangle The bounding rectangle of the button's text. The \c Right and
			///                \c Bottom members may be changed by the application.
			/// \param[in,out] horizontalIconCaptionGap Specifies the number of pixels in horizontal direction
			///                between the button's icon and its text.
			/// \param[in,out] furtherProcessing Controls further drawing. Most of the values defined by the
			///                \c CustomDrawReturnValuesConstants enumeration are valid.
			///
			/// \remarks The \c horizontalIconCaptionGap parameter is ignored, if the \c ButtonTextPosition
			///          property is set to a value other than \c btpRightToIcon.\n
			///          The \c horizontalIconCaptionGap parameter requires comctl32.dll version 6.0 or higher.\n
			///          This event may be disabled.
			///
			/// \sa RECTANGLE, CustomDrawStageConstants, CustomDrawItemStateConstants,
			///     CustomDrawReturnValuesConstants, IToolBar::HotButton, IToolBarButton::Marked,
			///     IToolBar::ButtonTextPosition, IToolBar::DisabledEvents,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb760492.aspx">NM_CUSTOMDRAW (tool bar)</a>
			[id(DISPID_TBE_CUSTOMDRAW), helpstring("Will be fired after the control processed a 'NM_CUSTOMDRAW' notification allowing custom drawing of the control's content. This event may be disabled.")]
			void CustomDraw(IToolBarButton* toolButton, OLE_COLOR* normalTextColor, OLE_COLOR* normalButtonBackColor, StringBackgroundModeConstants* normalBackgroundMode, OLE_COLOR* hotTextColor, OLE_COLOR* hotButtonBackColor, OLE_COLOR* markedTextBackColor, OLE_COLOR* markedButtonBackColor, StringBackgroundModeConstants* markedBackgroundMode, CustomDrawStageConstants drawStage, CustomDrawItemStateConstants buttonState, LONG hDC, RECTANGLE* drawingRectangle, RECTANGLE* textRectangle, OLE_XSIZE_PIXELS* HorizontalIconCaptionGap, CustomDrawReturnValuesConstants* furtherProcessing);
			/// \brief <em>The user has customized the tool bar</em>
			///
			/// Will be fired if the user has customized the tool bar.
			///
			/// \sa BeginCustomization, EndCustomization, IToolBar::AllowCustomization, IToolBar::Customize
			[id(DISPID_TBE_CUSTOMIZEDCONTROL), helpstring("Will be fired if the user has customized the tool bar.")]
			void CustomizedControl(void);
			/// \brief <em>The user is removing a button using the customization features</em>
			///
			/// Will be fired if the user is removing a tool bar button using the built-in customization
			/// dialog.
			///
			/// \param[in] toolButton The tool bar button that is being removed.
			///
			/// \sa FreeButtonData, QueryRemoveButton, IToolBar::Customize, IToolBarButtons::Remove
			[id(DISPID_TBE_CUSTOMIZEDIALOGREMOVINGBUTTON), helpstring("Will be fired if the user is removing a tool bar button using the built-in customization dialog.")]
			void CustomizeDialogRemovingButton(IToolBarButton* toolButton);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] toolButton The tool bar button that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, HitTestConstants, IToolBar::DisabledEvents
			[id(DISPID_TBE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IToolBar::hWnd
			[id(DISPID_TBE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>The chevron popup is about to be destroyed</em>
			///
			/// Will be fired before the control's chevron popup is destroyed. If the control is in menu mode,
			/// the popup will be a popup menu; otherwise the popup will be a vertical tool bar control.
			///
			/// \param[in] hPopup The handle of popup. In menu mode, this is the handle of the chevron popup
			///            menu; otherwise this is the window handle of the popup tool bar.
			/// \param[in] isMenu If \c True, the handle specified by \c hPopup is a menu handle; otherwise it is
			///            a window handle.
			///
			/// \sa BeforeDisplayChevronPopup, IToolBar::DisplayChevronPopupWindow, IToolBar::MenuMode
			[id(DISPID_TBE_DESTROYINGCHEVRONPOPUP), helpstring("Will be fired before the control's chevron popup is destroyed.")]
			void DestroyingChevronPopup(LONG hPopup, VARIANT_BOOL isMenu);
			/// \brief <em>The user clicked the customization dialog's help button</em>
			///
			/// Will be fired if the user clicked the help button in the customization dialog.
			///
			/// \sa InitializeCustomizationDialog, IToolBar::AllowCustomization, IToolBar::Customize
			[id(DISPID_TBE_DISPLAYCUSTOMIZATIONHELP), helpstring("Will be fired if the user clicked the help button in the customization dialog.")]
			void DisplayCustomizationHelp(void);
			/// \brief <em>The user clicked a button's drop-down arrow</em>
			///
			/// Will be fired if the user wants to display a drop-down button's drop-down menu.
			///
			/// \param[in] toolButton The tool bar button whose drop-down menu shall be displayed.
			/// \param[in] buttonRectangle The tool bar button's bounding rectangle in coordinates relative to
			///            the control's upper-left corner.
			/// \param[in,out] furtherProcessing Controls further processing of the user input. Any of the values
			///                defined by the \c DropDownReturnValuesConstants enumeration is valid.
			///
			/// \sa ExecuteCommand, Click, RECTANGLE, DropDownReturnValuesConstants
			[id(DISPID_TBE_DROPDOWN), helpstring("Will be fired if the user wants to display a drop-down button's drop-down menu.")]
			void DropDown(IToolBarButton* toolButton, RECTANGLE* buttonRectangle, DropDownReturnValuesConstants* furtherProcessing);
			/// \brief <em>The user has stopped costumizing the tool bar</em>
			///
			/// Will be fired if the user has stopped customizing the tool bar.
			///
			/// \sa BeginCustomization, CustomizedControl, IToolBar::AllowCustomization, IToolBar::Customize
			[id(DISPID_TBE_ENDCUSTOMIZATION), helpstring("Will be fired if the user has stopped customizing the tool bar.")]
			void EndCustomization(void);
			/// \brief <em>Any data associated with a tool bar button should be freed</em>
			///
			/// Will be fired if any data associated with the specified tool bar button should be freed.
			///
			/// \param[in] toolButton The tool bar button for which to free the data. If \c Nothing, all buttons'
			///            associated data shall be removed.
			///
			/// \remarks On program termination the application probably won't receive this event anymore,
			///          because Visual Basic shuts down the event receiver too early. So if you use this
			///          event to free any data, you should also add an event handler for \c Form_Unload (or
			///          similar) in which you iterate all buttons freeing their associated data.\n
			///          This event may be disabled.
			///
			/// \sa RemovingButton, RemovedButton, IToolBarButton::ButtonData, IToolBar::DisabledEvents
			[id(DISPID_TBE_FREEBUTTONDATA), helpstring("Will be fired if any data associated with the specified tool bar button should be freed. This event may be disabled.")]
			void FreeButtonData(IToolBarButton* toolButton);
			/// \brief <em>A tool bar button is about to be loaded into the customization dialog</em>
			///
			/// Will be fired if the control's built-in customization features collect all tool bar buttons that
			/// the application can provide.
			///
			/// \param[in] toolButton The tool bar button that is being requested. The application needs to set
			///            the object's properties.
			/// \param[in,out] noMoreButtons If set to \c True, the button specified by \c toolButton is the last
			///                button and the event won't be fired for any further buttons; otherwise the event
			///                will be fired once more to request the next button.
			///
			/// \remarks Due to implementation details inside the native tool bar control, the control won't use
			///          the text specified by the handler of this event, if the control is configured to send
			///          ANSI notification messages instead of Unicode to its parent window. Instead the
			///          \c ButtonGetDisplayInfo event will be fired to retrieve the button text.\n
			///          To avoid this scenario, make the control send Unicode notification messages. The first
			///          step is to use the Unicode version of the control. If the parent window itself also is a
			///          Unicode window, nothing more needs to be done. If the parent window is an ANSI window
			///          (like a VB6 Form or PictureBox), subclass it and make the control send a new
			///          \c WM_NOTIFYFORMAT message to its parent. See the VB6 samples for details.
			///
			/// \sa QueryInsertButton, BeginCustomization, EndCustomization, IToolBar::AllowCustomization,
			///     IToolBar::Customize, IVirtualToolBarButton, ButtonGetDisplayInfo
			[id(DISPID_TBE_GETAVAILABLEBUTTON), helpstring("Will be fired if the control's built-in customization features collect all tool bar buttons that the application can provide.")]
			void GetAvailableButton(IVirtualToolBarButton* toolButton, VARIANT_BOOL* noMoreButtons);
			/// \brief <em>The control's hot button is about to change</em>
			///
			/// Will be fired before the control's hot button is changed from the last tool bar button to the
			/// first or from the first tool bar button to the last. The hot button is the button under the mouse
			/// cursor.
			///
			/// \param[in] previousHotButton The previous hot button. May be \c Nothing.
			/// \param[in] wrappingDirection The direction into which the hot button will be changed. Any of the
			///            values defined by the \c WrappingDirectionConstants enumeration is valid.
			/// \param[in] causedBy The reason for the hot button change. Any combination of the values defined
			///            by the \c HotButtonChangingCausedByConstants enumeration is valid.
			/// \param[in,out] cancelChange If set to \c True, the hot button change is aborted, i. e. the
			///                current hot button remains the hot button. If set to \c False, the hot button
			///                change continues. Before it is completed, the \c HotButtonChanging event will be
			///                fired.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa HotButtonChanging, IToolBar::HotButton, IToolBar::DisabledEvents, WrappingDirectionConstants,
			///     HotButtonChangingCausedByConstants
			[id(DISPID_TBE_HOTBUTTONCHANGEWRAPPING), helpstring("Will be fired before the control's hot button is changed from the last tool bar button to the first or from the first tool bar button to the last. The hot button is the button under the mouse cursor. This event may be disabled.")]
			void HotButtonChangeWrapping(IToolBarButton* previousHotButton, WrappingDirectionConstants wrappingDirection, HotButtonChangingCausedByConstants causedBy, VARIANT_BOOL* cancelChange);
			/// \brief <em>The control's hot button is about to change</em>
			///
			/// Will be fired before another button becomes the control's hot button. The hot button is the
			/// button under the mouse cursor.
			///
			/// \param[in] previousHotButton The previous hot button. May be \c Nothing.
			/// \param[in] newHotButton The new hot button. May be \c Nothing.
			/// \param[in] causedBy The reason for the hot button change. Any combination of the values defined
			///            by the \c HotButtonChangingCausedByConstants enumeration is valid.
			/// \param[in] additionalInfo Additional information over the hot button change. Any combination of
			///            the values defined by the \c HotButtonChangingAdditionalInfoConstants enumeration is
			///            valid.
			/// \param[in,out] cancelChange If set to \c True, the hot button change is aborted, i. e. the
			///                current hot button remains the hot button. If set to \c False, the hot button
			///                change is completed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa HotButtonChangeWrapping, IToolBar::HotButton, IToolBar::DisabledEvents,
			///     HotButtonChangingCausedByConstants, HotButtonChangingAdditionalInfoConstants
			[id(DISPID_TBE_HOTBUTTONCHANGING), helpstring("Will be fired before another button becomes the control's hot button. The hot button is the button under the mouse cursor. This event may be disabled.")]
			void HotButtonChanging(IToolBarButton* previousHotButton, IToolBarButton* newHotButton, HotButtonChangingCausedByConstants causedBy, HotButtonChangingAdditionalInfoConstants additionalInfo, VARIANT_BOOL* cancelChange);
			/// \brief <em>The costumization dialog is about to be displayed</em>
			///
			/// Will be fired if the user is beginning customizing the tool bar and the customization dialog is
			/// being initialized.
			///
			/// \param[in] hCustomizationDialog The window handle of the customization dialog.
			/// \param[in,out] displayHelpButton If set to \c True, the customization dialog will have a help
			///                button; otherwise not.
			///
			/// \sa BeginCustomization, EndCustomization, DisplayCustomizationHelp, IToolBar::AllowCustomization,
			///     IToolBar::Customize
			[id(DISPID_TBE_INITIALIZECUSTOMIZATIONDIALOG), helpstring("Will be fired if the user is beginning customizing the tool bar and the customization dialog is being initialized.")]
			void InitializeCustomizationDialog(LONG hCustomizationDialog, VARIANT_BOOL* displayHelpButton);
			/// \brief <em>The tool bar state is being restored from a registry value</em>
			///
			/// Will be fired if the control's state is being restored from a binary registry value. This event
			/// can be used to load additional data from the registry value.
			///
			/// \param[in,out] numberOfButtonsToLoad The number of tool bar buttons that will be restored from
			///                the data stream. The client application must ensure that this parameter is set to
			///                the correct value.
			/// \param[in] totalDataSize The total size of the data stream in bytes.
			/// \param[in] perButtonDataSize The number of bytes that hold the control-defined part of a single
			///            button's state. The stream may contain additional application-defined data.
			/// \param[in] pDataStream The memory address where the tool bar state and the application-defined
			///            data are loaded from.
			/// \param[in,out] pStartOfNextDataBlock The (absolute) memory address of the first byte within the
			///                data stream that contains application-defined data. When leaving the event
			///                handler, \c pStartOfNextDataBlock must point to the first byte after the
			///                application-defined data.
			/// \param[in,out] cancelLoading If set to \c True, restoring the tool bar state is aborted;
			///                otherwise not.
			///
			/// \remarks If an application does not need to load additional data when restoring the tool bar
			///          state, it does not need to handle this event.
			///
			/// \sa InitializeToolBarStateRegistryStorage, RestoreButtonFromRegistryStream,
			///     IToolBar::LoadToolBarStateFromRegistry
			[id(DISPID_TBE_INITIALIZETOOLBARSTATEREGISTRYRESTORAGE), helpstring("Will be fired if the control's state is being restored from a binary registry value. This event can be used to load additional data from the registry value.")]
			void InitializeToolBarStateRegistryRestorage(LONG* numberOfButtonsToLoad, LONG totalDataSize, LONG perButtonDataSize, LONG pDataStream, LONG* pStartOfNextDataBlock, VARIANT_BOOL* cancelLoading);
			/// \brief <em>The tool bar state is being stored into a registry value</em>
			///
			/// Will be fired if the control's state is being written to a binary registry value. This event can
			/// be used to store additional data into the registry value.
			///
			/// \param[in,out] numberOfButtonsToSave The number of tool bar buttons that will be saved into the
			///                data stream. The client application must ensure that this parameter is set to the
			///                correct value.
			/// \param[in,out] totalDataSize The total size of the data stream in bytes. The control sets this
			///                parameter to the number of bytes that it needs to store the tool bar state. The
			///                client application must add the number of bytes that it needs to store additional
			///                data.
			/// \param[in,out] pDataStream The memory address where the tool bar state and the
			///                application-defined data will be written to. This memory must be allocated by the
			///                client application and it must be large enough to hold the number of bytes
			///                specified by \c totalDataSize.
			/// \param[in,out] pStartOfUnusedSpace The (absolute) memory address of the first unused byte within
			///                the allocated data stream. After allocating the memory, the application can write
			///                data into it. When leaving the event handler, \c pStartOfUnusedSpace must point to
			///                the first byte that the control can write to without overwriting the
			///                application-defined data.
			///
			/// \remarks If an application does not need to store additional data when storing the tool bar
			///          state, it does not need to handle this event.\n
			///          Memory allocated by the client application must be freed by the client application. This
			///          should be done after the \c SaveToolBarStateToRegistry method returned.
			///
			/// \sa InitializeToolBarStateRegistryRestorage, SaveButtonToRegistryStream,
			///     IToolBar::SaveToolBarStateToRegistry
			[id(DISPID_TBE_INITIALIZETOOLBARSTATEREGISTRYSTORAGE), helpstring("Will be fired if the control's state is being written to a binary registry value. This event can be used to store additional data into the registry value.")]
			void InitializeToolBarStateRegistryStorage(LONG* numberOfButtonsToSave, LONG* totalDataSize, LONG* pDataStream, LONG* pStartOfUnusedSpace);
			/// \brief <em>A tool bar button was inserted</em>
			///
			/// Will be fired after a new tool bar button was inserted.
			///
			/// \param[in] toolButton The tool bar button that was inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertingButton, RemovedButton, IToolBarButton, IToolBar::DisabledEvents
			[id(DISPID_TBE_INSERTEDBUTTON), helpstring("Will be fired after a new tool bar button was inserted. This event may be disabled.")]
			void InsertedButton(IToolBarButton* toolButton);
			/// \brief <em>A tool bar button is about to be inserted</em>
			///
			/// Will be fired before a new tool bar button is inserted.
			///
			/// \param[in] toolButton The tool bar button that is about to be inserted.
			/// \param[in,out] cancelInsertion If set to \c True, insertion is aborted, i. e. the button
			///                isn't inserted. If set to \c False, the band is inserted.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa InsertedButton, RemovingButton, IVirtualToolBarButton, IToolBar::DisabledEvents
			[id(DISPID_TBE_INSERTINGBUTTON), helpstring("Will be fired before a new tool bar button is inserted. This event may be disabled.")]
			void InsertingButton(IVirtualToolBarButton* toolButton, VARIANT_BOOL* cancelInsertion);
			/// \brief <em>A keyboard accelerator mapping needs to be classified as being unique or duplicate</em>
			///
			/// Will be fired if the mapping of a keyboard accelerator to a tool bar button needs to be
			/// classified as being unique or duplicate.
			///
			/// \param[in] accelerator The accelerator character to map.
			/// \param[out] isDuplicate If set to \c VARIANT_TRUE, the accelerator character is mapped to more
			///             than one tool bar button; otherwise not.
			/// \param[out] handledEvent If set to \c True, the control uses the value specified of the
			///             \c isDuplicate parameter. Otherwise the control tries to detect duplicate mappings
			///             itself.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MapAccelerator, IToolBar::DisabledEvents
			[id(DISPID_TBE_ISDUPLICATEACCELERATOR), helpstring("Will be fired if the mapping of a keyboard accelerator to a tool bar button needs to be classified as being unique or duplicate. This event may be disabled.")]
			void IsDuplicateAccelerator(SHORT accelerator, VARIANT_BOOL* isDuplicate, VARIANT_BOOL* handledEvent);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, IToolBar::DisabledEvents
			[id(DISPID_TBE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, IToolBar::DisabledEvents
			[id(DISPID_TBE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, IToolBar::DisabledEvents
			[id(DISPID_TBE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>A keyboard accelerator needs to be mapped to a button</em>
			///
			/// Will be fired if a keyboard accelerator character needs to be mapped to a tool bar button, so
			/// that the control can trigger the execution of the command associated with this button.
			///
			/// \param[in] accelerator The accelerator character to map.
			/// \param[in] startingPointOfSearch The button after which the search shall be started. Usually this
			///            is the current hot button. The \c matchingButton parameter must be set to a button
			///            that has a higher index than this button.
			/// \param[in] resumingSearchWithFirstButton If set to \c True, the control is currently doing
			///            automatic mapping of the accelerator character and has reached the last button and
			///            will continue the search with the first button. The client application has another
			///            chance to provide a custom mapping.
			/// \param[out] matchingButton Must be set to the button to which the accelerator was mapped. This
			///             can also be \c Nothing.
			/// \param[out] handledEvent If set to \c True, the control uses the button specified by the
			///             \c matchingButton parameter. Set this parameter to \c True, if you handle this event,
			///             even if you set \c matchingButton to \c Nothing. Otherwise the control tries to find
			///             a mapping itself.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, KeyPress, ExecuteCommand, IsDuplicateAccelerator, IToolBar::DisabledEvents
			[id(DISPID_TBE_MAPACCELERATOR), helpstring("Will be fired if a keyboard accelerator character needs to be mapped to a tool bar button, so that the control can trigger the execution of the command associated with this button. This event may be disabled.")]
			void MapAccelerator(SHORT accelerator, IToolBarButton* startingPointOfSearch, VARIANT_BOOL resumingSearchWithFirstButton, IToolBarButton** matchingButton, VARIANT_BOOL* handledEvent);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] toolButton The tool bar button that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, HitTestConstants, IToolBar::DisabledEvents
			[id(DISPID_TBE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] toolButton The tool bar button that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, HitTestConstants, IToolBar::DisabledEvents
			[id(DISPID_TBE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] toolButton The tool bar button that the mouse cursor is located over. May be \c Nothing.
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IToolBar::DisabledEvents
			[id(DISPID_TBE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] toolButton The tool bar button that the mouse cursor is located over. May be
			///            \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, ButtonMouseEnter, MouseHover, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IToolBar::DisabledEvents
			[id(DISPID_TBE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c IToolBar::HoverTime property.
			///
			/// \param[in] toolButton The tool bar button that the mouse cursor is located over. May be
			///            \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IToolBar::HoverTime, HitTestConstants,
			///     ExtendedMouseButtonConstants, IToolBar::DisabledEvents
			[id(DISPID_TBE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] toolButton The tool bar button that the mouse cursor is located over. May be
			///            \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, ButtonMouseLeave, MouseHover, MouseMove, HitTestConstants,
			///     ExtendedMouseButtonConstants, IToolBar::DisabledEvents
			[id(DISPID_TBE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] toolButton The tool bar button that the mouse cursor is located over. May be
			///            \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, HitTestConstants, ExtendedMouseButtonConstants,
			///     IToolBar::DisabledEvents
			[id(DISPID_TBE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] toolButton The tool bar button that the mouse cursor is located over. May be
			///            \c Nothing.
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IToolBar::DisabledEvents
			[id(DISPID_TBE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>An OLE drag'n'drop operation was completed</em>
			///
			/// Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.
			///
			/// \param[in] data The object that holds the dragged data. The drop target may have added data to
			///            it.
			/// \param[in] performedEffect The performed drop effect. Any of the values (except \c odeScroll)
			///            defined by the \c OLEDropEffectConstants enumeration is valid.
			///
			/// \sa IToolBar::OLEDrag, OLEStartDrag, IOLEDataObject::GetData
			[id(DISPID_TBE_OLECOMPLETEDRAG), helpstring("Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.")]
			void OLECompleteDrag(IOLEDataObject* data, OLEDropEffectConstants performedEffect);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] dropTarget The button that is the nearest one from the mouse cursor's position.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, MouseUp, IToolBar::RegisterForOLEDragDrop,
			///     IToolBar::FinishOLEDragDrop, OLEDropEffectConstants, IToolBar::SetInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_TBE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IToolBarButton* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The button that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another button.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoClickButton If set to \c True, the button specified by \c dropTarget will be
			///                auto-clicked; otherwise not. See the following <strong>remarks</strong> section
			///                for details.
			///
			/// \remarks Auto-clicking is timered, i. e. the timer is started after this event, if the
			///          \c dropTarget parameter specifies another button than the last time this event was
			///          fired. Setting the \c autoClickButton parameter to \c False cancels the timer. If
			///          it isn't canceled, the button is clicked when the timer expires.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, MouseEnter, IToolBar::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, IToolBar::DragClickTime, IToolBar::SetInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_TBE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IToolBarButton** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoClickButton);
			/// \brief <em>The user has dragged the data into a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop
			/// target window.
			///
			/// \param[in] hWndPotentialTarget The potential drop target window's handle.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragLeavePotentialTarget, IToolBar::OLEDrag
			[id(DISPID_TBE_OLEDRAGENTERPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragEnterPotentialTarget(LONG hWndPotentialTarget);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The button that is the current target of the drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave, IToolBar::RegisterForOLEDragDrop,
			///     IToolBar::SetInsertMarkPosition, HitTestConstants
			[id(DISPID_TBE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, IToolBarButton* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user has dragged the data out of a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop
			/// target window.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragEnterPotentialTarget, IToolBar::OLEDrag
			[id(DISPID_TBE_OLEDRAGLEAVEPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragLeavePotentialTarget(void);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] dropTarget The button that is the current target of the drag'n'drop operation.
			///                You may set this parameter to another button.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoClickButton If set to \c True, the button specified by \c dropTarget will be
			///                auto-clicked; otherwise not. See the following <strong>remarks</strong> section
			///                for details.
			///
			/// \remarks Auto-clicking is timered, i. e. the timer is started after this event, if the
			///          \c dropTarget parameter specifies another button than the last time this event was
			///          fired. Setting the \c autoClickButton parameter to \c False cancels the timer. If
			///          it isn't canceled, the button is clicked when the timer expires.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, MouseMove, IToolBar::RegisterForOLEDragDrop,
			///     OLEDropEffectConstants, IToolBar::DragClickTime, IToolBar::SetInsertMarkPosition,
			///     HitTestConstants
			[id(DISPID_TBE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IToolBarButton** dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* autoClickButton);
			/// \brief <em>The mouse cursor needs to be updated during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the mouse cursor should be updated to visualize the
			/// current drop effect.
			///
			/// \param[in] effect The current drop effect. It is chosen by the potential drop target.
			///            Any of the values defined by the \c OLEDropEffectConstants enumeration is valid.
			/// \param[in,out] useDefaultCursors If set to \c True, the system's default mouse cursors are
			///                used to visualize the various drop effects. If set to \c False, custom
			///                mouse cursors are used. You must set the custom cursor within the handler of
			///                this event.
			///
			/// \sa IToolBar::OLEDrag, OLEQueryContinueDrag, OLEDropEffectConstants
			[id(DISPID_TBE_OLEGIVEFEEDBACK), helpstring("Will be fired during OLE drag'n'drop if the mouse cursor should be updated.")]
			void OLEGiveFeedback(OLEDropEffectConstants effect, VARIANT_BOOL* useDefaultCursors);
			/// \brief <em>The drag source should decide how to proceed with the OLE drag'n'drop operation</em>
			///
			/// Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed. It
			/// gives the drag source the chance to cancel or complete the drag'n'drop operation.
			///
			/// \param[in] pressedEscape If \c True, the user has pressed the \c ESC key since the last time
			///            this event was fired.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in,out] actionToContinueWith Indicates whether to continue, cancel or complete the
			///                drag'n'drop operation. Any of the values defined by the
			///                \c OLEActionToContinueWithConstants enumeration is valid.
			///
			/// \sa IToolBar::OLEDrag, OLEGiveFeedback, OLEActionToContinueWithConstants
			[id(DISPID_TBE_OLEQUERYCONTINUEDRAG), helpstring("Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed.")]
			void OLEQueryContinueDrag(VARIANT_BOOL pressedEscape, SHORT button, SHORT shift, OLEActionToContinueWithConstants* actionToContinueWith);
			/// \brief <em>Data has been stored in the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data in the specified format has been written into the
			/// dragged data object.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the data object has received data for.
			///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
			///            other format that has been registered using the \c RegisterClipboardFormat API
			///            function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLESetData, IOLEDataObject::GetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_TBE_OLERECEIVEDNEWDATA), helpstring("Will be fired during OLE drag'n'drop if data in the specified format has been written into the dragged data object.")]
			void OLEReceivedNewData(IOLEDataObject* data, LONG formatID, LONG Index, LONG dataOrViewAspect);
			/// \brief <em>Data is requested from the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data
			/// format, that you've chosen to support (in the \c OLEStartDrag event), but for which you didn't
			/// provide any data so far.\n
			/// Call the provided object's \c SetData method to provide the data. If you chose to not support
			/// this data format, simply do nothing.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the drop target is requesting data
			///            for. Valid values are those defined by VB's \c ClipBoardConstants enumeration, but
			///            also any other format that has been registered using the \c RegisterClipboardFormat
			///            API function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLEStartDrag, IOLEDataObject::SetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_TBE_OLESETDATA), helpstring("Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data format, that you've chosen to support (in the 'OLEStartDrag' event), but for which you didn't provide any data so far.")]
			void OLESetData(IOLEDataObject* data, LONG formatID, LONG index, LONG dataOrViewAspect);
			/// \brief <em>The container holding the dragged data needs to be filled up</em>
			///
			/// Will be fired after you called the \c OLEDrag method to determine the data you're offering. You
			/// must call the provided object's \c SetData method for each data format you're offering data in.
			///
			/// \param[in] data The object that holds the dragged data.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa IToolBar::OLEDrag, OLESetData, OLECompleteDrag, IOLEDataObject::SetData
			[id(DISPID_TBE_OLESTARTDRAG), helpstring("Will be fired after you called the 'OLEDrag' method to determine the data you're offering.")]
			void OLEStartDrag(IOLEDataObject* data);
			/// \brief <em>A popup menu is about to be displayed</em>
			///
			/// Will be fired if a popup menu is about to be displayed. Use this event to e.g. modify the menu
			/// before it is displayed.
			///
			/// \param[in] hMenu The handle of the menu that is about to be displayed.
			/// \param[in] parentMenuItemIndex The zero-based index of the parent menu item within its containing
			///            menu.
			/// \param[in] isSystemMenu If \c True, \c hMenu is a window's system menu; otherwise it is a normal
			///            menu.
			///
			/// \sa IToolBar::MenuMode, SelectedMenuItem, ButtonGetDropDownMenu
			[id(DISPID_TBE_OPENPOPUPMENU), helpstring("Will be fired if a popup menu is about to be displayed. Use this event to e.g. modify the menu before it is displayed.")]
			void OpenPopupMenu(LONG hMenu, LONG parentMenuItemIndex, VARIANT_BOOL isSystemMenu);
			/// \brief <em>The customization dialog needs to know where new buttons can be inserted</em>
			///
			/// Will be fired if the customization dialog is being opened and the control needs to know where to
			/// allow insertion of new buttons.
			///
			/// \param[in] toolButton The tool bar button for which the control needs to know whether it shall
			///            allow inserting a new button to the left of this button.
			/// \param[in,out] allowInsertionToLeft If set to \c True, the customization dialog allows inserting
			///                a button to the left of the specified button; otherwise not.
			///
			/// \sa QueryRemoveButton, BeginCustomization, EndCustomization, GetAvailableButton,
			///     IToolBar::AllowCustomization, IToolBar::Customize
			[id(DISPID_TBE_QUERYINSERTBUTTON), helpstring("Will be fired if the customization dialog is being opened and the control needs to know where to allow insertion of new buttons.")]
			void QueryInsertButton(IToolBarButton* toolButton, VARIANT_BOOL* allowInsertionToLeft);
			/// \brief <em>The customization dialog needs to know whether a tool bar button may be removed</em>
			///
			/// Will be fired if the customization dialog is being opened and the control needs to know which
			/// tool bar buttons may be removed.
			///
			/// \param[in] toolButton The tool bar button for which the control needs to know whether it may be
			///            removed by the user.
			/// \param[in,out] allowRemoval If set to \c True, the customization dialog allows removing the
			///                specified button; otherwise not.
			///
			/// \sa QueryInsertButton, CustomizeDialogRemovingButton, BeginCustomization, EndCustomization,
			///     IToolBar::AllowCustomization, IToolBar::Customize
			[id(DISPID_TBE_QUERYREMOVEBUTTON), helpstring("Will be fired if the customization dialog is being opened and the control needs to know which tool bar buttons may be removed.")]
			void QueryRemoveButton(IToolBarButton* toolButton, VARIANT_BOOL* allowRemoval);
			/// \brief <em>A menu message needs to be processed</em>
			///
			/// Will be fired if a menu message has been received. Use this event to e.g. forward the menu
			/// message to \c IContextMenu3::HandleMenuMsg2.
			///
			/// \param[in] message The received message. The event is fired for the following messages:
			///            - \c WM_DRAWITEM
			///            - \c WM_INITMENUPOPUP
			///            - \c WM_MEASUREITEM
			///            - \c WM_MENUCHAR
			///            - \c WM_MENUSELECT
			///            - \c WM_NEXTMENU
			/// \param[in] wParam The message's \c wParam parameter.
			/// \param[in] lParam The message's \c lParam parameter.
			/// \param[out] result If the message has been handled, this parameter must be set to an appropriate
			///             return value as specified by the docs for this message.
			/// \param[out] handledEvent If the message has been handled, this parameter must be set to \c True.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IToolBar::MenuMode, SelectedMenuItem, OpenPopupMenu, ButtonGetDropDownMenu,
			///     IToolBar::DisabledEvents,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776085.aspx">IContextMenu3::HandleMenuMsg2</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb775923.aspx">WM_DRAWITEM</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms646347.aspx">WM_INITMENUPOPUP</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb775925.aspx">WM_MEASUREITEM</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms646349.aspx">WM_MENUCHAR</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms646352.aspx">WM_MENUSELECT</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms647612.aspx">WM_NEXTMENU</a>
			[id(DISPID_TBE_RAWMENUMESSAGE), helpstring("Will be fired if a menu message has been received. Use this event to e.g. forward the menu message to 'IContextMenu3.HandleMenuMsg2'. This event may be disabled.")]
			void RawMenuMessage(LONG message, LONG wParam, LONG lParam, LONG* result, VARIANT_BOOL* handledEvent);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] toolButton The tool bar button that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, HitTestConstants, IToolBar::DisabledEvents
			[id(DISPID_TBE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] toolButton The tool bar button that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, HitTestConstants, IToolBar::DisabledEvents
			[id(DISPID_TBE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IToolBar::hWnd
			[id(DISPID_TBE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>A tool bar button was removed</em>
			///
			/// Will be fired after a tool bar button was removed.
			///
			/// \param[in] toolButton The tool bar button that was removed. If \c Nothing, all buttons were
			///            removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovingButton, InsertedButton, IVirtualToolBarButton, IToolBar::DisabledEvents
			[id(DISPID_TBE_REMOVEDBUTTON), helpstring("Will be fired after a tool bar button was removed. If 'toolButton' is 'Nothing', all buttons were removed. This event may be disabled.")]
			void RemovedButton(IVirtualToolBarButton* toolButton);
			/// \brief <em>A tool bar button is about to be removed</em>
			///
			/// Will be fired before a tool bar button is removed.
			///
			/// \param[in] toolButton The tool bar button that is about to be removed. If \c Nothing, all buttons
			///            are removed.
			/// \param[in,out] cancelDeletion If set to \c True, deletion is aborted, i. e. the button isn't
			///                removed. If set to \c False, the button is removed.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RemovedButton, InsertingButton, IToolBarButton, IToolBar::DisabledEvents
			[id(DISPID_TBE_REMOVINGBUTTON), helpstring("Will be fired before a tool bar button is removed. If 'toolButton' is 'Nothing', all buttons are removed. This event may be disabled.")]
			void RemovingButton(IToolBarButton* toolButton, VARIANT_BOOL* cancelDeletion);
			/// \brief <em>The user clicked the customization dialog's reset button</em>
			///
			/// Will be fired if the user clicked the reset button in the customization dialog.
			///
			/// \param[in] hCustomizationDialog The window handle of the customization dialog.
			/// \param[in,out] endCustomization If set to \c True, customization is ended, i. e. the
			///                customization dialog is closed. If set to \c False, the dialog remains opened.
			///
			/// \sa BeginCustomization, EndCustomization, IToolBar::Customize
			[id(DISPID_TBE_RESETCUSTOMIZATIONS), helpstring("Will be fired if the user clicked the reset button in the customization dialog.")]
			void ResetCustomizations(LONG hCustomizationDialog, VARIANT_BOOL* EndCustomization);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_TBE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The tool bar state is being restored from a registry value</em>
			///
			/// Will be fired if a specific tool bar button's state is being restored from a binary registry
			/// value. This event can be used to load additional data from the registry value.
			///
			/// \param[in] toolButton The tool bar button that is being restored.
			/// \param[in] numberOfButtonsToLoad The number of tool bar buttons that is being restored from the
			///            data stream.
			/// \param[in] totalDataSize The total size of the data stream in bytes.
			/// \param[in] perButtonDataSize The number of bytes that hold the control-defined part of a single
			///            button's state. The stream may contain additional application-defined data.
			/// \param[in] pDataStream The memory address where the tool bar state and the application-defined
			///            data are loaded from.
			/// \param[in,out] pStartOfNextDataBlock The (absolute) memory address of the first byte within the
			///                data stream that contains application-defined data for the specified button. When
			///                leaving the event handler, \c pStartOfNextDataBlock must point to the first byte
			///                after this application-defined data.
			///
			/// \remarks If an application does not need to load additional data when restoring the tool bar
			///          state, it does not need to handle this event.
			///
			/// \sa SaveButtonToRegistryStream, InitializeToolBarStateRegistryRestorage,
			///     IToolBar::LoadToolBarStateFromRegistry
			[id(DISPID_TBE_RESTOREBUTTONFROMREGISTRYSTREAM), helpstring("Will be fired if a specific tool bar button's state is being restored from a binary registry value. This event can be used to load additional data from the registry value.")]
			void RestoreButtonFromRegistryStream(IVirtualToolBarButton* toolButton, LONG numberOfButtonsToLoad, LONG totalDataSize, LONG perButtonDataSize, LONG pDataStream, LONG* pStartOfNextDataBlock);
			/// \brief <em>The tool bar state is being stored into a registry value</em>
			///
			/// Will be fired if a specific tool bar button's state is being written to a binary registry value.
			/// This event can be used to store additional data into the registry value.
			///
			/// \param[in] toolButton The tool bar button that needs to be stored.
			/// \param[in] totalDataSize The total size of the data stream in bytes.
			/// \param[in] pDataStream The memory address where the tool bar state and the application-defined
			///            data is written to.
			/// \param[in,out] pStartOfUnusedSpace The (absolute) memory address of the first unused byte within
			///                the data stream. The application can write data to this address. When leaving the
			///                event handler, \c pStartOfUnusedSpace must point to the first byte that the
			///                control can write to without overwriting the application-defined data.
			///
			/// \remarks If an application does not need to store additional data when storing the tool bar
			///          state, it does not need to handle this event.
			///
			/// \sa RestoreButtonFromRegistryStream, InitializeToolBarStateRegistryStorage,
			///     IToolBar::SaveToolBarStateToRegistry
			[id(DISPID_TBE_SAVEBUTTONTOREGISTRYSTREAM), helpstring("Will be fired if a specific tool bar button's state is being written to a binary registry value. This event can be used to store additional data into the registry value.")]
			void SaveButtonToRegistryStream(IVirtualToolBarButton* toolButton, LONG totalDataSize, LONG pDataStream, LONG* pStartOfUnusedSpace);
			/// \brief <em>The user has selected a menu item</em>
			///
			/// Will be fired if the user has selected a menu item. Use this event to e.g. display an
			/// explanatory text in the status bar.
			///
			/// \param[in] commandIDOrSubMenuIndex The unique ID of the selected menu command. If the menu item
			///            opens a sub-menu, this parameter contains the zero-based index of the menu item within
			///            its containing menu. If the menu is closed, this parameter will be 0.
			/// \param[in] menuItemState A bit-field describing the state of the menu item. Any combination of
			///            the values defined by the \c MenuItemStateConstants enumeration is valid. If the menu
			///            is closed, this parameter will be 0xFFFF.
			/// \param[in] hMenu The handle of the menu that contains the selected menu item. If the menu is
			///            closed, this parameter will be 0.
			///
			/// \sa IToolBar::MenuMode, OpenPopupMenu, ButtonGetDropDownMenu, MenuItemStateConstants
			[id(DISPID_TBE_SELECTEDMENUITEM), helpstring("Will be fired if the user has selected a menu item. Use this event to e.g. display an explanatory text in the status bar.")]
			void SelectedMenuItem(LONG commandIDOrSubMenuIndex, MenuItemStateConstants menuItemState, LONG hMenu);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] toolButton The tool bar button that was clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IToolBar::DisabledEvents
			[id(DISPID_TBE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] toolButton The tool bar button that was double-clicked. May be \c Nothing.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, HitTestConstants, ExtendedMouseButtonConstants,
			///     IToolBar::DisabledEvents
			[id(DISPID_TBE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(IToolBarButton* toolButton, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	};


	/// \brief <em>The \c ToolBar class</em>
	///
	/// The control's main COM class. It implements the \c IToolBar and
	/// \c _IToolBarEvents interfaces.
	///
	/// \sa IToolBar, _IToolBarEvents
	[
		uuid(AF5A99F8-1DD4-43bd-963F-996E82D80992),
		version(1.3),
		helpstring("ToolBar Control 1.3 (ANSI)")
	]
	coclass ToolBar
	{
		[default] interface IToolBar;
		[default, source] dispinterface _IToolBarEvents;
	};


	[
		uuid(A46D4C3E-ECFB-4BD9-87C6-3C6F4C5744B2),
		version(1.3),
		noncreatable,
		helpstring("CommonProperties Class 1.3 (ANSI)"),
		hidden
	]
	coclass CommonProperties
	{
		[default] interface IUnknown;
	};
};
